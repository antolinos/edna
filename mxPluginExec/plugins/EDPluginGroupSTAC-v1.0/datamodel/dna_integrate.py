#!/usr/bin/env python



#################################################################
#
#   Project:   Python-Jython Asynchronous Action Library Project
#              http://pyaalib.sourceforge.net/
#              http://jyaalib.sourceforge.net/
#
#   Author(s): Romeu A. Pieritz - romeu.pieritz@gmail.com
#
#   Code Generated in Date:      Mon Jun  1 23:18:40 2009
#
#   License:
#   ----------------------------------------------
#   Python-Jython Asynchronous Action Library Project
#   Copyright (c) 2005-2008, PyAALib-JyAALib developers
#   All rights reserved.
#
#   Redistribution and use in source and binary forms,
#   with or without modification, are permitted
#   provided that the following conditions are met:
#
#   Redistributions of source code must retain the
#   above copyright notice,this list of conditions
#   and the following disclaimer.
#
#   Redistributions in binary form must reproduce
#   the above copyright notice,this list of conditions
#   and the following disclaimer in the documentation
#   and/or other materials provided with the distribution.
#
#   Neither the names of PyAALib-JyAALib's copyright owner
#   nor the names of its contributors may be used to endorse
#   or promote products derived from this software without
#   specific prior written permission.
#
#   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS
#   AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED
#   WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
#   IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
#   FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO
#   EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS
#   BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
#   SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
#   (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
#   SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA,
#   OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
#   CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER
#   IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
#   NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT
#   OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
#   THE POSSIBILITY OF SUCH DAMAGE.
#
################################################################
#
#
# Generated by ALExternalPackGenerateDS.py.
#
# This file is generated by a modified version of the original file:
# generateDS.py, proposed by Dave Kuhlman:
#
## LICENSE
#
## Copyright (c) 2003 Dave Kuhlman
#
## Permission is hereby granted, free of charge, to any person obtaining
## a copy of this software and associated documentation files (the
## "Software"), to deal in the Software without restriction, including
## without limitation the rights to use, copy, modify, merge, publish,
## distribute, sublicense, and/or sell copies of the Software, and to
## permit persons to whom the Software is furnished to do so, subject to
## the following conditions:
#
## The above copyright notice and this permission notice shall be
## included in all copies or substantial portions of the Software.
#
## THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
## EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
## MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
## IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
## CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
## TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
## SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
#
##############################################################################

import sys
import getopt
from xml.dom import minidom
from xml.dom import Node


#
# Support/utility functions.
#

def showIndent(outfile, level):
    for idx in range(level):
        outfile.write('    ')


def showIndentHtml(outfile, level):
    for idx in range(level):
        outfile.write(' &nbsp; &nbsp; &nbsp; &nbsp;')


def quote_xml(inStr):
    s1 = inStr
    s1 = s1.replace('&', '&amp;')
    s1 = s1.replace('<', '&lt;')
    s1 = s1.replace('"', '&quot;')
    return s1

def quote_python(inStr):
    s1 = inStr
    if s1.find("'") == -1:
        if s1.find('\n') == -1:
            return "'%s'" % s1
        else:
            return "'''%s'''" % s1
    else:
        if s1.find('"') != -1:
            s1 = s1.replace('"', '\\"')
        if s1.find('\n') == -1:
            return '"%s"' % s1
        else:
            return '"""%s"""' % s1


class MixedContainer(object):
    # Constants for category:
    CategoryNone = 0
    CategoryText = 1
    CategorySimple = 2
    CategoryComplex = 3
    # Constants for content_type:
    TypeNone = 0
    TypeText = 1
    TypeString = 2
    TypeInteger = 3
    TypeFloat = 4
    TypeDecimal = 5
    TypeDouble = 6
    TypeBoolean = 7
    def __init__(self, category, content_type, name, value):
        self.category = category
        self.content_type = content_type
        self.name = name
        self.value = value
    def getCategory(self):
        return self.category
    def getContenttype(self, content_type):
        return self.content_type
    def getValue(self):
        return self.value
    def getName(self):
        return self.name
    def export(self, outfile, level, name):
        if self.category == MixedContainer.CategoryText:
            outfile.write(self.value)
        elif self.category == MixedContainer.CategorySimple:
            self.exportSimple(outfile, level, name)
        else:    # category == MixedContainer.CategoryComplex
            self.value.export(outfile, level, name)
    def exportSimple(self, outfile, level, name):
        if self.content_type == MixedContainer.TypeString:
            outfile.write('<%s>%s</%s>' % (self.name, self.value, self.name))
        elif self.content_type == MixedContainer.TypeInteger or \
                self.content_type == MixedContainer.TypeBoolean:
            outfile.write('<%s>%d</%s>' % (self.name, self.value, self.name))
        elif self.content_type == MixedContainer.TypeFloat or \
                self.content_type == MixedContainer.TypeDecimal:
            outfile.write('<%s>%f</%s>' % (self.name, self.value, self.name))
        elif self.content_type == MixedContainer.TypeDouble:
            outfile.write('<%s>%g</%s>' % (self.name, self.value, self.name))
    def exportLiteral(self, outfile, level, name):
        if self.category == MixedContainer.CategoryText:
            showIndent(outfile, level)
            outfile.write('MixedContainer(%d, %d, "%s", "%s"),\n' % \
                (self.category, self.content_type, self.name, self.value))
        elif self.category == MixedContainer.CategorySimple:
            showIndent(outfile, level)
            outfile.write('MixedContainer(%d, %d, "%s", "%s"),\n' % \
                (self.category, self.content_type, self.name, self.value))
        else:    # category == MixedContainer.CategoryComplex
            showIndent(outfile, level)
            outfile.write('MixedContainer(%d, %d, "%s",\n' % \
                (self.category, self.content_type, self.name,))
            self.value.exportLiteral(outfile, level + 1)
            showIndent(outfile, level)
            outfile.write(')\n')



TEMPLATE_PAGE_P1 = """
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN" "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en">
<head>
    <title>AALib Plugin Data Description</title>
    <meta http-equiv="content-type" content="text/html; charset=utf-8">
    <meta name="description" content="AALib Plugin generation from XSD files">
    <meta name="keywords" content="AALib, xsd, plugin">
    <meta name="author" content="Romeu Pieritz(romeu_pieritz@yahoo.fr)">
    <link href="style.css" rel="stylesheet" type="text/css">
    <base target="main">
</head>
<body>
    <div id="main">
        <div id="block">
          %s
    </div>
"""

TEMPLATE_PAGE_P2 = """
    </div>
</body>
</html>
"""



#
# Class definition
#

class integrate_request(object):
    subclass = None
    def __init__(self, extra_commands=None, start=-1, end=-1, number_of_batches=-1, fileinfo=None):
        self.extra_commands = extra_commands
        self.start = start
        self.end = end
        self.number_of_batches = number_of_batches
        self.fileinfo = fileinfo
    def factory(*args_, **kwargs_):
        if integrate_request.subclass:
            return integrate_request.subclass(*args_, **kwargs_)
        else:
            return integrate_request(*args_, **kwargs_)
    factory = staticmethod(factory)
    def getExtra_commands(self): return self.extra_commands
    def setExtra_commands(self, extra_commands): self.extra_commands = extra_commands
    def getStart(self): return self.start
    def setStart(self, start): self.start = start
    def getEnd(self): return self.end
    def setEnd(self, end): self.end = end
    def getNumber_of_batches(self): return self.number_of_batches
    def setNumber_of_batches(self, number_of_batches): self.number_of_batches = number_of_batches
    def getFileinfo(self): return self.fileinfo
    def setFileinfo(self, fileinfo): self.fileinfo = fileinfo
    def export(self, outfile, level = 0, name_='integrate_request'):
        showIndent(outfile, level)
        outfile.write('<%s>\n' % name_)
        self.exportChildren(outfile, level + 1, name_)
        showIndent(outfile, level)
        outfile.write('</%s>\n' % name_)
    def exportAttributes(self, outfile, level, name_='integrate_request'):
        pass
    def exportChildren(self, outfile, level, name_='integrate_request'):
        if self.extra_commands:
            self.extra_commands.export(outfile, level)
        showIndent(outfile, level)
        outfile.write('<start>%d</start>\n' % self.getStart())
        showIndent(outfile, level)
        outfile.write('<end>%d</end>\n' % self.getEnd())
        showIndent(outfile, level)
        outfile.write('<number_of_batches>%d</number_of_batches>\n' % self.getNumber_of_batches())
        if self.fileinfo:
            self.fileinfo.export(outfile, level)

    #Only to export the entire XML tree to a file stream on disk
    def outputFile( self, _outfileName ):
        outfile = open( _outfileName, "w" )
        outfile.write("<?xml version=\"1.0\" ?>\n")
        self.export( outfile, 0, name_='integrate_request' )
        outfile.close()


    #Only to export the entire XML tree to a Html Page in a file stream on disk
    def outputPageHtml( self, _outfileName ):
        odtStrTitle = "    <span class=\"title\">integrate_request:</span> <br> <br> <br>\n" 
        outfile = open( _outfileName, "w" )
        outfile.write( TEMPLATE_PAGE_P1 % ( odtStrTitle ) )
        self.exportLiteralHtml( outfile, 0, name_='integrate_request' )
        outfile.write( TEMPLATE_PAGE_P2  )
        outfile.close()


    def outputFileHtml( self, _outfileName ):
        self.outputPageHtml( _outfileName )



    #Static method for parsing a string
    def parseString( _inString ):
        doc = minidom.parseString(_inString)
        rootNode = doc.documentElement
        rootObj = integrate_request.factory()
        rootObj.build(rootNode)
        return rootObj
    parseString = staticmethod( parseString ) 


    #Method for marshalling an object
    def marshal( self ):
        oStreamString = StringIO.StringIO()
        oStreamString.write('<?xml version="1.0" ?>\n')
        self.export( oStreamString, 0, name_="integrate_request" )
        oStringXML = oStreamString.getvalue()
        oStreamString.close()
        return oStringXML

    def exportLiteral(self, outfile, level = 0, name_='integrate_request'):
        level += 1
        self.exportLiteralAttributes(outfile, level, name_)
        self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.extra_commands:
            showIndent(outfile, level)
            outfile.write('extra_commands = extra_commands(\n')
            self.extra_commands.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        showIndent(outfile, level)
        outfile.write('start = %d,\n' % self.getStart())
        showIndent(outfile, level)
        outfile.write('end = %d,\n' % self.getEnd())
        showIndent(outfile, level)
        outfile.write('number_of_batches = %d,\n' % self.getNumber_of_batches())
        if self.fileinfo:
            showIndent(outfile, level)
            outfile.write('fileinfo = fileinfo(\n')
            self.fileinfo.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
    def exportLiteralHtml(self, outfile, level = 0, name_='integrate_request'):
        level += 1
        self.exportLiteralAttributesHtml(outfile, level, name_)
        self.exportLiteralChildrenHtml(outfile, level, name_)
    def exportLiteralAttributesHtml(self, outfile, level, name_):
        pass
    def exportLiteralChildrenHtml(self, outfile, level, name_):
        if self.extra_commands:
            showIndentHtml(outfile, level)
            outfile.write('extra_commands<br>\n')
            self.extra_commands.exportLiteralHtml(outfile, level)
            showIndentHtml(outfile, level)
            outfile.write('<br>\n')
        showIndentHtml(outfile, level)
        outfile.write('start = <a  href:"#">%d</a><br>\n' % self.getStart())
        showIndentHtml(outfile, level)
        outfile.write('end = <a  href:"#">%d</a><br>\n' % self.getEnd())
        showIndentHtml(outfile, level)
        outfile.write('number_of_batches = <a  href:"#">%d</a><br>\n' % self.getNumber_of_batches())
        if self.fileinfo:
            showIndentHtml(outfile, level)
            outfile.write('fileinfo<br>\n')
            self.fileinfo.exportLiteralHtml(outfile, level)
            showIndentHtml(outfile, level)
            outfile.write('<br>\n')
    def build(self, node_):
        attrs = node_.attributes
        self.buildAttributes(attrs)
        for child_ in node_.childNodes:
            nodeName_ = child_.nodeName.split(':')[-1]
            self.buildChildren(child_, nodeName_)
    def buildAttributes(self, attrs):
        pass
    def buildChildren(self, child_, nodeName_):
        if child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'extra_commands':
            obj_ = extra_commands.factory()
            obj_.build(child_)
            self.setExtra_commands(obj_)
        elif child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'start':
            if child_.firstChild:
                sval_ = child_.firstChild.nodeValue
                try:
                    ival_ = int(sval_)
                except ValueError:
                    raise ValueError('requires integer -- %s' % child_.toxml())
                self.start = ival_
        elif child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'end':
            if child_.firstChild:
                sval_ = child_.firstChild.nodeValue
                try:
                    ival_ = int(sval_)
                except ValueError:
                    raise ValueError('requires integer -- %s' % child_.toxml())
                self.end = ival_
        elif child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'number_of_batches':
            if child_.firstChild:
                sval_ = child_.firstChild.nodeValue
                try:
                    ival_ = int(sval_)
                except ValueError:
                    raise ValueError('requires integer -- %s' % child_.toxml())
                self.number_of_batches = ival_
        elif child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'fileinfo':
            obj_ = fileinfo.factory()
            obj_.build(child_)
            self.setFileinfo(obj_)
# end class integrate_request


class single_integrate_request(object):
    subclass = None
    def __init__(self, extra_commands=None, image=None, fileinfo=None, I_over_sigma=0.0):
        self.extra_commands = extra_commands
        if image is None:
            self.image = []
        else:
            self.image = image
        self.fileinfo = fileinfo
        self.I_over_sigma = I_over_sigma
    def factory(*args_, **kwargs_):
        if single_integrate_request.subclass:
            return single_integrate_request.subclass(*args_, **kwargs_)
        else:
            return single_integrate_request(*args_, **kwargs_)
    factory = staticmethod(factory)
    def getExtra_commands(self): return self.extra_commands
    def setExtra_commands(self, extra_commands): self.extra_commands = extra_commands
    def getImage(self): return self.image
    def setImage(self, image): self.image = image
    def addImage(self, value): self.image.append(value)
    def insertImage(self, index, value): self.image[index] = value
    def getFileinfo(self): return self.fileinfo
    def setFileinfo(self, fileinfo): self.fileinfo = fileinfo
    def getI_over_sigma(self): return self.I_over_sigma
    def setI_over_sigma(self, I_over_sigma): self.I_over_sigma = I_over_sigma
    def export(self, outfile, level = 0, name_='single_integrate_request'):
        showIndent(outfile, level)
        outfile.write('<%s>\n' % name_)
        self.exportChildren(outfile, level + 1, name_)
        showIndent(outfile, level)
        outfile.write('</%s>\n' % name_)
    def exportAttributes(self, outfile, level, name_='single_integrate_request'):
        pass
    def exportChildren(self, outfile, level, name_='single_integrate_request'):
        if self.extra_commands:
            self.extra_commands.export(outfile, level)
        for image_ in self.getImage():
            showIndent(outfile, level)
            outfile.write('<image>%d</image>\n' % image_)
        if self.fileinfo:
            self.fileinfo.export(outfile, level)
        showIndent(outfile, level)
        outfile.write('<I_over_sigma>%e</I_over_sigma>\n' % self.getI_over_sigma())

    #Only to export the entire XML tree to a file stream on disk
    def outputFile( self, _outfileName ):
        outfile = open( _outfileName, "w" )
        outfile.write("<?xml version=\"1.0\" ?>\n")
        self.export( outfile, 0, name_='single_integrate_request' )
        outfile.close()


    #Only to export the entire XML tree to a Html Page in a file stream on disk
    def outputPageHtml( self, _outfileName ):
        odtStrTitle = "    <span class=\"title\">single_integrate_request:</span> <br> <br> <br>\n" 
        outfile = open( _outfileName, "w" )
        outfile.write( TEMPLATE_PAGE_P1 % ( odtStrTitle ) )
        self.exportLiteralHtml( outfile, 0, name_='single_integrate_request' )
        outfile.write( TEMPLATE_PAGE_P2  )
        outfile.close()


    def outputFileHtml( self, _outfileName ):
        self.outputPageHtml( _outfileName )



    #Static method for parsing a string
    def parseString( _inString ):
        doc = minidom.parseString(_inString)
        rootNode = doc.documentElement
        rootObj = single_integrate_request.factory()
        rootObj.build(rootNode)
        return rootObj
    parseString = staticmethod( parseString ) 


    #Method for marshalling an object
    def marshal( self ):
        oStreamString = StringIO.StringIO()
        oStreamString.write('<?xml version="1.0" ?>\n')
        self.export( oStreamString, 0, name_="single_integrate_request" )
        oStringXML = oStreamString.getvalue()
        oStreamString.close()
        return oStringXML

    def exportLiteral(self, outfile, level = 0, name_='single_integrate_request'):
        level += 1
        self.exportLiteralAttributes(outfile, level, name_)
        self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.extra_commands:
            showIndent(outfile, level)
            outfile.write('extra_commands = extra_commands(\n')
            self.extra_commands.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        showIndent(outfile, level)
        outfile.write('image=[\n')
        level += 1
        for image in self.image:
            showIndent(outfile, level)
            outfile.write('%d,\n' % image)
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        if self.fileinfo:
            showIndent(outfile, level)
            outfile.write('fileinfo = fileinfo(\n')
            self.fileinfo.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        showIndent(outfile, level)
        outfile.write('I_over_sigma = %e,\n' % self.getI_over_sigma())
    def exportLiteralHtml(self, outfile, level = 0, name_='single_integrate_request'):
        level += 1
        self.exportLiteralAttributesHtml(outfile, level, name_)
        self.exportLiteralChildrenHtml(outfile, level, name_)
    def exportLiteralAttributesHtml(self, outfile, level, name_):
        pass
    def exportLiteralChildrenHtml(self, outfile, level, name_):
        if self.extra_commands:
            showIndentHtml(outfile, level)
            outfile.write('extra_commands<br>\n')
            self.extra_commands.exportLiteralHtml(outfile, level)
            showIndentHtml(outfile, level)
            outfile.write('<br>\n')
        showIndentHtml(outfile, level)
        outfile.write('image<br>\n')
        level += 1
        for image in self.image:
            showIndentHtml(outfile, level)
            outfile.write('<a  href:"#">%d</a><br>\n' % image)
        level -= 1
        showIndentHtml(outfile, level)
        outfile.write('<br>\n')
        if self.fileinfo:
            showIndentHtml(outfile, level)
            outfile.write('fileinfo<br>\n')
            self.fileinfo.exportLiteralHtml(outfile, level)
            showIndentHtml(outfile, level)
            outfile.write('<br>\n')
        showIndentHtml(outfile, level)
        outfile.write('I_over_sigma = <a  href:"#">%e</a><br>\n' % self.getI_over_sigma())
    def build(self, node_):
        attrs = node_.attributes
        self.buildAttributes(attrs)
        for child_ in node_.childNodes:
            nodeName_ = child_.nodeName.split(':')[-1]
            self.buildChildren(child_, nodeName_)
    def buildAttributes(self, attrs):
        pass
    def buildChildren(self, child_, nodeName_):
        if child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'extra_commands':
            obj_ = extra_commands.factory()
            obj_.build(child_)
            self.setExtra_commands(obj_)
        elif child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'image':
            if child_.firstChild:
                sval_ = child_.firstChild.nodeValue
                try:
                    ival_ = int(sval_)
                except ValueError:
                    raise ValueError('requires integer -- %s' % child_.toxml())
                self.image.append(ival_)
        elif child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'fileinfo':
            obj_ = fileinfo.factory()
            obj_.build(child_)
            self.setFileinfo(obj_)
        elif child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'I_over_sigma':
            if child_.firstChild:
                sval_ = child_.firstChild.nodeValue
                try:
                    fval_ = float(sval_)
                except ValueError:
                    raise ValueError('requires float (or double) -- %s' % child_.toxml())
                self.I_over_sigma = fval_
# end class single_integrate_request


class integrate_response(object):
    subclass = None
    def __init__(self, status=None, integrated_image=None, calculated_resolution=None):
        self.status = status
        if integrated_image is None:
            self.integrated_image = []
        else:
            self.integrated_image = integrated_image
        self.calculated_resolution = calculated_resolution
    def factory(*args_, **kwargs_):
        if integrate_response.subclass:
            return integrate_response.subclass(*args_, **kwargs_)
        else:
            return integrate_response(*args_, **kwargs_)
    factory = staticmethod(factory)
    def getStatus(self): return self.status
    def setStatus(self, status): self.status = status
    def getIntegrated_image(self): return self.integrated_image
    def setIntegrated_image(self, integrated_image): self.integrated_image = integrated_image
    def addIntegrated_image(self, value): self.integrated_image.append(value)
    def insertIntegrated_image(self, index, value): self.integrated_image[index] = value
    def getCalculated_resolution(self): return self.calculated_resolution
    def setCalculated_resolution(self, calculated_resolution): self.calculated_resolution = calculated_resolution
    def export(self, outfile, level = 0, name_='integrate_response'):
        showIndent(outfile, level)
        outfile.write('<%s>\n' % name_)
        self.exportChildren(outfile, level + 1, name_)
        showIndent(outfile, level)
        outfile.write('</%s>\n' % name_)
    def exportAttributes(self, outfile, level, name_='integrate_response'):
        pass
    def exportChildren(self, outfile, level, name_='integrate_response'):
        if self.status:
            self.status.export(outfile, level)
        for integrated_image_ in self.getIntegrated_image():
            integrated_image_.export(outfile, level)
        if self.calculated_resolution:
            self.calculated_resolution.export(outfile, level, name_='calculated_resolution')

    #Only to export the entire XML tree to a file stream on disk
    def outputFile( self, _outfileName ):
        outfile = open( _outfileName, "w" )
        outfile.write("<?xml version=\"1.0\" ?>\n")
        self.export( outfile, 0, name_='integrate_response' )
        outfile.close()


    #Only to export the entire XML tree to a Html Page in a file stream on disk
    def outputPageHtml( self, _outfileName ):
        odtStrTitle = "    <span class=\"title\">integrate_response:</span> <br> <br> <br>\n" 
        outfile = open( _outfileName, "w" )
        outfile.write( TEMPLATE_PAGE_P1 % ( odtStrTitle ) )
        self.exportLiteralHtml( outfile, 0, name_='integrate_response' )
        outfile.write( TEMPLATE_PAGE_P2  )
        outfile.close()


    def outputFileHtml( self, _outfileName ):
        self.outputPageHtml( _outfileName )



    #Static method for parsing a string
    def parseString( _inString ):
        doc = minidom.parseString(_inString)
        rootNode = doc.documentElement
        rootObj = integrate_response.factory()
        rootObj.build(rootNode)
        return rootObj
    parseString = staticmethod( parseString ) 


    #Method for marshalling an object
    def marshal( self ):
        oStreamString = StringIO.StringIO()
        oStreamString.write('<?xml version="1.0" ?>\n')
        self.export( oStreamString, 0, name_="integrate_response" )
        oStringXML = oStreamString.getvalue()
        oStreamString.close()
        return oStringXML

    def exportLiteral(self, outfile, level = 0, name_='integrate_response'):
        level += 1
        self.exportLiteralAttributes(outfile, level, name_)
        self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.status:
            showIndent(outfile, level)
            outfile.write('status = status(\n')
            self.status.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        showIndent(outfile, level)
        outfile.write('integrated_image=[\n')
        level += 1
        for integrated_image in self.integrated_image:
            showIndent(outfile, level)
            outfile.write('integrated_image(\n')
            integrated_image.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        if self.calculated_resolution:
            showIndent(outfile, level)
            outfile.write('calculated_resolution = resolution(\n')
            self.calculated_resolution.exportLiteral(outfile, level, name_='calculated_resolution')
            showIndent(outfile, level)
            outfile.write('),\n')
    def exportLiteralHtml(self, outfile, level = 0, name_='integrate_response'):
        level += 1
        self.exportLiteralAttributesHtml(outfile, level, name_)
        self.exportLiteralChildrenHtml(outfile, level, name_)
    def exportLiteralAttributesHtml(self, outfile, level, name_):
        pass
    def exportLiteralChildrenHtml(self, outfile, level, name_):
        if self.status:
            showIndentHtml(outfile, level)
            outfile.write('status<br>\n')
            self.status.exportLiteralHtml(outfile, level)
            showIndentHtml(outfile, level)
            outfile.write('<br>\n')
        showIndentHtml(outfile, level)
        outfile.write('integrated_image<br>\n')
        level += 1
        for integrated_image in self.integrated_image:
            integrated_image.exportLiteralHtml(outfile, level)
            showIndentHtml(outfile, level)
            outfile.write('<br>\n')
        level -= 1
        showIndentHtml(outfile, level)
        outfile.write('<br>\n')
        if self.calculated_resolution:
            showIndentHtml(outfile, level)
            outfile.write('calculated_resolution<br>\n')
            self.calculated_resolution.exportLiteralHtml(outfile, level, name_='calculated_resolution')
            showIndentHtml(outfile, level)
            outfile.write('<br>\n')
    def build(self, node_):
        attrs = node_.attributes
        self.buildAttributes(attrs)
        for child_ in node_.childNodes:
            nodeName_ = child_.nodeName.split(':')[-1]
            self.buildChildren(child_, nodeName_)
    def buildAttributes(self, attrs):
        pass
    def buildChildren(self, child_, nodeName_):
        if child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'status':
            obj_ = status.factory()
            obj_.build(child_)
            self.setStatus(obj_)
        elif child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'integrated_image':
            obj_ = integrated_image.factory()
            obj_.build(child_)
            self.integrated_image.append(obj_)
        elif child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'calculated_resolution':
            obj_ = resolution.factory()
            obj_.build(child_)
            self.setCalculated_resolution(obj_)
# end class integrate_response


class spot_information(object):
    subclass = None
    def __init__(self, full_spots=-1, partial_spots=-1, overlap_spots=-1, negative_spots=-1, bad_spots=-1):
        self.full_spots = full_spots
        self.partial_spots = partial_spots
        self.overlap_spots = overlap_spots
        self.negative_spots = negative_spots
        self.bad_spots = bad_spots
    def factory(*args_, **kwargs_):
        if spot_information.subclass:
            return spot_information.subclass(*args_, **kwargs_)
        else:
            return spot_information(*args_, **kwargs_)
    factory = staticmethod(factory)
    def getFull_spots(self): return self.full_spots
    def setFull_spots(self, full_spots): self.full_spots = full_spots
    def getPartial_spots(self): return self.partial_spots
    def setPartial_spots(self, partial_spots): self.partial_spots = partial_spots
    def getOverlap_spots(self): return self.overlap_spots
    def setOverlap_spots(self, overlap_spots): self.overlap_spots = overlap_spots
    def getNegative_spots(self): return self.negative_spots
    def setNegative_spots(self, negative_spots): self.negative_spots = negative_spots
    def getBad_spots(self): return self.bad_spots
    def setBad_spots(self, bad_spots): self.bad_spots = bad_spots
    def export(self, outfile, level = 0, name_='spot_information'):
        showIndent(outfile, level)
        outfile.write('<%s>\n' % name_)
        self.exportChildren(outfile, level + 1, name_)
        showIndent(outfile, level)
        outfile.write('</%s>\n' % name_)
    def exportAttributes(self, outfile, level, name_='spot_information'):
        pass
    def exportChildren(self, outfile, level, name_='spot_information'):
        showIndent(outfile, level)
        outfile.write('<full_spots>%d</full_spots>\n' % self.getFull_spots())
        showIndent(outfile, level)
        outfile.write('<partial_spots>%d</partial_spots>\n' % self.getPartial_spots())
        showIndent(outfile, level)
        outfile.write('<overlap_spots>%d</overlap_spots>\n' % self.getOverlap_spots())
        showIndent(outfile, level)
        outfile.write('<negative_spots>%d</negative_spots>\n' % self.getNegative_spots())
        showIndent(outfile, level)
        outfile.write('<bad_spots>%d</bad_spots>\n' % self.getBad_spots())

    #Only to export the entire XML tree to a file stream on disk
    def outputFile( self, _outfileName ):
        outfile = open( _outfileName, "w" )
        outfile.write("<?xml version=\"1.0\" ?>\n")
        self.export( outfile, 0, name_='spot_information' )
        outfile.close()


    #Only to export the entire XML tree to a Html Page in a file stream on disk
    def outputPageHtml( self, _outfileName ):
        odtStrTitle = "    <span class=\"title\">spot_information:</span> <br> <br> <br>\n" 
        outfile = open( _outfileName, "w" )
        outfile.write( TEMPLATE_PAGE_P1 % ( odtStrTitle ) )
        self.exportLiteralHtml( outfile, 0, name_='spot_information' )
        outfile.write( TEMPLATE_PAGE_P2  )
        outfile.close()


    def outputFileHtml( self, _outfileName ):
        self.outputPageHtml( _outfileName )



    #Static method for parsing a string
    def parseString( _inString ):
        doc = minidom.parseString(_inString)
        rootNode = doc.documentElement
        rootObj = spot_information.factory()
        rootObj.build(rootNode)
        return rootObj
    parseString = staticmethod( parseString ) 


    #Method for marshalling an object
    def marshal( self ):
        oStreamString = StringIO.StringIO()
        oStreamString.write('<?xml version="1.0" ?>\n')
        self.export( oStreamString, 0, name_="spot_information" )
        oStringXML = oStreamString.getvalue()
        oStreamString.close()
        return oStringXML

    def exportLiteral(self, outfile, level = 0, name_='spot_information'):
        level += 1
        self.exportLiteralAttributes(outfile, level, name_)
        self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('full_spots = %d,\n' % self.getFull_spots())
        showIndent(outfile, level)
        outfile.write('partial_spots = %d,\n' % self.getPartial_spots())
        showIndent(outfile, level)
        outfile.write('overlap_spots = %d,\n' % self.getOverlap_spots())
        showIndent(outfile, level)
        outfile.write('negative_spots = %d,\n' % self.getNegative_spots())
        showIndent(outfile, level)
        outfile.write('bad_spots = %d,\n' % self.getBad_spots())
    def exportLiteralHtml(self, outfile, level = 0, name_='spot_information'):
        level += 1
        self.exportLiteralAttributesHtml(outfile, level, name_)
        self.exportLiteralChildrenHtml(outfile, level, name_)
    def exportLiteralAttributesHtml(self, outfile, level, name_):
        pass
    def exportLiteralChildrenHtml(self, outfile, level, name_):
        showIndentHtml(outfile, level)
        outfile.write('full_spots = <a  href:"#">%d</a><br>\n' % self.getFull_spots())
        showIndentHtml(outfile, level)
        outfile.write('partial_spots = <a  href:"#">%d</a><br>\n' % self.getPartial_spots())
        showIndentHtml(outfile, level)
        outfile.write('overlap_spots = <a  href:"#">%d</a><br>\n' % self.getOverlap_spots())
        showIndentHtml(outfile, level)
        outfile.write('negative_spots = <a  href:"#">%d</a><br>\n' % self.getNegative_spots())
        showIndentHtml(outfile, level)
        outfile.write('bad_spots = <a  href:"#">%d</a><br>\n' % self.getBad_spots())
    def build(self, node_):
        attrs = node_.attributes
        self.buildAttributes(attrs)
        for child_ in node_.childNodes:
            nodeName_ = child_.nodeName.split(':')[-1]
            self.buildChildren(child_, nodeName_)
    def buildAttributes(self, attrs):
        pass
    def buildChildren(self, child_, nodeName_):
        if child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'full_spots':
            if child_.firstChild:
                sval_ = child_.firstChild.nodeValue
                try:
                    ival_ = int(sval_)
                except ValueError:
                    raise ValueError('requires integer -- %s' % child_.toxml())
                self.full_spots = ival_
        elif child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'partial_spots':
            if child_.firstChild:
                sval_ = child_.firstChild.nodeValue
                try:
                    ival_ = int(sval_)
                except ValueError:
                    raise ValueError('requires integer -- %s' % child_.toxml())
                self.partial_spots = ival_
        elif child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'overlap_spots':
            if child_.firstChild:
                sval_ = child_.firstChild.nodeValue
                try:
                    ival_ = int(sval_)
                except ValueError:
                    raise ValueError('requires integer -- %s' % child_.toxml())
                self.overlap_spots = ival_
        elif child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'negative_spots':
            if child_.firstChild:
                sval_ = child_.firstChild.nodeValue
                try:
                    ival_ = int(sval_)
                except ValueError:
                    raise ValueError('requires integer -- %s' % child_.toxml())
                self.negative_spots = ival_
        elif child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'bad_spots':
            if child_.firstChild:
                sval_ = child_.firstChild.nodeValue
                try:
                    ival_ = int(sval_)
                except ValueError:
                    raise ValueError('requires integer -- %s' % child_.toxml())
                self.bad_spots = ival_
# end class spot_information


class integration_summary(object):
    subclass = None
    def __init__(self, distance=0.0, yscale=0.0, overall_signal=0.0, outer_signal=0.0, spot_information=None):
        self.distance = distance
        self.yscale = yscale
        self.overall_signal = overall_signal
        self.outer_signal = outer_signal
        self.spot_information = spot_information
    def factory(*args_, **kwargs_):
        if integration_summary.subclass:
            return integration_summary.subclass(*args_, **kwargs_)
        else:
            return integration_summary(*args_, **kwargs_)
    factory = staticmethod(factory)
    def getDistance(self): return self.distance
    def setDistance(self, distance): self.distance = distance
    def getYscale(self): return self.yscale
    def setYscale(self, yscale): self.yscale = yscale
    def getOverall_signal(self): return self.overall_signal
    def setOverall_signal(self, overall_signal): self.overall_signal = overall_signal
    def getOuter_signal(self): return self.outer_signal
    def setOuter_signal(self, outer_signal): self.outer_signal = outer_signal
    def getSpot_information(self): return self.spot_information
    def setSpot_information(self, spot_information): self.spot_information = spot_information
    def export(self, outfile, level = 0, name_='integration_summary'):
        showIndent(outfile, level)
        outfile.write('<%s>\n' % name_)
        self.exportChildren(outfile, level + 1, name_)
        showIndent(outfile, level)
        outfile.write('</%s>\n' % name_)
    def exportAttributes(self, outfile, level, name_='integration_summary'):
        pass
    def exportChildren(self, outfile, level, name_='integration_summary'):
        showIndent(outfile, level)
        outfile.write('<distance>%e</distance>\n' % self.getDistance())
        showIndent(outfile, level)
        outfile.write('<yscale>%e</yscale>\n' % self.getYscale())
        showIndent(outfile, level)
        outfile.write('<overall_signal>%e</overall_signal>\n' % self.getOverall_signal())
        showIndent(outfile, level)
        outfile.write('<outer_signal>%e</outer_signal>\n' % self.getOuter_signal())
        if self.spot_information:
            self.spot_information.export(outfile, level)

    #Only to export the entire XML tree to a file stream on disk
    def outputFile( self, _outfileName ):
        outfile = open( _outfileName, "w" )
        outfile.write("<?xml version=\"1.0\" ?>\n")
        self.export( outfile, 0, name_='integration_summary' )
        outfile.close()


    #Only to export the entire XML tree to a Html Page in a file stream on disk
    def outputPageHtml( self, _outfileName ):
        odtStrTitle = "    <span class=\"title\">integration_summary:</span> <br> <br> <br>\n" 
        outfile = open( _outfileName, "w" )
        outfile.write( TEMPLATE_PAGE_P1 % ( odtStrTitle ) )
        self.exportLiteralHtml( outfile, 0, name_='integration_summary' )
        outfile.write( TEMPLATE_PAGE_P2  )
        outfile.close()


    def outputFileHtml( self, _outfileName ):
        self.outputPageHtml( _outfileName )



    #Static method for parsing a string
    def parseString( _inString ):
        doc = minidom.parseString(_inString)
        rootNode = doc.documentElement
        rootObj = integration_summary.factory()
        rootObj.build(rootNode)
        return rootObj
    parseString = staticmethod( parseString ) 


    #Method for marshalling an object
    def marshal( self ):
        oStreamString = StringIO.StringIO()
        oStreamString.write('<?xml version="1.0" ?>\n')
        self.export( oStreamString, 0, name_="integration_summary" )
        oStringXML = oStreamString.getvalue()
        oStreamString.close()
        return oStringXML

    def exportLiteral(self, outfile, level = 0, name_='integration_summary'):
        level += 1
        self.exportLiteralAttributes(outfile, level, name_)
        self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('distance = %e,\n' % self.getDistance())
        showIndent(outfile, level)
        outfile.write('yscale = %e,\n' % self.getYscale())
        showIndent(outfile, level)
        outfile.write('overall_signal = %e,\n' % self.getOverall_signal())
        showIndent(outfile, level)
        outfile.write('outer_signal = %e,\n' % self.getOuter_signal())
        if self.spot_information:
            showIndent(outfile, level)
            outfile.write('spot_information = spot_information(\n')
            self.spot_information.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
    def exportLiteralHtml(self, outfile, level = 0, name_='integration_summary'):
        level += 1
        self.exportLiteralAttributesHtml(outfile, level, name_)
        self.exportLiteralChildrenHtml(outfile, level, name_)
    def exportLiteralAttributesHtml(self, outfile, level, name_):
        pass
    def exportLiteralChildrenHtml(self, outfile, level, name_):
        showIndentHtml(outfile, level)
        outfile.write('distance = <a  href:"#">%e</a><br>\n' % self.getDistance())
        showIndentHtml(outfile, level)
        outfile.write('yscale = <a  href:"#">%e</a><br>\n' % self.getYscale())
        showIndentHtml(outfile, level)
        outfile.write('overall_signal = <a  href:"#">%e</a><br>\n' % self.getOverall_signal())
        showIndentHtml(outfile, level)
        outfile.write('outer_signal = <a  href:"#">%e</a><br>\n' % self.getOuter_signal())
        if self.spot_information:
            showIndentHtml(outfile, level)
            outfile.write('spot_information<br>\n')
            self.spot_information.exportLiteralHtml(outfile, level)
            showIndentHtml(outfile, level)
            outfile.write('<br>\n')
    def build(self, node_):
        attrs = node_.attributes
        self.buildAttributes(attrs)
        for child_ in node_.childNodes:
            nodeName_ = child_.nodeName.split(':')[-1]
            self.buildChildren(child_, nodeName_)
    def buildAttributes(self, attrs):
        pass
    def buildChildren(self, child_, nodeName_):
        if child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'distance':
            if child_.firstChild:
                sval_ = child_.firstChild.nodeValue
                try:
                    fval_ = float(sval_)
                except ValueError:
                    raise ValueError('requires float (or double) -- %s' % child_.toxml())
                self.distance = fval_
        elif child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'yscale':
            if child_.firstChild:
                sval_ = child_.firstChild.nodeValue
                try:
                    fval_ = float(sval_)
                except ValueError:
                    raise ValueError('requires float (or double) -- %s' % child_.toxml())
                self.yscale = fval_
        elif child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'overall_signal':
            if child_.firstChild:
                sval_ = child_.firstChild.nodeValue
                try:
                    fval_ = float(sval_)
                except ValueError:
                    raise ValueError('requires float (or double) -- %s' % child_.toxml())
                self.overall_signal = fval_
        elif child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'outer_signal':
            if child_.firstChild:
                sval_ = child_.firstChild.nodeValue
                try:
                    fval_ = float(sval_)
                except ValueError:
                    raise ValueError('requires float (or double) -- %s' % child_.toxml())
                self.outer_signal = fval_
        elif child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'spot_information':
            obj_ = spot_information.factory()
            obj_.build(child_)
            self.setSpot_information(obj_)
# end class integration_summary


class integrated_image(object):
    subclass = None
    def __init__(self, image=-1, integration_bin=None, integration_summary=None, refined_mosaic_spread=0.0, resolution=None):
        self.image = image
        if integration_bin is None:
            self.integration_bin = []
        else:
            self.integration_bin = integration_bin
        self.integration_summary = integration_summary
        self.refined_mosaic_spread = refined_mosaic_spread
        self.resolution = resolution
    def factory(*args_, **kwargs_):
        if integrated_image.subclass:
            return integrated_image.subclass(*args_, **kwargs_)
        else:
            return integrated_image(*args_, **kwargs_)
    factory = staticmethod(factory)
    def getImage(self): return self.image
    def setImage(self, image): self.image = image
    def getIntegration_bin(self): return self.integration_bin
    def setIntegration_bin(self, integration_bin): self.integration_bin = integration_bin
    def addIntegration_bin(self, value): self.integration_bin.append(value)
    def insertIntegration_bin(self, index, value): self.integration_bin[index] = value
    def getIntegration_summary(self): return self.integration_summary
    def setIntegration_summary(self, integration_summary): self.integration_summary = integration_summary
    def getRefined_mosaic_spread(self): return self.refined_mosaic_spread
    def setRefined_mosaic_spread(self, refined_mosaic_spread): self.refined_mosaic_spread = refined_mosaic_spread
    def getResolution(self): return self.resolution
    def setResolution(self, resolution): self.resolution = resolution
    def export(self, outfile, level = 0, name_='integrated_image'):
        showIndent(outfile, level)
        outfile.write('<%s>\n' % name_)
        self.exportChildren(outfile, level + 1, name_)
        showIndent(outfile, level)
        outfile.write('</%s>\n' % name_)
    def exportAttributes(self, outfile, level, name_='integrated_image'):
        pass
    def exportChildren(self, outfile, level, name_='integrated_image'):
        showIndent(outfile, level)
        outfile.write('<image>%d</image>\n' % self.getImage())
        for integration_bin_ in self.getIntegration_bin():
            integration_bin_.export(outfile, level)
        if self.integration_summary:
            self.integration_summary.export(outfile, level)
        showIndent(outfile, level)
        outfile.write('<refined_mosaic_spread>%e</refined_mosaic_spread>\n' % self.getRefined_mosaic_spread())
        if self.resolution:
            self.resolution.export(outfile, level)

    #Only to export the entire XML tree to a file stream on disk
    def outputFile( self, _outfileName ):
        outfile = open( _outfileName, "w" )
        outfile.write("<?xml version=\"1.0\" ?>\n")
        self.export( outfile, 0, name_='integrated_image' )
        outfile.close()


    #Only to export the entire XML tree to a Html Page in a file stream on disk
    def outputPageHtml( self, _outfileName ):
        odtStrTitle = "    <span class=\"title\">integrated_image:</span> <br> <br> <br>\n" 
        outfile = open( _outfileName, "w" )
        outfile.write( TEMPLATE_PAGE_P1 % ( odtStrTitle ) )
        self.exportLiteralHtml( outfile, 0, name_='integrated_image' )
        outfile.write( TEMPLATE_PAGE_P2  )
        outfile.close()


    def outputFileHtml( self, _outfileName ):
        self.outputPageHtml( _outfileName )



    #Static method for parsing a string
    def parseString( _inString ):
        doc = minidom.parseString(_inString)
        rootNode = doc.documentElement
        rootObj = integrated_image.factory()
        rootObj.build(rootNode)
        return rootObj
    parseString = staticmethod( parseString ) 


    #Method for marshalling an object
    def marshal( self ):
        oStreamString = StringIO.StringIO()
        oStreamString.write('<?xml version="1.0" ?>\n')
        self.export( oStreamString, 0, name_="integrated_image" )
        oStringXML = oStreamString.getvalue()
        oStreamString.close()
        return oStringXML

    def exportLiteral(self, outfile, level = 0, name_='integrated_image'):
        level += 1
        self.exportLiteralAttributes(outfile, level, name_)
        self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('image = %d,\n' % self.getImage())
        showIndent(outfile, level)
        outfile.write('integration_bin=[\n')
        level += 1
        for integration_bin in self.integration_bin:
            showIndent(outfile, level)
            outfile.write('integration_bin(\n')
            integration_bin.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        if self.integration_summary:
            showIndent(outfile, level)
            outfile.write('integration_summary = integration_summary(\n')
            self.integration_summary.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        showIndent(outfile, level)
        outfile.write('refined_mosaic_spread = %e,\n' % self.getRefined_mosaic_spread())
        if self.resolution:
            showIndent(outfile, level)
            outfile.write('resolution = resolution(\n')
            self.resolution.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
    def exportLiteralHtml(self, outfile, level = 0, name_='integrated_image'):
        level += 1
        self.exportLiteralAttributesHtml(outfile, level, name_)
        self.exportLiteralChildrenHtml(outfile, level, name_)
    def exportLiteralAttributesHtml(self, outfile, level, name_):
        pass
    def exportLiteralChildrenHtml(self, outfile, level, name_):
        showIndentHtml(outfile, level)
        outfile.write('image = <a  href:"#">%d</a><br>\n' % self.getImage())
        showIndentHtml(outfile, level)
        outfile.write('integration_bin<br>\n')
        level += 1
        for integration_bin in self.integration_bin:
            integration_bin.exportLiteralHtml(outfile, level)
            showIndentHtml(outfile, level)
            outfile.write('<br>\n')
        level -= 1
        showIndentHtml(outfile, level)
        outfile.write('<br>\n')
        if self.integration_summary:
            showIndentHtml(outfile, level)
            outfile.write('integration_summary<br>\n')
            self.integration_summary.exportLiteralHtml(outfile, level)
            showIndentHtml(outfile, level)
            outfile.write('<br>\n')
        showIndentHtml(outfile, level)
        outfile.write('refined_mosaic_spread = <a  href:"#">%e</a><br>\n' % self.getRefined_mosaic_spread())
        if self.resolution:
            showIndentHtml(outfile, level)
            outfile.write('resolution<br>\n')
            self.resolution.exportLiteralHtml(outfile, level)
            showIndentHtml(outfile, level)
            outfile.write('<br>\n')
    def build(self, node_):
        attrs = node_.attributes
        self.buildAttributes(attrs)
        for child_ in node_.childNodes:
            nodeName_ = child_.nodeName.split(':')[-1]
            self.buildChildren(child_, nodeName_)
    def buildAttributes(self, attrs):
        pass
    def buildChildren(self, child_, nodeName_):
        if child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'image':
            if child_.firstChild:
                sval_ = child_.firstChild.nodeValue
                try:
                    ival_ = int(sval_)
                except ValueError:
                    raise ValueError('requires integer -- %s' % child_.toxml())
                self.image = ival_
        elif child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'integration_bin':
            obj_ = integration_bin.factory()
            obj_.build(child_)
            self.integration_bin.append(obj_)
        elif child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'integration_summary':
            obj_ = integration_summary.factory()
            obj_.build(child_)
            self.setIntegration_summary(obj_)
        elif child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'refined_mosaic_spread':
            if child_.firstChild:
                sval_ = child_.firstChild.nodeValue
                try:
                    fval_ = float(sval_)
                except ValueError:
                    raise ValueError('requires float (or double) -- %s' % child_.toxml())
                self.refined_mosaic_spread = fval_
        elif child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'resolution':
            obj_ = resolution.factory()
            obj_.build(child_)
            self.setResolution(obj_)
# end class integrated_image


class spot_profile(object):
    subclass = None
    def __init__(self, width=-1, height=-1, profile='', mask=''):
        self.width = width
        self.height = height
        self.profile = profile
        self.mask = mask
    def factory(*args_, **kwargs_):
        if spot_profile.subclass:
            return spot_profile.subclass(*args_, **kwargs_)
        else:
            return spot_profile(*args_, **kwargs_)
    factory = staticmethod(factory)
    def getWidth(self): return self.width
    def setWidth(self, width): self.width = width
    def getHeight(self): return self.height
    def setHeight(self, height): self.height = height
    def getProfile(self): return self.profile
    def setProfile(self, profile): self.profile = profile
    def getMask(self): return self.mask
    def setMask(self, mask): self.mask = mask
    def export(self, outfile, level = 0, name_='spot_profile'):
        showIndent(outfile, level)
        outfile.write('<%s>\n' % name_)
        self.exportChildren(outfile, level + 1, name_)
        showIndent(outfile, level)
        outfile.write('</%s>\n' % name_)
    def exportAttributes(self, outfile, level, name_='spot_profile'):
        pass
    def exportChildren(self, outfile, level, name_='spot_profile'):
        showIndent(outfile, level)
        outfile.write('<width>%d</width>\n' % self.getWidth())
        showIndent(outfile, level)
        outfile.write('<height>%d</height>\n' % self.getHeight())
        showIndent(outfile, level)
        outfile.write('<profile>%s</profile>\n' % quote_xml(self.getProfile()))
        showIndent(outfile, level)
        outfile.write('<mask>%s</mask>\n' % quote_xml(self.getMask()))

    #Only to export the entire XML tree to a file stream on disk
    def outputFile( self, _outfileName ):
        outfile = open( _outfileName, "w" )
        outfile.write("<?xml version=\"1.0\" ?>\n")
        self.export( outfile, 0, name_='spot_profile' )
        outfile.close()


    #Only to export the entire XML tree to a Html Page in a file stream on disk
    def outputPageHtml( self, _outfileName ):
        odtStrTitle = "    <span class=\"title\">spot_profile:</span> <br> <br> <br>\n" 
        outfile = open( _outfileName, "w" )
        outfile.write( TEMPLATE_PAGE_P1 % ( odtStrTitle ) )
        self.exportLiteralHtml( outfile, 0, name_='spot_profile' )
        outfile.write( TEMPLATE_PAGE_P2  )
        outfile.close()


    def outputFileHtml( self, _outfileName ):
        self.outputPageHtml( _outfileName )



    #Static method for parsing a string
    def parseString( _inString ):
        doc = minidom.parseString(_inString)
        rootNode = doc.documentElement
        rootObj = spot_profile.factory()
        rootObj.build(rootNode)
        return rootObj
    parseString = staticmethod( parseString ) 


    #Method for marshalling an object
    def marshal( self ):
        oStreamString = StringIO.StringIO()
        oStreamString.write('<?xml version="1.0" ?>\n')
        self.export( oStreamString, 0, name_="spot_profile" )
        oStringXML = oStreamString.getvalue()
        oStreamString.close()
        return oStringXML

    def exportLiteral(self, outfile, level = 0, name_='spot_profile'):
        level += 1
        self.exportLiteralAttributes(outfile, level, name_)
        self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('width = %d,\n' % self.getWidth())
        showIndent(outfile, level)
        outfile.write('height = %d,\n' % self.getHeight())
        showIndent(outfile, level)
        outfile.write('profile = %s,\n' % quote_python(self.getProfile()))
        showIndent(outfile, level)
        outfile.write('mask = %s,\n' % quote_python(self.getMask()))
    def exportLiteralHtml(self, outfile, level = 0, name_='spot_profile'):
        level += 1
        self.exportLiteralAttributesHtml(outfile, level, name_)
        self.exportLiteralChildrenHtml(outfile, level, name_)
    def exportLiteralAttributesHtml(self, outfile, level, name_):
        pass
    def exportLiteralChildrenHtml(self, outfile, level, name_):
        showIndentHtml(outfile, level)
        outfile.write('width = <a  href:"#">%d</a><br>\n' % self.getWidth())
        showIndentHtml(outfile, level)
        outfile.write('height = <a  href:"#">%d</a><br>\n' % self.getHeight())
        showIndentHtml(outfile, level)
        outfile.write('profile = <a  href:"#">%s</a><br>\n' % quote_python(self.getProfile()))
        showIndentHtml(outfile, level)
        outfile.write('mask = <a  href:"#">%s</a><br>\n' % quote_python(self.getMask()))
    def build(self, node_):
        attrs = node_.attributes
        self.buildAttributes(attrs)
        for child_ in node_.childNodes:
            nodeName_ = child_.nodeName.split(':')[-1]
            self.buildChildren(child_, nodeName_)
    def buildAttributes(self, attrs):
        pass
    def buildChildren(self, child_, nodeName_):
        if child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'width':
            if child_.firstChild:
                sval_ = child_.firstChild.nodeValue
                try:
                    ival_ = int(sval_)
                except ValueError:
                    raise ValueError('requires integer -- %s' % child_.toxml())
                self.width = ival_
        elif child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'height':
            if child_.firstChild:
                sval_ = child_.firstChild.nodeValue
                try:
                    ival_ = int(sval_)
                except ValueError:
                    raise ValueError('requires integer -- %s' % child_.toxml())
                self.height = ival_
        elif child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'profile':
            profile_ = ''
            for text__content_ in child_.childNodes:
                profile_ += text__content_.nodeValue
            self.profile = profile_
        elif child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'mask':
            mask_ = ''
            for text__content_ in child_.childNodes:
                mask_ += text__content_.nodeValue
            self.mask = mask_
# end class spot_profile


class integration_bin(object):
    subclass = None
    def __init__(self, number=-1, resolution=None, measured_spots_profile=None, measured_spots_summation=None):
        self.number = number
        self.resolution = resolution
        self.measured_spots_profile = measured_spots_profile
        self.measured_spots_summation = measured_spots_summation
    def factory(*args_, **kwargs_):
        if integration_bin.subclass:
            return integration_bin.subclass(*args_, **kwargs_)
        else:
            return integration_bin(*args_, **kwargs_)
    factory = staticmethod(factory)
    def getNumber(self): return self.number
    def setNumber(self, number): self.number = number
    def getResolution(self): return self.resolution
    def setResolution(self, resolution): self.resolution = resolution
    def getMeasured_spots_profile(self): return self.measured_spots_profile
    def setMeasured_spots_profile(self, measured_spots_profile): self.measured_spots_profile = measured_spots_profile
    def getMeasured_spots_summation(self): return self.measured_spots_summation
    def setMeasured_spots_summation(self, measured_spots_summation): self.measured_spots_summation = measured_spots_summation
    def export(self, outfile, level = 0, name_='integration_bin'):
        showIndent(outfile, level)
        outfile.write('<%s>\n' % name_)
        self.exportChildren(outfile, level + 1, name_)
        showIndent(outfile, level)
        outfile.write('</%s>\n' % name_)
    def exportAttributes(self, outfile, level, name_='integration_bin'):
        pass
    def exportChildren(self, outfile, level, name_='integration_bin'):
        showIndent(outfile, level)
        outfile.write('<number>%d</number>\n' % self.getNumber())
        if self.resolution:
            self.resolution.export(outfile, level)
        if self.measured_spots_profile:
            self.measured_spots_profile.export(outfile, level, name_='measured_spots_profile')
        if self.measured_spots_summation:
            self.measured_spots_summation.export(outfile, level, name_='measured_spots_summation')

    #Only to export the entire XML tree to a file stream on disk
    def outputFile( self, _outfileName ):
        outfile = open( _outfileName, "w" )
        outfile.write("<?xml version=\"1.0\" ?>\n")
        self.export( outfile, 0, name_='integration_bin' )
        outfile.close()


    #Only to export the entire XML tree to a Html Page in a file stream on disk
    def outputPageHtml( self, _outfileName ):
        odtStrTitle = "    <span class=\"title\">integration_bin:</span> <br> <br> <br>\n" 
        outfile = open( _outfileName, "w" )
        outfile.write( TEMPLATE_PAGE_P1 % ( odtStrTitle ) )
        self.exportLiteralHtml( outfile, 0, name_='integration_bin' )
        outfile.write( TEMPLATE_PAGE_P2  )
        outfile.close()


    def outputFileHtml( self, _outfileName ):
        self.outputPageHtml( _outfileName )



    #Static method for parsing a string
    def parseString( _inString ):
        doc = minidom.parseString(_inString)
        rootNode = doc.documentElement
        rootObj = integration_bin.factory()
        rootObj.build(rootNode)
        return rootObj
    parseString = staticmethod( parseString ) 


    #Method for marshalling an object
    def marshal( self ):
        oStreamString = StringIO.StringIO()
        oStreamString.write('<?xml version="1.0" ?>\n')
        self.export( oStreamString, 0, name_="integration_bin" )
        oStringXML = oStreamString.getvalue()
        oStreamString.close()
        return oStringXML

    def exportLiteral(self, outfile, level = 0, name_='integration_bin'):
        level += 1
        self.exportLiteralAttributes(outfile, level, name_)
        self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('number = %d,\n' % self.getNumber())
        if self.resolution:
            showIndent(outfile, level)
            outfile.write('resolution = resolution(\n')
            self.resolution.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.measured_spots_profile:
            showIndent(outfile, level)
            outfile.write('measured_spots_profile = measured_spot_summary(\n')
            self.measured_spots_profile.exportLiteral(outfile, level, name_='measured_spots_profile')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.measured_spots_summation:
            showIndent(outfile, level)
            outfile.write('measured_spots_summation = measured_spot_summary(\n')
            self.measured_spots_summation.exportLiteral(outfile, level, name_='measured_spots_summation')
            showIndent(outfile, level)
            outfile.write('),\n')
    def exportLiteralHtml(self, outfile, level = 0, name_='integration_bin'):
        level += 1
        self.exportLiteralAttributesHtml(outfile, level, name_)
        self.exportLiteralChildrenHtml(outfile, level, name_)
    def exportLiteralAttributesHtml(self, outfile, level, name_):
        pass
    def exportLiteralChildrenHtml(self, outfile, level, name_):
        showIndentHtml(outfile, level)
        outfile.write('number = <a  href:"#">%d</a><br>\n' % self.getNumber())
        if self.resolution:
            showIndentHtml(outfile, level)
            outfile.write('resolution<br>\n')
            self.resolution.exportLiteralHtml(outfile, level)
            showIndentHtml(outfile, level)
            outfile.write('<br>\n')
        if self.measured_spots_profile:
            showIndentHtml(outfile, level)
            outfile.write('measured_spots_profile<br>\n')
            self.measured_spots_profile.exportLiteralHtml(outfile, level, name_='measured_spots_profile')
            showIndentHtml(outfile, level)
            outfile.write('<br>\n')
        if self.measured_spots_summation:
            showIndentHtml(outfile, level)
            outfile.write('measured_spots_summation<br>\n')
            self.measured_spots_summation.exportLiteralHtml(outfile, level, name_='measured_spots_summation')
            showIndentHtml(outfile, level)
            outfile.write('<br>\n')
    def build(self, node_):
        attrs = node_.attributes
        self.buildAttributes(attrs)
        for child_ in node_.childNodes:
            nodeName_ = child_.nodeName.split(':')[-1]
            self.buildChildren(child_, nodeName_)
    def buildAttributes(self, attrs):
        pass
    def buildChildren(self, child_, nodeName_):
        if child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'number':
            if child_.firstChild:
                sval_ = child_.firstChild.nodeValue
                try:
                    ival_ = int(sval_)
                except ValueError:
                    raise ValueError('requires integer -- %s' % child_.toxml())
                self.number = ival_
        elif child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'resolution':
            obj_ = resolution.factory()
            obj_.build(child_)
            self.setResolution(obj_)
        elif child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'measured_spots_profile':
            obj_ = measured_spot_summary.factory()
            obj_.build(child_)
            self.setMeasured_spots_profile(obj_)
        elif child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'measured_spots_summation':
            obj_ = measured_spot_summary.factory()
            obj_.build(child_)
            self.setMeasured_spots_summation(obj_)
# end class integration_bin


class measured_spot_summary(object):
    subclass = None
    def __init__(self, full=None, partial=None):
        self.full = full
        self.partial = partial
    def factory(*args_, **kwargs_):
        if measured_spot_summary.subclass:
            return measured_spot_summary.subclass(*args_, **kwargs_)
        else:
            return measured_spot_summary(*args_, **kwargs_)
    factory = staticmethod(factory)
    def getFull(self): return self.full
    def setFull(self, full): self.full = full
    def getPartial(self): return self.partial
    def setPartial(self, partial): self.partial = partial
    def export(self, outfile, level = 0, name_='measured_spot_summary'):
        showIndent(outfile, level)
        outfile.write('<%s>\n' % name_)
        self.exportChildren(outfile, level + 1, name_)
        showIndent(outfile, level)
        outfile.write('</%s>\n' % name_)
    def exportAttributes(self, outfile, level, name_='measured_spot_summary'):
        pass
    def exportChildren(self, outfile, level, name_='measured_spot_summary'):
        if self.full:
            self.full.export(outfile, level, name_='full')
        if self.partial:
            self.partial.export(outfile, level, name_='partial')

    #Only to export the entire XML tree to a file stream on disk
    def outputFile( self, _outfileName ):
        outfile = open( _outfileName, "w" )
        outfile.write("<?xml version=\"1.0\" ?>\n")
        self.export( outfile, 0, name_='measured_spot_summary' )
        outfile.close()


    #Only to export the entire XML tree to a Html Page in a file stream on disk
    def outputPageHtml( self, _outfileName ):
        odtStrTitle = "    <span class=\"title\">measured_spot_summary:</span> <br> <br> <br>\n" 
        outfile = open( _outfileName, "w" )
        outfile.write( TEMPLATE_PAGE_P1 % ( odtStrTitle ) )
        self.exportLiteralHtml( outfile, 0, name_='measured_spot_summary' )
        outfile.write( TEMPLATE_PAGE_P2  )
        outfile.close()


    def outputFileHtml( self, _outfileName ):
        self.outputPageHtml( _outfileName )



    #Static method for parsing a string
    def parseString( _inString ):
        doc = minidom.parseString(_inString)
        rootNode = doc.documentElement
        rootObj = measured_spot_summary.factory()
        rootObj.build(rootNode)
        return rootObj
    parseString = staticmethod( parseString ) 


    #Method for marshalling an object
    def marshal( self ):
        oStreamString = StringIO.StringIO()
        oStreamString.write('<?xml version="1.0" ?>\n')
        self.export( oStreamString, 0, name_="measured_spot_summary" )
        oStringXML = oStreamString.getvalue()
        oStreamString.close()
        return oStringXML

    def exportLiteral(self, outfile, level = 0, name_='measured_spot_summary'):
        level += 1
        self.exportLiteralAttributes(outfile, level, name_)
        self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.full:
            showIndent(outfile, level)
            outfile.write('full = spot_summary_element(\n')
            self.full.exportLiteral(outfile, level, name_='full')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.partial:
            showIndent(outfile, level)
            outfile.write('partial = spot_summary_element(\n')
            self.partial.exportLiteral(outfile, level, name_='partial')
            showIndent(outfile, level)
            outfile.write('),\n')
    def exportLiteralHtml(self, outfile, level = 0, name_='measured_spot_summary'):
        level += 1
        self.exportLiteralAttributesHtml(outfile, level, name_)
        self.exportLiteralChildrenHtml(outfile, level, name_)
    def exportLiteralAttributesHtml(self, outfile, level, name_):
        pass
    def exportLiteralChildrenHtml(self, outfile, level, name_):
        if self.full:
            showIndentHtml(outfile, level)
            outfile.write('full<br>\n')
            self.full.exportLiteralHtml(outfile, level, name_='full')
            showIndentHtml(outfile, level)
            outfile.write('<br>\n')
        if self.partial:
            showIndentHtml(outfile, level)
            outfile.write('partial<br>\n')
            self.partial.exportLiteralHtml(outfile, level, name_='partial')
            showIndentHtml(outfile, level)
            outfile.write('<br>\n')
    def build(self, node_):
        attrs = node_.attributes
        self.buildAttributes(attrs)
        for child_ in node_.childNodes:
            nodeName_ = child_.nodeName.split(':')[-1]
            self.buildChildren(child_, nodeName_)
    def buildAttributes(self, attrs):
        pass
    def buildChildren(self, child_, nodeName_):
        if child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'full':
            obj_ = spot_summary_element.factory()
            obj_.build(child_)
            self.setFull(obj_)
        elif child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'partial':
            obj_ = spot_summary_element.factory()
            obj_.build(child_)
            self.setPartial(obj_)
# end class measured_spot_summary


class spot_summary_element(object):
    subclass = None
    def __init__(self, spot_count=-1, signal=-1, noise=-1, signal_to_noise=0.0):
        self.spot_count = spot_count
        self.signal = signal
        self.noise = noise
        self.signal_to_noise = signal_to_noise
    def factory(*args_, **kwargs_):
        if spot_summary_element.subclass:
            return spot_summary_element.subclass(*args_, **kwargs_)
        else:
            return spot_summary_element(*args_, **kwargs_)
    factory = staticmethod(factory)
    def getSpot_count(self): return self.spot_count
    def setSpot_count(self, spot_count): self.spot_count = spot_count
    def getSignal(self): return self.signal
    def setSignal(self, signal): self.signal = signal
    def getNoise(self): return self.noise
    def setNoise(self, noise): self.noise = noise
    def getSignal_to_noise(self): return self.signal_to_noise
    def setSignal_to_noise(self, signal_to_noise): self.signal_to_noise = signal_to_noise
    def export(self, outfile, level = 0, name_='spot_summary_element'):
        showIndent(outfile, level)
        outfile.write('<%s>\n' % name_)
        self.exportChildren(outfile, level + 1, name_)
        showIndent(outfile, level)
        outfile.write('</%s>\n' % name_)
    def exportAttributes(self, outfile, level, name_='spot_summary_element'):
        pass
    def exportChildren(self, outfile, level, name_='spot_summary_element'):
        showIndent(outfile, level)
        outfile.write('<spot_count>%d</spot_count>\n' % self.getSpot_count())
        showIndent(outfile, level)
        outfile.write('<signal>%d</signal>\n' % self.getSignal())
        showIndent(outfile, level)
        outfile.write('<noise>%d</noise>\n' % self.getNoise())
        showIndent(outfile, level)
        outfile.write('<signal_to_noise>%e</signal_to_noise>\n' % self.getSignal_to_noise())

    #Only to export the entire XML tree to a file stream on disk
    def outputFile( self, _outfileName ):
        outfile = open( _outfileName, "w" )
        outfile.write("<?xml version=\"1.0\" ?>\n")
        self.export( outfile, 0, name_='spot_summary_element' )
        outfile.close()


    #Only to export the entire XML tree to a Html Page in a file stream on disk
    def outputPageHtml( self, _outfileName ):
        odtStrTitle = "    <span class=\"title\">spot_summary_element:</span> <br> <br> <br>\n" 
        outfile = open( _outfileName, "w" )
        outfile.write( TEMPLATE_PAGE_P1 % ( odtStrTitle ) )
        self.exportLiteralHtml( outfile, 0, name_='spot_summary_element' )
        outfile.write( TEMPLATE_PAGE_P2  )
        outfile.close()


    def outputFileHtml( self, _outfileName ):
        self.outputPageHtml( _outfileName )



    #Static method for parsing a string
    def parseString( _inString ):
        doc = minidom.parseString(_inString)
        rootNode = doc.documentElement
        rootObj = spot_summary_element.factory()
        rootObj.build(rootNode)
        return rootObj
    parseString = staticmethod( parseString ) 


    #Method for marshalling an object
    def marshal( self ):
        oStreamString = StringIO.StringIO()
        oStreamString.write('<?xml version="1.0" ?>\n')
        self.export( oStreamString, 0, name_="spot_summary_element" )
        oStringXML = oStreamString.getvalue()
        oStreamString.close()
        return oStringXML

    def exportLiteral(self, outfile, level = 0, name_='spot_summary_element'):
        level += 1
        self.exportLiteralAttributes(outfile, level, name_)
        self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('spot_count = %d,\n' % self.getSpot_count())
        showIndent(outfile, level)
        outfile.write('signal = %d,\n' % self.getSignal())
        showIndent(outfile, level)
        outfile.write('noise = %d,\n' % self.getNoise())
        showIndent(outfile, level)
        outfile.write('signal_to_noise = %e,\n' % self.getSignal_to_noise())
    def exportLiteralHtml(self, outfile, level = 0, name_='spot_summary_element'):
        level += 1
        self.exportLiteralAttributesHtml(outfile, level, name_)
        self.exportLiteralChildrenHtml(outfile, level, name_)
    def exportLiteralAttributesHtml(self, outfile, level, name_):
        pass
    def exportLiteralChildrenHtml(self, outfile, level, name_):
        showIndentHtml(outfile, level)
        outfile.write('spot_count = <a  href:"#">%d</a><br>\n' % self.getSpot_count())
        showIndentHtml(outfile, level)
        outfile.write('signal = <a  href:"#">%d</a><br>\n' % self.getSignal())
        showIndentHtml(outfile, level)
        outfile.write('noise = <a  href:"#">%d</a><br>\n' % self.getNoise())
        showIndentHtml(outfile, level)
        outfile.write('signal_to_noise = <a  href:"#">%e</a><br>\n' % self.getSignal_to_noise())
    def build(self, node_):
        attrs = node_.attributes
        self.buildAttributes(attrs)
        for child_ in node_.childNodes:
            nodeName_ = child_.nodeName.split(':')[-1]
            self.buildChildren(child_, nodeName_)
    def buildAttributes(self, attrs):
        pass
    def buildChildren(self, child_, nodeName_):
        if child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'spot_count':
            if child_.firstChild:
                sval_ = child_.firstChild.nodeValue
                try:
                    ival_ = int(sval_)
                except ValueError:
                    raise ValueError('requires integer -- %s' % child_.toxml())
                self.spot_count = ival_
        elif child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'signal':
            if child_.firstChild:
                sval_ = child_.firstChild.nodeValue
                try:
                    ival_ = int(sval_)
                except ValueError:
                    raise ValueError('requires integer -- %s' % child_.toxml())
                self.signal = ival_
        elif child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'noise':
            if child_.firstChild:
                sval_ = child_.firstChild.nodeValue
                try:
                    ival_ = int(sval_)
                except ValueError:
                    raise ValueError('requires integer -- %s' % child_.toxml())
                self.noise = ival_
        elif child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'signal_to_noise':
            if child_.firstChild:
                sval_ = child_.firstChild.nodeValue
                try:
                    fval_ = float(sval_)
                except ValueError:
                    raise ValueError('requires float (or double) -- %s' % child_.toxml())
                self.signal_to_noise = fval_
# end class spot_summary_element


class start_images(object):
    subclass = None
    def __init__(self, image=None):
        if image is None:
            self.image = []
        else:
            self.image = image
    def factory(*args_, **kwargs_):
        if start_images.subclass:
            return start_images.subclass(*args_, **kwargs_)
        else:
            return start_images(*args_, **kwargs_)
    factory = staticmethod(factory)
    def getImage(self): return self.image
    def setImage(self, image): self.image = image
    def addImage(self, value): self.image.append(value)
    def insertImage(self, index, value): self.image[index] = value
    def export(self, outfile, level = 0, name_='start_images'):
        showIndent(outfile, level)
        outfile.write('<%s>\n' % name_)
        self.exportChildren(outfile, level + 1, name_)
        showIndent(outfile, level)
        outfile.write('</%s>\n' % name_)
    def exportAttributes(self, outfile, level, name_='start_images'):
        pass
    def exportChildren(self, outfile, level, name_='start_images'):
        for image_ in self.getImage():
            showIndent(outfile, level)
            outfile.write('<image>%d</image>\n' % image_)

    #Only to export the entire XML tree to a file stream on disk
    def outputFile( self, _outfileName ):
        outfile = open( _outfileName, "w" )
        outfile.write("<?xml version=\"1.0\" ?>\n")
        self.export( outfile, 0, name_='start_images' )
        outfile.close()


    #Only to export the entire XML tree to a Html Page in a file stream on disk
    def outputPageHtml( self, _outfileName ):
        odtStrTitle = "    <span class=\"title\">start_images:</span> <br> <br> <br>\n" 
        outfile = open( _outfileName, "w" )
        outfile.write( TEMPLATE_PAGE_P1 % ( odtStrTitle ) )
        self.exportLiteralHtml( outfile, 0, name_='start_images' )
        outfile.write( TEMPLATE_PAGE_P2  )
        outfile.close()


    def outputFileHtml( self, _outfileName ):
        self.outputPageHtml( _outfileName )



    #Static method for parsing a string
    def parseString( _inString ):
        doc = minidom.parseString(_inString)
        rootNode = doc.documentElement
        rootObj = start_images.factory()
        rootObj.build(rootNode)
        return rootObj
    parseString = staticmethod( parseString ) 


    #Method for marshalling an object
    def marshal( self ):
        oStreamString = StringIO.StringIO()
        oStreamString.write('<?xml version="1.0" ?>\n')
        self.export( oStreamString, 0, name_="start_images" )
        oStringXML = oStreamString.getvalue()
        oStreamString.close()
        return oStringXML

    def exportLiteral(self, outfile, level = 0, name_='start_images'):
        level += 1
        self.exportLiteralAttributes(outfile, level, name_)
        self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('image=[\n')
        level += 1
        for image in self.image:
            showIndent(outfile, level)
            outfile.write('%d,\n' % image)
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def exportLiteralHtml(self, outfile, level = 0, name_='start_images'):
        level += 1
        self.exportLiteralAttributesHtml(outfile, level, name_)
        self.exportLiteralChildrenHtml(outfile, level, name_)
    def exportLiteralAttributesHtml(self, outfile, level, name_):
        pass
    def exportLiteralChildrenHtml(self, outfile, level, name_):
        showIndentHtml(outfile, level)
        outfile.write('image<br>\n')
        level += 1
        for image in self.image:
            showIndentHtml(outfile, level)
            outfile.write('<a  href:"#">%d</a><br>\n' % image)
        level -= 1
        showIndentHtml(outfile, level)
        outfile.write('<br>\n')
    def build(self, node_):
        attrs = node_.attributes
        self.buildAttributes(attrs)
        for child_ in node_.childNodes:
            nodeName_ = child_.nodeName.split(':')[-1]
            self.buildChildren(child_, nodeName_)
    def buildAttributes(self, attrs):
        pass
    def buildChildren(self, child_, nodeName_):
        if child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'image':
            if child_.firstChild:
                sval_ = child_.firstChild.nodeValue
                try:
                    ival_ = int(sval_)
                except ValueError:
                    raise ValueError('requires integer -- %s' % child_.toxml())
                self.image.append(ival_)
# end class start_images


class end_images(object):
    subclass = None
    def __init__(self, image=None):
        if image is None:
            self.image = []
        else:
            self.image = image
    def factory(*args_, **kwargs_):
        if end_images.subclass:
            return end_images.subclass(*args_, **kwargs_)
        else:
            return end_images(*args_, **kwargs_)
    factory = staticmethod(factory)
    def getImage(self): return self.image
    def setImage(self, image): self.image = image
    def addImage(self, value): self.image.append(value)
    def insertImage(self, index, value): self.image[index] = value
    def export(self, outfile, level = 0, name_='end_images'):
        showIndent(outfile, level)
        outfile.write('<%s>\n' % name_)
        self.exportChildren(outfile, level + 1, name_)
        showIndent(outfile, level)
        outfile.write('</%s>\n' % name_)
    def exportAttributes(self, outfile, level, name_='end_images'):
        pass
    def exportChildren(self, outfile, level, name_='end_images'):
        for image_ in self.getImage():
            showIndent(outfile, level)
            outfile.write('<image>%d</image>\n' % image_)

    #Only to export the entire XML tree to a file stream on disk
    def outputFile( self, _outfileName ):
        outfile = open( _outfileName, "w" )
        outfile.write("<?xml version=\"1.0\" ?>\n")
        self.export( outfile, 0, name_='end_images' )
        outfile.close()


    #Only to export the entire XML tree to a Html Page in a file stream on disk
    def outputPageHtml( self, _outfileName ):
        odtStrTitle = "    <span class=\"title\">end_images:</span> <br> <br> <br>\n" 
        outfile = open( _outfileName, "w" )
        outfile.write( TEMPLATE_PAGE_P1 % ( odtStrTitle ) )
        self.exportLiteralHtml( outfile, 0, name_='end_images' )
        outfile.write( TEMPLATE_PAGE_P2  )
        outfile.close()


    def outputFileHtml( self, _outfileName ):
        self.outputPageHtml( _outfileName )



    #Static method for parsing a string
    def parseString( _inString ):
        doc = minidom.parseString(_inString)
        rootNode = doc.documentElement
        rootObj = end_images.factory()
        rootObj.build(rootNode)
        return rootObj
    parseString = staticmethod( parseString ) 


    #Method for marshalling an object
    def marshal( self ):
        oStreamString = StringIO.StringIO()
        oStreamString.write('<?xml version="1.0" ?>\n')
        self.export( oStreamString, 0, name_="end_images" )
        oStringXML = oStreamString.getvalue()
        oStreamString.close()
        return oStringXML

    def exportLiteral(self, outfile, level = 0, name_='end_images'):
        level += 1
        self.exportLiteralAttributes(outfile, level, name_)
        self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('image=[\n')
        level += 1
        for image in self.image:
            showIndent(outfile, level)
            outfile.write('%d,\n' % image)
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def exportLiteralHtml(self, outfile, level = 0, name_='end_images'):
        level += 1
        self.exportLiteralAttributesHtml(outfile, level, name_)
        self.exportLiteralChildrenHtml(outfile, level, name_)
    def exportLiteralAttributesHtml(self, outfile, level, name_):
        pass
    def exportLiteralChildrenHtml(self, outfile, level, name_):
        showIndentHtml(outfile, level)
        outfile.write('image<br>\n')
        level += 1
        for image in self.image:
            showIndentHtml(outfile, level)
            outfile.write('<a  href:"#">%d</a><br>\n' % image)
        level -= 1
        showIndentHtml(outfile, level)
        outfile.write('<br>\n')
    def build(self, node_):
        attrs = node_.attributes
        self.buildAttributes(attrs)
        for child_ in node_.childNodes:
            nodeName_ = child_.nodeName.split(':')[-1]
            self.buildChildren(child_, nodeName_)
    def buildAttributes(self, attrs):
        pass
    def buildChildren(self, child_, nodeName_):
        if child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'image':
            if child_.firstChild:
                sval_ = child_.firstChild.nodeValue
                try:
                    ival_ = int(sval_)
                except ValueError:
                    raise ValueError('requires integer -- %s' % child_.toxml())
                self.image.append(ival_)
# end class end_images


class cell_refinement_request(object):
    subclass = None
    def __init__(self, extra_commands=None, start_images=None, end_images=None, symmetry='', fileinfo=None):
        self.extra_commands = extra_commands
        self.start_images = start_images
        self.end_images = end_images
        self.symmetry = symmetry
        self.fileinfo = fileinfo
    def factory(*args_, **kwargs_):
        if cell_refinement_request.subclass:
            return cell_refinement_request.subclass(*args_, **kwargs_)
        else:
            return cell_refinement_request(*args_, **kwargs_)
    factory = staticmethod(factory)
    def getExtra_commands(self): return self.extra_commands
    def setExtra_commands(self, extra_commands): self.extra_commands = extra_commands
    def getStart_images(self): return self.start_images
    def setStart_images(self, start_images): self.start_images = start_images
    def getEnd_images(self): return self.end_images
    def setEnd_images(self, end_images): self.end_images = end_images
    def getSymmetry(self): return self.symmetry
    def setSymmetry(self, symmetry): self.symmetry = symmetry
    def getFileinfo(self): return self.fileinfo
    def setFileinfo(self, fileinfo): self.fileinfo = fileinfo
    def export(self, outfile, level = 0, name_='cell_refinement_request'):
        showIndent(outfile, level)
        outfile.write('<%s>\n' % name_)
        self.exportChildren(outfile, level + 1, name_)
        showIndent(outfile, level)
        outfile.write('</%s>\n' % name_)
    def exportAttributes(self, outfile, level, name_='cell_refinement_request'):
        pass
    def exportChildren(self, outfile, level, name_='cell_refinement_request'):
        if self.extra_commands:
            self.extra_commands.export(outfile, level)
        if self.start_images:
            self.start_images.export(outfile, level)
        if self.end_images:
            self.end_images.export(outfile, level)
        showIndent(outfile, level)
        outfile.write('<symmetry>%s</symmetry>\n' % quote_xml(self.getSymmetry()))
        if self.fileinfo:
            self.fileinfo.export(outfile, level)

    #Only to export the entire XML tree to a file stream on disk
    def outputFile( self, _outfileName ):
        outfile = open( _outfileName, "w" )
        outfile.write("<?xml version=\"1.0\" ?>\n")
        self.export( outfile, 0, name_='cell_refinement_request' )
        outfile.close()


    #Only to export the entire XML tree to a Html Page in a file stream on disk
    def outputPageHtml( self, _outfileName ):
        odtStrTitle = "    <span class=\"title\">cell_refinement_request:</span> <br> <br> <br>\n" 
        outfile = open( _outfileName, "w" )
        outfile.write( TEMPLATE_PAGE_P1 % ( odtStrTitle ) )
        self.exportLiteralHtml( outfile, 0, name_='cell_refinement_request' )
        outfile.write( TEMPLATE_PAGE_P2  )
        outfile.close()


    def outputFileHtml( self, _outfileName ):
        self.outputPageHtml( _outfileName )



    #Static method for parsing a string
    def parseString( _inString ):
        doc = minidom.parseString(_inString)
        rootNode = doc.documentElement
        rootObj = cell_refinement_request.factory()
        rootObj.build(rootNode)
        return rootObj
    parseString = staticmethod( parseString ) 


    #Method for marshalling an object
    def marshal( self ):
        oStreamString = StringIO.StringIO()
        oStreamString.write('<?xml version="1.0" ?>\n')
        self.export( oStreamString, 0, name_="cell_refinement_request" )
        oStringXML = oStreamString.getvalue()
        oStreamString.close()
        return oStringXML

    def exportLiteral(self, outfile, level = 0, name_='cell_refinement_request'):
        level += 1
        self.exportLiteralAttributes(outfile, level, name_)
        self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.extra_commands:
            showIndent(outfile, level)
            outfile.write('extra_commands = extra_commands(\n')
            self.extra_commands.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.start_images:
            showIndent(outfile, level)
            outfile.write('start_images = start_images(\n')
            self.start_images.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.end_images:
            showIndent(outfile, level)
            outfile.write('end_images = end_images(\n')
            self.end_images.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        showIndent(outfile, level)
        outfile.write('symmetry = %s,\n' % quote_python(self.getSymmetry()))
        if self.fileinfo:
            showIndent(outfile, level)
            outfile.write('fileinfo = fileinfo(\n')
            self.fileinfo.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
    def exportLiteralHtml(self, outfile, level = 0, name_='cell_refinement_request'):
        level += 1
        self.exportLiteralAttributesHtml(outfile, level, name_)
        self.exportLiteralChildrenHtml(outfile, level, name_)
    def exportLiteralAttributesHtml(self, outfile, level, name_):
        pass
    def exportLiteralChildrenHtml(self, outfile, level, name_):
        if self.extra_commands:
            showIndentHtml(outfile, level)
            outfile.write('extra_commands<br>\n')
            self.extra_commands.exportLiteralHtml(outfile, level)
            showIndentHtml(outfile, level)
            outfile.write('<br>\n')
        if self.start_images:
            showIndentHtml(outfile, level)
            outfile.write('start_images<br>\n')
            self.start_images.exportLiteralHtml(outfile, level)
            showIndentHtml(outfile, level)
            outfile.write('<br>\n')
        if self.end_images:
            showIndentHtml(outfile, level)
            outfile.write('end_images<br>\n')
            self.end_images.exportLiteralHtml(outfile, level)
            showIndentHtml(outfile, level)
            outfile.write('<br>\n')
        showIndentHtml(outfile, level)
        outfile.write('symmetry = <a  href:"#">%s</a><br>\n' % quote_python(self.getSymmetry()))
        if self.fileinfo:
            showIndentHtml(outfile, level)
            outfile.write('fileinfo<br>\n')
            self.fileinfo.exportLiteralHtml(outfile, level)
            showIndentHtml(outfile, level)
            outfile.write('<br>\n')
    def build(self, node_):
        attrs = node_.attributes
        self.buildAttributes(attrs)
        for child_ in node_.childNodes:
            nodeName_ = child_.nodeName.split(':')[-1]
            self.buildChildren(child_, nodeName_)
    def buildAttributes(self, attrs):
        pass
    def buildChildren(self, child_, nodeName_):
        if child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'extra_commands':
            obj_ = extra_commands.factory()
            obj_.build(child_)
            self.setExtra_commands(obj_)
        elif child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'start_images':
            obj_ = start_images.factory()
            obj_.build(child_)
            self.setStart_images(obj_)
        elif child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'end_images':
            obj_ = end_images.factory()
            obj_.build(child_)
            self.setEnd_images(obj_)
        elif child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'symmetry':
            symmetry_ = ''
            for text__content_ in child_.childNodes:
                symmetry_ += text__content_.nodeValue
            self.symmetry = symmetry_
        elif child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'fileinfo':
            obj_ = fileinfo.factory()
            obj_.build(child_)
            self.setFileinfo(obj_)
# end class cell_refinement_request


class pointless_results(object):
    subclass = None
    def __init__(self, pg_confidence=0.0, pg_pointgroup='', pg_reindex_op=''):
        self.pg_confidence = pg_confidence
        self.pg_pointgroup = pg_pointgroup
        self.pg_reindex_op = pg_reindex_op
    def factory(*args_, **kwargs_):
        if pointless_results.subclass:
            return pointless_results.subclass(*args_, **kwargs_)
        else:
            return pointless_results(*args_, **kwargs_)
    factory = staticmethod(factory)
    def getPg_confidence(self): return self.pg_confidence
    def setPg_confidence(self, pg_confidence): self.pg_confidence = pg_confidence
    def getPg_pointgroup(self): return self.pg_pointgroup
    def setPg_pointgroup(self, pg_pointgroup): self.pg_pointgroup = pg_pointgroup
    def getPg_reindex_op(self): return self.pg_reindex_op
    def setPg_reindex_op(self, pg_reindex_op): self.pg_reindex_op = pg_reindex_op
    def export(self, outfile, level = 0, name_='pointless_results'):
        showIndent(outfile, level)
        outfile.write('<%s>\n' % name_)
        self.exportChildren(outfile, level + 1, name_)
        showIndent(outfile, level)
        outfile.write('</%s>\n' % name_)
    def exportAttributes(self, outfile, level, name_='pointless_results'):
        pass
    def exportChildren(self, outfile, level, name_='pointless_results'):
        showIndent(outfile, level)
        outfile.write('<pg_confidence>%e</pg_confidence>\n' % self.getPg_confidence())
        showIndent(outfile, level)
        outfile.write('<pg_pointgroup>%s</pg_pointgroup>\n' % quote_xml(self.getPg_pointgroup()))
        showIndent(outfile, level)
        outfile.write('<pg_reindex_op>%s</pg_reindex_op>\n' % quote_xml(self.getPg_reindex_op()))

    #Only to export the entire XML tree to a file stream on disk
    def outputFile( self, _outfileName ):
        outfile = open( _outfileName, "w" )
        outfile.write("<?xml version=\"1.0\" ?>\n")
        self.export( outfile, 0, name_='pointless_results' )
        outfile.close()


    #Only to export the entire XML tree to a Html Page in a file stream on disk
    def outputPageHtml( self, _outfileName ):
        odtStrTitle = "    <span class=\"title\">pointless_results:</span> <br> <br> <br>\n" 
        outfile = open( _outfileName, "w" )
        outfile.write( TEMPLATE_PAGE_P1 % ( odtStrTitle ) )
        self.exportLiteralHtml( outfile, 0, name_='pointless_results' )
        outfile.write( TEMPLATE_PAGE_P2  )
        outfile.close()


    def outputFileHtml( self, _outfileName ):
        self.outputPageHtml( _outfileName )



    #Static method for parsing a string
    def parseString( _inString ):
        doc = minidom.parseString(_inString)
        rootNode = doc.documentElement
        rootObj = pointless_results.factory()
        rootObj.build(rootNode)
        return rootObj
    parseString = staticmethod( parseString ) 


    #Method for marshalling an object
    def marshal( self ):
        oStreamString = StringIO.StringIO()
        oStreamString.write('<?xml version="1.0" ?>\n')
        self.export( oStreamString, 0, name_="pointless_results" )
        oStringXML = oStreamString.getvalue()
        oStreamString.close()
        return oStringXML

    def exportLiteral(self, outfile, level = 0, name_='pointless_results'):
        level += 1
        self.exportLiteralAttributes(outfile, level, name_)
        self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('pg_confidence = %e,\n' % self.getPg_confidence())
        showIndent(outfile, level)
        outfile.write('pg_pointgroup = %s,\n' % quote_python(self.getPg_pointgroup()))
        showIndent(outfile, level)
        outfile.write('pg_reindex_op = %s,\n' % quote_python(self.getPg_reindex_op()))
    def exportLiteralHtml(self, outfile, level = 0, name_='pointless_results'):
        level += 1
        self.exportLiteralAttributesHtml(outfile, level, name_)
        self.exportLiteralChildrenHtml(outfile, level, name_)
    def exportLiteralAttributesHtml(self, outfile, level, name_):
        pass
    def exportLiteralChildrenHtml(self, outfile, level, name_):
        showIndentHtml(outfile, level)
        outfile.write('pg_confidence = <a  href:"#">%e</a><br>\n' % self.getPg_confidence())
        showIndentHtml(outfile, level)
        outfile.write('pg_pointgroup = <a  href:"#">%s</a><br>\n' % quote_python(self.getPg_pointgroup()))
        showIndentHtml(outfile, level)
        outfile.write('pg_reindex_op = <a  href:"#">%s</a><br>\n' % quote_python(self.getPg_reindex_op()))
    def build(self, node_):
        attrs = node_.attributes
        self.buildAttributes(attrs)
        for child_ in node_.childNodes:
            nodeName_ = child_.nodeName.split(':')[-1]
            self.buildChildren(child_, nodeName_)
    def buildAttributes(self, attrs):
        pass
    def buildChildren(self, child_, nodeName_):
        if child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'pg_confidence':
            if child_.firstChild:
                sval_ = child_.firstChild.nodeValue
                try:
                    fval_ = float(sval_)
                except ValueError:
                    raise ValueError('requires float (or double) -- %s' % child_.toxml())
                self.pg_confidence = fval_
        elif child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'pg_pointgroup':
            pg_pointgroup_ = ''
            for text__content_ in child_.childNodes:
                pg_pointgroup_ += text__content_.nodeValue
            self.pg_pointgroup = pg_pointgroup_
        elif child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'pg_reindex_op':
            pg_reindex_op_ = ''
            for text__content_ in child_.childNodes:
                pg_reindex_op_ += text__content_.nodeValue
            self.pg_reindex_op = pg_reindex_op_
# end class pointless_results


class cell_refinement_response(object):
    subclass = None
    def __init__(self, status=None, refined_cell=None, pointless_results=None, refined_mosaic_spread=0.0):
        self.status = status
        self.refined_cell = refined_cell
        self.pointless_results = pointless_results
        self.refined_mosaic_spread = refined_mosaic_spread
    def factory(*args_, **kwargs_):
        if cell_refinement_response.subclass:
            return cell_refinement_response.subclass(*args_, **kwargs_)
        else:
            return cell_refinement_response(*args_, **kwargs_)
    factory = staticmethod(factory)
    def getStatus(self): return self.status
    def setStatus(self, status): self.status = status
    def getRefined_cell(self): return self.refined_cell
    def setRefined_cell(self, refined_cell): self.refined_cell = refined_cell
    def getPointless_results(self): return self.pointless_results
    def setPointless_results(self, pointless_results): self.pointless_results = pointless_results
    def getRefined_mosaic_spread(self): return self.refined_mosaic_spread
    def setRefined_mosaic_spread(self, refined_mosaic_spread): self.refined_mosaic_spread = refined_mosaic_spread
    def export(self, outfile, level = 0, name_='cell_refinement_response'):
        showIndent(outfile, level)
        outfile.write('<%s>\n' % name_)
        self.exportChildren(outfile, level + 1, name_)
        showIndent(outfile, level)
        outfile.write('</%s>\n' % name_)
    def exportAttributes(self, outfile, level, name_='cell_refinement_response'):
        pass
    def exportChildren(self, outfile, level, name_='cell_refinement_response'):
        if self.status:
            self.status.export(outfile, level)
        if self.refined_cell:
            self.refined_cell.export(outfile, level, name_='refined_cell')
        if self.pointless_results:
            self.pointless_results.export(outfile, level)
        showIndent(outfile, level)
        outfile.write('<refined_mosaic_spread>%e</refined_mosaic_spread>\n' % self.getRefined_mosaic_spread())

    #Only to export the entire XML tree to a file stream on disk
    def outputFile( self, _outfileName ):
        outfile = open( _outfileName, "w" )
        outfile.write("<?xml version=\"1.0\" ?>\n")
        self.export( outfile, 0, name_='cell_refinement_response' )
        outfile.close()


    #Only to export the entire XML tree to a Html Page in a file stream on disk
    def outputPageHtml( self, _outfileName ):
        odtStrTitle = "    <span class=\"title\">cell_refinement_response:</span> <br> <br> <br>\n" 
        outfile = open( _outfileName, "w" )
        outfile.write( TEMPLATE_PAGE_P1 % ( odtStrTitle ) )
        self.exportLiteralHtml( outfile, 0, name_='cell_refinement_response' )
        outfile.write( TEMPLATE_PAGE_P2  )
        outfile.close()


    def outputFileHtml( self, _outfileName ):
        self.outputPageHtml( _outfileName )



    #Static method for parsing a string
    def parseString( _inString ):
        doc = minidom.parseString(_inString)
        rootNode = doc.documentElement
        rootObj = cell_refinement_response.factory()
        rootObj.build(rootNode)
        return rootObj
    parseString = staticmethod( parseString ) 


    #Method for marshalling an object
    def marshal( self ):
        oStreamString = StringIO.StringIO()
        oStreamString.write('<?xml version="1.0" ?>\n')
        self.export( oStreamString, 0, name_="cell_refinement_response" )
        oStringXML = oStreamString.getvalue()
        oStreamString.close()
        return oStringXML

    def exportLiteral(self, outfile, level = 0, name_='cell_refinement_response'):
        level += 1
        self.exportLiteralAttributes(outfile, level, name_)
        self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.status:
            showIndent(outfile, level)
            outfile.write('status = status(\n')
            self.status.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.refined_cell:
            showIndent(outfile, level)
            outfile.write('refined_cell = cell(\n')
            self.refined_cell.exportLiteral(outfile, level, name_='refined_cell')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.pointless_results:
            showIndent(outfile, level)
            outfile.write('pointless_results = pointless_results(\n')
            self.pointless_results.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        showIndent(outfile, level)
        outfile.write('refined_mosaic_spread = %e,\n' % self.getRefined_mosaic_spread())
    def exportLiteralHtml(self, outfile, level = 0, name_='cell_refinement_response'):
        level += 1
        self.exportLiteralAttributesHtml(outfile, level, name_)
        self.exportLiteralChildrenHtml(outfile, level, name_)
    def exportLiteralAttributesHtml(self, outfile, level, name_):
        pass
    def exportLiteralChildrenHtml(self, outfile, level, name_):
        if self.status:
            showIndentHtml(outfile, level)
            outfile.write('status<br>\n')
            self.status.exportLiteralHtml(outfile, level)
            showIndentHtml(outfile, level)
            outfile.write('<br>\n')
        if self.refined_cell:
            showIndentHtml(outfile, level)
            outfile.write('refined_cell<br>\n')
            self.refined_cell.exportLiteralHtml(outfile, level, name_='refined_cell')
            showIndentHtml(outfile, level)
            outfile.write('<br>\n')
        if self.pointless_results:
            showIndentHtml(outfile, level)
            outfile.write('pointless_results<br>\n')
            self.pointless_results.exportLiteralHtml(outfile, level)
            showIndentHtml(outfile, level)
            outfile.write('<br>\n')
        showIndentHtml(outfile, level)
        outfile.write('refined_mosaic_spread = <a  href:"#">%e</a><br>\n' % self.getRefined_mosaic_spread())
    def build(self, node_):
        attrs = node_.attributes
        self.buildAttributes(attrs)
        for child_ in node_.childNodes:
            nodeName_ = child_.nodeName.split(':')[-1]
            self.buildChildren(child_, nodeName_)
    def buildAttributes(self, attrs):
        pass
    def buildChildren(self, child_, nodeName_):
        if child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'status':
            obj_ = status.factory()
            obj_.build(child_)
            self.setStatus(obj_)
        elif child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'refined_cell':
            obj_ = cell.factory()
            obj_.build(child_)
            self.setRefined_cell(obj_)
        elif child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'pointless_results':
            obj_ = pointless_results.factory()
            obj_.build(child_)
            self.setPointless_results(obj_)
        elif child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'refined_mosaic_spread':
            if child_.firstChild:
                sval_ = child_.firstChild.nodeValue
                try:
                    fval_ = float(sval_)
                except ValueError:
                    raise ValueError('requires float (or double) -- %s' % child_.toxml())
                self.refined_mosaic_spread = fval_
# end class cell_refinement_response


class mosflm_commands(object):
    subclass = None
    def __init__(self, command=None):
        if command is None:
            self.command = []
        else:
            self.command = command
    def factory(*args_, **kwargs_):
        if mosflm_commands.subclass:
            return mosflm_commands.subclass(*args_, **kwargs_)
        else:
            return mosflm_commands(*args_, **kwargs_)
    factory = staticmethod(factory)
    def getCommand(self): return self.command
    def setCommand(self, command): self.command = command
    def addCommand(self, value): self.command.append(value)
    def insertCommand(self, index, value): self.command[index] = value
    def export(self, outfile, level = 0, name_='mosflm_commands'):
        showIndent(outfile, level)
        outfile.write('<%s>\n' % name_)
        self.exportChildren(outfile, level + 1, name_)
        showIndent(outfile, level)
        outfile.write('</%s>\n' % name_)
    def exportAttributes(self, outfile, level, name_='mosflm_commands'):
        pass
    def exportChildren(self, outfile, level, name_='mosflm_commands'):
        for command_ in self.getCommand():
            showIndent(outfile, level)
            outfile.write('<command>%s</command>\n' % quote_xml(command_))

    #Only to export the entire XML tree to a file stream on disk
    def outputFile( self, _outfileName ):
        outfile = open( _outfileName, "w" )
        outfile.write("<?xml version=\"1.0\" ?>\n")
        self.export( outfile, 0, name_='mosflm_commands' )
        outfile.close()


    #Only to export the entire XML tree to a Html Page in a file stream on disk
    def outputPageHtml( self, _outfileName ):
        odtStrTitle = "    <span class=\"title\">mosflm_commands:</span> <br> <br> <br>\n" 
        outfile = open( _outfileName, "w" )
        outfile.write( TEMPLATE_PAGE_P1 % ( odtStrTitle ) )
        self.exportLiteralHtml( outfile, 0, name_='mosflm_commands' )
        outfile.write( TEMPLATE_PAGE_P2  )
        outfile.close()


    def outputFileHtml( self, _outfileName ):
        self.outputPageHtml( _outfileName )



    #Static method for parsing a string
    def parseString( _inString ):
        doc = minidom.parseString(_inString)
        rootNode = doc.documentElement
        rootObj = mosflm_commands.factory()
        rootObj.build(rootNode)
        return rootObj
    parseString = staticmethod( parseString ) 


    #Method for marshalling an object
    def marshal( self ):
        oStreamString = StringIO.StringIO()
        oStreamString.write('<?xml version="1.0" ?>\n')
        self.export( oStreamString, 0, name_="mosflm_commands" )
        oStringXML = oStreamString.getvalue()
        oStreamString.close()
        return oStringXML

    def exportLiteral(self, outfile, level = 0, name_='mosflm_commands'):
        level += 1
        self.exportLiteralAttributes(outfile, level, name_)
        self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('command=[\n')
        level += 1
        for command in self.command:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(command))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def exportLiteralHtml(self, outfile, level = 0, name_='mosflm_commands'):
        level += 1
        self.exportLiteralAttributesHtml(outfile, level, name_)
        self.exportLiteralChildrenHtml(outfile, level, name_)
    def exportLiteralAttributesHtml(self, outfile, level, name_):
        pass
    def exportLiteralChildrenHtml(self, outfile, level, name_):
        showIndentHtml(outfile, level)
        outfile.write('command<br>\n')
        level += 1
        for command in self.command:
            showIndentHtml(outfile, level)
            outfile.write('<a  href:"#">%s</a><br>\n' % quote_python(command))
        level -= 1
        showIndentHtml(outfile, level)
        outfile.write('<br>\n')
    def build(self, node_):
        attrs = node_.attributes
        self.buildAttributes(attrs)
        for child_ in node_.childNodes:
            nodeName_ = child_.nodeName.split(':')[-1]
            self.buildChildren(child_, nodeName_)
    def buildAttributes(self, attrs):
        pass
    def buildChildren(self, child_, nodeName_):
        if child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'command':
            command_ = ''
            for text__content_ in child_.childNodes:
                command_ += text__content_.nodeValue
            self.command.append(command_)
# end class mosflm_commands


class scala_commands(object):
    subclass = None
    def __init__(self, command=None):
        if command is None:
            self.command = []
        else:
            self.command = command
    def factory(*args_, **kwargs_):
        if scala_commands.subclass:
            return scala_commands.subclass(*args_, **kwargs_)
        else:
            return scala_commands(*args_, **kwargs_)
    factory = staticmethod(factory)
    def getCommand(self): return self.command
    def setCommand(self, command): self.command = command
    def addCommand(self, value): self.command.append(value)
    def insertCommand(self, index, value): self.command[index] = value
    def export(self, outfile, level = 0, name_='scala_commands'):
        showIndent(outfile, level)
        outfile.write('<%s>\n' % name_)
        self.exportChildren(outfile, level + 1, name_)
        showIndent(outfile, level)
        outfile.write('</%s>\n' % name_)
    def exportAttributes(self, outfile, level, name_='scala_commands'):
        pass
    def exportChildren(self, outfile, level, name_='scala_commands'):
        for command_ in self.getCommand():
            showIndent(outfile, level)
            outfile.write('<command>%s</command>\n' % quote_xml(command_))

    #Only to export the entire XML tree to a file stream on disk
    def outputFile( self, _outfileName ):
        outfile = open( _outfileName, "w" )
        outfile.write("<?xml version=\"1.0\" ?>\n")
        self.export( outfile, 0, name_='scala_commands' )
        outfile.close()


    #Only to export the entire XML tree to a Html Page in a file stream on disk
    def outputPageHtml( self, _outfileName ):
        odtStrTitle = "    <span class=\"title\">scala_commands:</span> <br> <br> <br>\n" 
        outfile = open( _outfileName, "w" )
        outfile.write( TEMPLATE_PAGE_P1 % ( odtStrTitle ) )
        self.exportLiteralHtml( outfile, 0, name_='scala_commands' )
        outfile.write( TEMPLATE_PAGE_P2  )
        outfile.close()


    def outputFileHtml( self, _outfileName ):
        self.outputPageHtml( _outfileName )



    #Static method for parsing a string
    def parseString( _inString ):
        doc = minidom.parseString(_inString)
        rootNode = doc.documentElement
        rootObj = scala_commands.factory()
        rootObj.build(rootNode)
        return rootObj
    parseString = staticmethod( parseString ) 


    #Method for marshalling an object
    def marshal( self ):
        oStreamString = StringIO.StringIO()
        oStreamString.write('<?xml version="1.0" ?>\n')
        self.export( oStreamString, 0, name_="scala_commands" )
        oStringXML = oStreamString.getvalue()
        oStreamString.close()
        return oStringXML

    def exportLiteral(self, outfile, level = 0, name_='scala_commands'):
        level += 1
        self.exportLiteralAttributes(outfile, level, name_)
        self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('command=[\n')
        level += 1
        for command in self.command:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(command))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def exportLiteralHtml(self, outfile, level = 0, name_='scala_commands'):
        level += 1
        self.exportLiteralAttributesHtml(outfile, level, name_)
        self.exportLiteralChildrenHtml(outfile, level, name_)
    def exportLiteralAttributesHtml(self, outfile, level, name_):
        pass
    def exportLiteralChildrenHtml(self, outfile, level, name_):
        showIndentHtml(outfile, level)
        outfile.write('command<br>\n')
        level += 1
        for command in self.command:
            showIndentHtml(outfile, level)
            outfile.write('<a  href:"#">%s</a><br>\n' % quote_python(command))
        level -= 1
        showIndentHtml(outfile, level)
        outfile.write('<br>\n')
    def build(self, node_):
        attrs = node_.attributes
        self.buildAttributes(attrs)
        for child_ in node_.childNodes:
            nodeName_ = child_.nodeName.split(':')[-1]
            self.buildChildren(child_, nodeName_)
    def buildAttributes(self, attrs):
        pass
    def buildChildren(self, child_, nodeName_):
        if child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'command':
            command_ = ''
            for text__content_ in child_.childNodes:
                command_ += text__content_.nodeValue
            self.command.append(command_)
# end class scala_commands


class xds_commands(object):
    subclass = None
    def __init__(self, command=None):
        if command is None:
            self.command = []
        else:
            self.command = command
    def factory(*args_, **kwargs_):
        if xds_commands.subclass:
            return xds_commands.subclass(*args_, **kwargs_)
        else:
            return xds_commands(*args_, **kwargs_)
    factory = staticmethod(factory)
    def getCommand(self): return self.command
    def setCommand(self, command): self.command = command
    def addCommand(self, value): self.command.append(value)
    def insertCommand(self, index, value): self.command[index] = value
    def export(self, outfile, level = 0, name_='xds_commands'):
        showIndent(outfile, level)
        outfile.write('<%s>\n' % name_)
        self.exportChildren(outfile, level + 1, name_)
        showIndent(outfile, level)
        outfile.write('</%s>\n' % name_)
    def exportAttributes(self, outfile, level, name_='xds_commands'):
        pass
    def exportChildren(self, outfile, level, name_='xds_commands'):
        for command_ in self.getCommand():
            showIndent(outfile, level)
            outfile.write('<command>%s</command>\n' % quote_xml(command_))

    #Only to export the entire XML tree to a file stream on disk
    def outputFile( self, _outfileName ):
        outfile = open( _outfileName, "w" )
        outfile.write("<?xml version=\"1.0\" ?>\n")
        self.export( outfile, 0, name_='xds_commands' )
        outfile.close()


    #Only to export the entire XML tree to a Html Page in a file stream on disk
    def outputPageHtml( self, _outfileName ):
        odtStrTitle = "    <span class=\"title\">xds_commands:</span> <br> <br> <br>\n" 
        outfile = open( _outfileName, "w" )
        outfile.write( TEMPLATE_PAGE_P1 % ( odtStrTitle ) )
        self.exportLiteralHtml( outfile, 0, name_='xds_commands' )
        outfile.write( TEMPLATE_PAGE_P2  )
        outfile.close()


    def outputFileHtml( self, _outfileName ):
        self.outputPageHtml( _outfileName )



    #Static method for parsing a string
    def parseString( _inString ):
        doc = minidom.parseString(_inString)
        rootNode = doc.documentElement
        rootObj = xds_commands.factory()
        rootObj.build(rootNode)
        return rootObj
    parseString = staticmethod( parseString ) 


    #Method for marshalling an object
    def marshal( self ):
        oStreamString = StringIO.StringIO()
        oStreamString.write('<?xml version="1.0" ?>\n')
        self.export( oStreamString, 0, name_="xds_commands" )
        oStringXML = oStreamString.getvalue()
        oStreamString.close()
        return oStringXML

    def exportLiteral(self, outfile, level = 0, name_='xds_commands'):
        level += 1
        self.exportLiteralAttributes(outfile, level, name_)
        self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('command=[\n')
        level += 1
        for command in self.command:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(command))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def exportLiteralHtml(self, outfile, level = 0, name_='xds_commands'):
        level += 1
        self.exportLiteralAttributesHtml(outfile, level, name_)
        self.exportLiteralChildrenHtml(outfile, level, name_)
    def exportLiteralAttributesHtml(self, outfile, level, name_):
        pass
    def exportLiteralChildrenHtml(self, outfile, level, name_):
        showIndentHtml(outfile, level)
        outfile.write('command<br>\n')
        level += 1
        for command in self.command:
            showIndentHtml(outfile, level)
            outfile.write('<a  href:"#">%s</a><br>\n' % quote_python(command))
        level -= 1
        showIndentHtml(outfile, level)
        outfile.write('<br>\n')
    def build(self, node_):
        attrs = node_.attributes
        self.buildAttributes(attrs)
        for child_ in node_.childNodes:
            nodeName_ = child_.nodeName.split(':')[-1]
            self.buildChildren(child_, nodeName_)
    def buildAttributes(self, attrs):
        pass
    def buildChildren(self, child_, nodeName_):
        if child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'command':
            command_ = ''
            for text__content_ in child_.childNodes:
                command_ += text__content_.nodeValue
            self.command.append(command_)
# end class xds_commands


class extra_commands(object):
    subclass = None
    def __init__(self, mosflm_commands=None, scala_commands=None, xds_commands=None):
        self.mosflm_commands = mosflm_commands
        self.scala_commands = scala_commands
        self.xds_commands = xds_commands
    def factory(*args_, **kwargs_):
        if extra_commands.subclass:
            return extra_commands.subclass(*args_, **kwargs_)
        else:
            return extra_commands(*args_, **kwargs_)
    factory = staticmethod(factory)
    def getMosflm_commands(self): return self.mosflm_commands
    def setMosflm_commands(self, mosflm_commands): self.mosflm_commands = mosflm_commands
    def getScala_commands(self): return self.scala_commands
    def setScala_commands(self, scala_commands): self.scala_commands = scala_commands
    def getXds_commands(self): return self.xds_commands
    def setXds_commands(self, xds_commands): self.xds_commands = xds_commands
    def export(self, outfile, level = 0, name_='extra_commands'):
        showIndent(outfile, level)
        outfile.write('<%s>\n' % name_)
        self.exportChildren(outfile, level + 1, name_)
        showIndent(outfile, level)
        outfile.write('</%s>\n' % name_)
    def exportAttributes(self, outfile, level, name_='extra_commands'):
        pass
    def exportChildren(self, outfile, level, name_='extra_commands'):
        if self.mosflm_commands:
            self.mosflm_commands.export(outfile, level)
        if self.scala_commands:
            self.scala_commands.export(outfile, level)
        if self.xds_commands:
            self.xds_commands.export(outfile, level)

    #Only to export the entire XML tree to a file stream on disk
    def outputFile( self, _outfileName ):
        outfile = open( _outfileName, "w" )
        outfile.write("<?xml version=\"1.0\" ?>\n")
        self.export( outfile, 0, name_='extra_commands' )
        outfile.close()


    #Only to export the entire XML tree to a Html Page in a file stream on disk
    def outputPageHtml( self, _outfileName ):
        odtStrTitle = "    <span class=\"title\">extra_commands:</span> <br> <br> <br>\n" 
        outfile = open( _outfileName, "w" )
        outfile.write( TEMPLATE_PAGE_P1 % ( odtStrTitle ) )
        self.exportLiteralHtml( outfile, 0, name_='extra_commands' )
        outfile.write( TEMPLATE_PAGE_P2  )
        outfile.close()


    def outputFileHtml( self, _outfileName ):
        self.outputPageHtml( _outfileName )



    #Static method for parsing a string
    def parseString( _inString ):
        doc = minidom.parseString(_inString)
        rootNode = doc.documentElement
        rootObj = extra_commands.factory()
        rootObj.build(rootNode)
        return rootObj
    parseString = staticmethod( parseString ) 


    #Method for marshalling an object
    def marshal( self ):
        oStreamString = StringIO.StringIO()
        oStreamString.write('<?xml version="1.0" ?>\n')
        self.export( oStreamString, 0, name_="extra_commands" )
        oStringXML = oStreamString.getvalue()
        oStreamString.close()
        return oStringXML

    def exportLiteral(self, outfile, level = 0, name_='extra_commands'):
        level += 1
        self.exportLiteralAttributes(outfile, level, name_)
        self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.mosflm_commands:
            showIndent(outfile, level)
            outfile.write('mosflm_commands = mosflm_commands(\n')
            self.mosflm_commands.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.scala_commands:
            showIndent(outfile, level)
            outfile.write('scala_commands = scala_commands(\n')
            self.scala_commands.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.xds_commands:
            showIndent(outfile, level)
            outfile.write('xds_commands = xds_commands(\n')
            self.xds_commands.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
    def exportLiteralHtml(self, outfile, level = 0, name_='extra_commands'):
        level += 1
        self.exportLiteralAttributesHtml(outfile, level, name_)
        self.exportLiteralChildrenHtml(outfile, level, name_)
    def exportLiteralAttributesHtml(self, outfile, level, name_):
        pass
    def exportLiteralChildrenHtml(self, outfile, level, name_):
        if self.mosflm_commands:
            showIndentHtml(outfile, level)
            outfile.write('mosflm_commands<br>\n')
            self.mosflm_commands.exportLiteralHtml(outfile, level)
            showIndentHtml(outfile, level)
            outfile.write('<br>\n')
        if self.scala_commands:
            showIndentHtml(outfile, level)
            outfile.write('scala_commands<br>\n')
            self.scala_commands.exportLiteralHtml(outfile, level)
            showIndentHtml(outfile, level)
            outfile.write('<br>\n')
        if self.xds_commands:
            showIndentHtml(outfile, level)
            outfile.write('xds_commands<br>\n')
            self.xds_commands.exportLiteralHtml(outfile, level)
            showIndentHtml(outfile, level)
            outfile.write('<br>\n')
    def build(self, node_):
        attrs = node_.attributes
        self.buildAttributes(attrs)
        for child_ in node_.childNodes:
            nodeName_ = child_.nodeName.split(':')[-1]
            self.buildChildren(child_, nodeName_)
    def buildAttributes(self, attrs):
        pass
    def buildChildren(self, child_, nodeName_):
        if child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'mosflm_commands':
            obj_ = mosflm_commands.factory()
            obj_.build(child_)
            self.setMosflm_commands(obj_)
        elif child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'scala_commands':
            obj_ = scala_commands.factory()
            obj_.build(child_)
            self.setScala_commands(obj_)
        elif child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'xds_commands':
            obj_ = xds_commands.factory()
            obj_.build(child_)
            self.setXds_commands(obj_)
# end class extra_commands


class status(object):
    subclass = None
    def __init__(self, code='', message=''):
        self.code = code
        self.message = message
    def factory(*args_, **kwargs_):
        if status.subclass:
            return status.subclass(*args_, **kwargs_)
        else:
            return status(*args_, **kwargs_)
    factory = staticmethod(factory)
    def getCode(self): return self.code
    def setCode(self, code): self.code = code
    def getMessage(self): return self.message
    def setMessage(self, message): self.message = message
    def export(self, outfile, level = 0, name_='status'):
        showIndent(outfile, level)
        outfile.write('<%s>\n' % name_)
        self.exportChildren(outfile, level + 1, name_)
        showIndent(outfile, level)
        outfile.write('</%s>\n' % name_)
    def exportAttributes(self, outfile, level, name_='status'):
        pass
    def exportChildren(self, outfile, level, name_='status'):
        showIndent(outfile, level)
        outfile.write('<code>%s</code>\n' % quote_xml(self.getCode()))
        showIndent(outfile, level)
        outfile.write('<message>%s</message>\n' % quote_xml(self.getMessage()))

    #Only to export the entire XML tree to a file stream on disk
    def outputFile( self, _outfileName ):
        outfile = open( _outfileName, "w" )
        outfile.write("<?xml version=\"1.0\" ?>\n")
        self.export( outfile, 0, name_='status' )
        outfile.close()


    #Only to export the entire XML tree to a Html Page in a file stream on disk
    def outputPageHtml( self, _outfileName ):
        odtStrTitle = "    <span class=\"title\">status:</span> <br> <br> <br>\n" 
        outfile = open( _outfileName, "w" )
        outfile.write( TEMPLATE_PAGE_P1 % ( odtStrTitle ) )
        self.exportLiteralHtml( outfile, 0, name_='status' )
        outfile.write( TEMPLATE_PAGE_P2  )
        outfile.close()


    def outputFileHtml( self, _outfileName ):
        self.outputPageHtml( _outfileName )



    #Static method for parsing a string
    def parseString( _inString ):
        doc = minidom.parseString(_inString)
        rootNode = doc.documentElement
        rootObj = status.factory()
        rootObj.build(rootNode)
        return rootObj
    parseString = staticmethod( parseString ) 


    #Method for marshalling an object
    def marshal( self ):
        oStreamString = StringIO.StringIO()
        oStreamString.write('<?xml version="1.0" ?>\n')
        self.export( oStreamString, 0, name_="status" )
        oStringXML = oStreamString.getvalue()
        oStreamString.close()
        return oStringXML

    def exportLiteral(self, outfile, level = 0, name_='status'):
        level += 1
        self.exportLiteralAttributes(outfile, level, name_)
        self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('code = %s,\n' % quote_python(self.getCode()))
        showIndent(outfile, level)
        outfile.write('message = %s,\n' % quote_python(self.getMessage()))
    def exportLiteralHtml(self, outfile, level = 0, name_='status'):
        level += 1
        self.exportLiteralAttributesHtml(outfile, level, name_)
        self.exportLiteralChildrenHtml(outfile, level, name_)
    def exportLiteralAttributesHtml(self, outfile, level, name_):
        pass
    def exportLiteralChildrenHtml(self, outfile, level, name_):
        showIndentHtml(outfile, level)
        outfile.write('code = <a  href:"#">%s</a><br>\n' % quote_python(self.getCode()))
        showIndentHtml(outfile, level)
        outfile.write('message = <a  href:"#">%s</a><br>\n' % quote_python(self.getMessage()))
    def build(self, node_):
        attrs = node_.attributes
        self.buildAttributes(attrs)
        for child_ in node_.childNodes:
            nodeName_ = child_.nodeName.split(':')[-1]
            self.buildChildren(child_, nodeName_)
    def buildAttributes(self, attrs):
        pass
    def buildChildren(self, child_, nodeName_):
        if child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'code':
            code_ = ''
            for text__content_ in child_.childNodes:
                code_ += text__content_.nodeValue
            self.code = code_
        elif child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'message':
            message_ = ''
            for text__content_ in child_.childNodes:
                message_ += text__content_.nodeValue
            self.message = message_
# end class status


class fileinfo(object):
    subclass = None
    def __init__(self, directory='', prefix='', suffix='', template='', run_number=''):
        self.directory = directory
        self.prefix = prefix
        self.suffix = suffix
        self.template = template
        self.run_number = run_number
    def factory(*args_, **kwargs_):
        if fileinfo.subclass:
            return fileinfo.subclass(*args_, **kwargs_)
        else:
            return fileinfo(*args_, **kwargs_)
    factory = staticmethod(factory)
    def getDirectory(self): return self.directory
    def setDirectory(self, directory): self.directory = directory
    def getPrefix(self): return self.prefix
    def setPrefix(self, prefix): self.prefix = prefix
    def getSuffix(self): return self.suffix
    def setSuffix(self, suffix): self.suffix = suffix
    def getTemplate(self): return self.template
    def setTemplate(self, template): self.template = template
    def getRun_number(self): return self.run_number
    def setRun_number(self, run_number): self.run_number = run_number
    def export(self, outfile, level = 0, name_='fileinfo'):
        showIndent(outfile, level)
        outfile.write('<%s>\n' % name_)
        self.exportChildren(outfile, level + 1, name_)
        showIndent(outfile, level)
        outfile.write('</%s>\n' % name_)
    def exportAttributes(self, outfile, level, name_='fileinfo'):
        pass
    def exportChildren(self, outfile, level, name_='fileinfo'):
        showIndent(outfile, level)
        outfile.write('<directory>%s</directory>\n' % quote_xml(self.getDirectory()))
        showIndent(outfile, level)
        outfile.write('<prefix>%s</prefix>\n' % quote_xml(self.getPrefix()))
        showIndent(outfile, level)
        outfile.write('<suffix>%s</suffix>\n' % quote_xml(self.getSuffix()))
        showIndent(outfile, level)
        outfile.write('<template>%s</template>\n' % quote_xml(self.getTemplate()))
        showIndent(outfile, level)
        outfile.write('<run_number>%s</run_number>\n' % quote_xml(self.getRun_number()))

    #Only to export the entire XML tree to a file stream on disk
    def outputFile( self, _outfileName ):
        outfile = open( _outfileName, "w" )
        outfile.write("<?xml version=\"1.0\" ?>\n")
        self.export( outfile, 0, name_='fileinfo' )
        outfile.close()


    #Only to export the entire XML tree to a Html Page in a file stream on disk
    def outputPageHtml( self, _outfileName ):
        odtStrTitle = "    <span class=\"title\">fileinfo:</span> <br> <br> <br>\n" 
        outfile = open( _outfileName, "w" )
        outfile.write( TEMPLATE_PAGE_P1 % ( odtStrTitle ) )
        self.exportLiteralHtml( outfile, 0, name_='fileinfo' )
        outfile.write( TEMPLATE_PAGE_P2  )
        outfile.close()


    def outputFileHtml( self, _outfileName ):
        self.outputPageHtml( _outfileName )



    #Static method for parsing a string
    def parseString( _inString ):
        doc = minidom.parseString(_inString)
        rootNode = doc.documentElement
        rootObj = fileinfo.factory()
        rootObj.build(rootNode)
        return rootObj
    parseString = staticmethod( parseString ) 


    #Method for marshalling an object
    def marshal( self ):
        oStreamString = StringIO.StringIO()
        oStreamString.write('<?xml version="1.0" ?>\n')
        self.export( oStreamString, 0, name_="fileinfo" )
        oStringXML = oStreamString.getvalue()
        oStreamString.close()
        return oStringXML

    def exportLiteral(self, outfile, level = 0, name_='fileinfo'):
        level += 1
        self.exportLiteralAttributes(outfile, level, name_)
        self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('directory = %s,\n' % quote_python(self.getDirectory()))
        showIndent(outfile, level)
        outfile.write('prefix = %s,\n' % quote_python(self.getPrefix()))
        showIndent(outfile, level)
        outfile.write('suffix = %s,\n' % quote_python(self.getSuffix()))
        showIndent(outfile, level)
        outfile.write('template = %s,\n' % quote_python(self.getTemplate()))
        showIndent(outfile, level)
        outfile.write('run_number = %s,\n' % quote_python(self.getRun_number()))
    def exportLiteralHtml(self, outfile, level = 0, name_='fileinfo'):
        level += 1
        self.exportLiteralAttributesHtml(outfile, level, name_)
        self.exportLiteralChildrenHtml(outfile, level, name_)
    def exportLiteralAttributesHtml(self, outfile, level, name_):
        pass
    def exportLiteralChildrenHtml(self, outfile, level, name_):
        showIndentHtml(outfile, level)
        outfile.write('directory = <a  href:"#">%s</a><br>\n' % quote_python(self.getDirectory()))
        showIndentHtml(outfile, level)
        outfile.write('prefix = <a  href:"#">%s</a><br>\n' % quote_python(self.getPrefix()))
        showIndentHtml(outfile, level)
        outfile.write('suffix = <a  href:"#">%s</a><br>\n' % quote_python(self.getSuffix()))
        showIndentHtml(outfile, level)
        outfile.write('template = <a  href:"#">%s</a><br>\n' % quote_python(self.getTemplate()))
        showIndentHtml(outfile, level)
        outfile.write('run_number = <a  href:"#">%s</a><br>\n' % quote_python(self.getRun_number()))
    def build(self, node_):
        attrs = node_.attributes
        self.buildAttributes(attrs)
        for child_ in node_.childNodes:
            nodeName_ = child_.nodeName.split(':')[-1]
            self.buildChildren(child_, nodeName_)
    def buildAttributes(self, attrs):
        pass
    def buildChildren(self, child_, nodeName_):
        if child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'directory':
            directory_ = ''
            for text__content_ in child_.childNodes:
                directory_ += text__content_.nodeValue
            self.directory = directory_
        elif child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'prefix':
            prefix_ = ''
            for text__content_ in child_.childNodes:
                prefix_ += text__content_.nodeValue
            self.prefix = prefix_
        elif child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'suffix':
            suffix_ = ''
            for text__content_ in child_.childNodes:
                suffix_ += text__content_.nodeValue
            self.suffix = suffix_
        elif child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'template':
            template_ = ''
            for text__content_ in child_.childNodes:
                template_ += text__content_.nodeValue
            self.template = template_
        elif child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'run_number':
            run_number_ = ''
            for text__content_ in child_.childNodes:
                run_number_ += text__content_.nodeValue
            self.run_number = run_number_
# end class fileinfo


class oscillation_sequence(object):
    subclass = None
    def __init__(self, start=0.0, end=0.0, range=0.0, number_of_images='', overlap=0.0, exposure_time=0.0, start_image_number='', number_of_passes=''):
        self.start = start
        self.end = end
        self.range = range
        self.number_of_images = number_of_images
        self.overlap = overlap
        self.exposure_time = exposure_time
        self.start_image_number = start_image_number
        self.number_of_passes = number_of_passes
    def factory(*args_, **kwargs_):
        if oscillation_sequence.subclass:
            return oscillation_sequence.subclass(*args_, **kwargs_)
        else:
            return oscillation_sequence(*args_, **kwargs_)
    factory = staticmethod(factory)
    def getStart(self): return self.start
    def setStart(self, start): self.start = start
    def getEnd(self): return self.end
    def setEnd(self, end): self.end = end
    def getRange(self): return self.range
    def setRange(self, range): self.range = range
    def getNumber_of_images(self): return self.number_of_images
    def setNumber_of_images(self, number_of_images): self.number_of_images = number_of_images
    def getOverlap(self): return self.overlap
    def setOverlap(self, overlap): self.overlap = overlap
    def getExposure_time(self): return self.exposure_time
    def setExposure_time(self, exposure_time): self.exposure_time = exposure_time
    def getStart_image_number(self): return self.start_image_number
    def setStart_image_number(self, start_image_number): self.start_image_number = start_image_number
    def getNumber_of_passes(self): return self.number_of_passes
    def setNumber_of_passes(self, number_of_passes): self.number_of_passes = number_of_passes
    def export(self, outfile, level = 0, name_='oscillation_sequence'):
        showIndent(outfile, level)
        outfile.write('<%s>\n' % name_)
        self.exportChildren(outfile, level + 1, name_)
        showIndent(outfile, level)
        outfile.write('</%s>\n' % name_)
    def exportAttributes(self, outfile, level, name_='oscillation_sequence'):
        pass
    def exportChildren(self, outfile, level, name_='oscillation_sequence'):
        showIndent(outfile, level)
        outfile.write('<start>%e</start>\n' % self.getStart())
        showIndent(outfile, level)
        outfile.write('<end>%e</end>\n' % self.getEnd())
        showIndent(outfile, level)
        outfile.write('<range>%e</range>\n' % self.getRange())
        showIndent(outfile, level)
        outfile.write('<number_of_images>%s</number_of_images>\n' % quote_xml(self.getNumber_of_images()))
        showIndent(outfile, level)
        outfile.write('<overlap>%e</overlap>\n' % self.getOverlap())
        showIndent(outfile, level)
        outfile.write('<exposure_time>%e</exposure_time>\n' % self.getExposure_time())
        showIndent(outfile, level)
        outfile.write('<start_image_number>%s</start_image_number>\n' % quote_xml(self.getStart_image_number()))
        showIndent(outfile, level)
        outfile.write('<number_of_passes>%s</number_of_passes>\n' % quote_xml(self.getNumber_of_passes()))

    #Only to export the entire XML tree to a file stream on disk
    def outputFile( self, _outfileName ):
        outfile = open( _outfileName, "w" )
        outfile.write("<?xml version=\"1.0\" ?>\n")
        self.export( outfile, 0, name_='oscillation_sequence' )
        outfile.close()


    #Only to export the entire XML tree to a Html Page in a file stream on disk
    def outputPageHtml( self, _outfileName ):
        odtStrTitle = "    <span class=\"title\">oscillation_sequence:</span> <br> <br> <br>\n" 
        outfile = open( _outfileName, "w" )
        outfile.write( TEMPLATE_PAGE_P1 % ( odtStrTitle ) )
        self.exportLiteralHtml( outfile, 0, name_='oscillation_sequence' )
        outfile.write( TEMPLATE_PAGE_P2  )
        outfile.close()


    def outputFileHtml( self, _outfileName ):
        self.outputPageHtml( _outfileName )



    #Static method for parsing a string
    def parseString( _inString ):
        doc = minidom.parseString(_inString)
        rootNode = doc.documentElement
        rootObj = oscillation_sequence.factory()
        rootObj.build(rootNode)
        return rootObj
    parseString = staticmethod( parseString ) 


    #Method for marshalling an object
    def marshal( self ):
        oStreamString = StringIO.StringIO()
        oStreamString.write('<?xml version="1.0" ?>\n')
        self.export( oStreamString, 0, name_="oscillation_sequence" )
        oStringXML = oStreamString.getvalue()
        oStreamString.close()
        return oStringXML

    def exportLiteral(self, outfile, level = 0, name_='oscillation_sequence'):
        level += 1
        self.exportLiteralAttributes(outfile, level, name_)
        self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('start = %e,\n' % self.getStart())
        showIndent(outfile, level)
        outfile.write('end = %e,\n' % self.getEnd())
        showIndent(outfile, level)
        outfile.write('range = %e,\n' % self.getRange())
        showIndent(outfile, level)
        outfile.write('number_of_images = %s,\n' % quote_python(self.getNumber_of_images()))
        showIndent(outfile, level)
        outfile.write('overlap = %e,\n' % self.getOverlap())
        showIndent(outfile, level)
        outfile.write('exposure_time = %e,\n' % self.getExposure_time())
        showIndent(outfile, level)
        outfile.write('start_image_number = %s,\n' % quote_python(self.getStart_image_number()))
        showIndent(outfile, level)
        outfile.write('number_of_passes = %s,\n' % quote_python(self.getNumber_of_passes()))
    def exportLiteralHtml(self, outfile, level = 0, name_='oscillation_sequence'):
        level += 1
        self.exportLiteralAttributesHtml(outfile, level, name_)
        self.exportLiteralChildrenHtml(outfile, level, name_)
    def exportLiteralAttributesHtml(self, outfile, level, name_):
        pass
    def exportLiteralChildrenHtml(self, outfile, level, name_):
        showIndentHtml(outfile, level)
        outfile.write('start = <a  href:"#">%e</a><br>\n' % self.getStart())
        showIndentHtml(outfile, level)
        outfile.write('end = <a  href:"#">%e</a><br>\n' % self.getEnd())
        showIndentHtml(outfile, level)
        outfile.write('range = <a  href:"#">%e</a><br>\n' % self.getRange())
        showIndentHtml(outfile, level)
        outfile.write('number_of_images = <a  href:"#">%s</a><br>\n' % quote_python(self.getNumber_of_images()))
        showIndentHtml(outfile, level)
        outfile.write('overlap = <a  href:"#">%e</a><br>\n' % self.getOverlap())
        showIndentHtml(outfile, level)
        outfile.write('exposure_time = <a  href:"#">%e</a><br>\n' % self.getExposure_time())
        showIndentHtml(outfile, level)
        outfile.write('start_image_number = <a  href:"#">%s</a><br>\n' % quote_python(self.getStart_image_number()))
        showIndentHtml(outfile, level)
        outfile.write('number_of_passes = <a  href:"#">%s</a><br>\n' % quote_python(self.getNumber_of_passes()))
    def build(self, node_):
        attrs = node_.attributes
        self.buildAttributes(attrs)
        for child_ in node_.childNodes:
            nodeName_ = child_.nodeName.split(':')[-1]
            self.buildChildren(child_, nodeName_)
    def buildAttributes(self, attrs):
        pass
    def buildChildren(self, child_, nodeName_):
        if child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'start':
            if child_.firstChild:
                sval_ = child_.firstChild.nodeValue
                try:
                    fval_ = float(sval_)
                except ValueError:
                    raise ValueError('requires float (or double) -- %s' % child_.toxml())
                self.start = fval_
        elif child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'end':
            if child_.firstChild:
                sval_ = child_.firstChild.nodeValue
                try:
                    fval_ = float(sval_)
                except ValueError:
                    raise ValueError('requires float (or double) -- %s' % child_.toxml())
                self.end = fval_
        elif child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'range':
            if child_.firstChild:
                sval_ = child_.firstChild.nodeValue
                try:
                    fval_ = float(sval_)
                except ValueError:
                    raise ValueError('requires float (or double) -- %s' % child_.toxml())
                self.range = fval_
        elif child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'number_of_images':
            number_of_images_ = ''
            for text__content_ in child_.childNodes:
                number_of_images_ += text__content_.nodeValue
            self.number_of_images = number_of_images_
        elif child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'overlap':
            if child_.firstChild:
                sval_ = child_.firstChild.nodeValue
                try:
                    fval_ = float(sval_)
                except ValueError:
                    raise ValueError('requires float (or double) -- %s' % child_.toxml())
                self.overlap = fval_
        elif child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'exposure_time':
            if child_.firstChild:
                sval_ = child_.firstChild.nodeValue
                try:
                    fval_ = float(sval_)
                except ValueError:
                    raise ValueError('requires float (or double) -- %s' % child_.toxml())
                self.exposure_time = fval_
        elif child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'start_image_number':
            start_image_number_ = ''
            for text__content_ in child_.childNodes:
                start_image_number_ += text__content_.nodeValue
            self.start_image_number = start_image_number_
        elif child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'number_of_passes':
            number_of_passes_ = ''
            for text__content_ in child_.childNodes:
                number_of_passes_ += text__content_.nodeValue
            self.number_of_passes = number_of_passes_
# end class oscillation_sequence


class detector(object):
    subclass = None
    def __init__(self, ttype='', suffix=''):
        self.ttype = ttype
        self.suffix = suffix
    def factory(*args_, **kwargs_):
        if detector.subclass:
            return detector.subclass(*args_, **kwargs_)
        else:
            return detector(*args_, **kwargs_)
    factory = staticmethod(factory)
    def getType(self): return self.ttype
    def setType(self, ttype): self.ttype = ttype
    def getSuffix(self): return self.suffix
    def setSuffix(self, suffix): self.suffix = suffix
    def export(self, outfile, level = 0, name_='detector'):
        showIndent(outfile, level)
        outfile.write('<%s>\n' % name_)
        self.exportChildren(outfile, level + 1, name_)
        showIndent(outfile, level)
        outfile.write('</%s>\n' % name_)
    def exportAttributes(self, outfile, level, name_='detector'):
        pass
    def exportChildren(self, outfile, level, name_='detector'):
        showIndent(outfile, level)
        outfile.write('<type>%s</type>\n' % quote_xml(self.getType()))
        showIndent(outfile, level)
        outfile.write('<suffix>%s</suffix>\n' % quote_xml(self.getSuffix()))

    #Only to export the entire XML tree to a file stream on disk
    def outputFile( self, _outfileName ):
        outfile = open( _outfileName, "w" )
        outfile.write("<?xml version=\"1.0\" ?>\n")
        self.export( outfile, 0, name_='detector' )
        outfile.close()


    #Only to export the entire XML tree to a Html Page in a file stream on disk
    def outputPageHtml( self, _outfileName ):
        odtStrTitle = "    <span class=\"title\">detector:</span> <br> <br> <br>\n" 
        outfile = open( _outfileName, "w" )
        outfile.write( TEMPLATE_PAGE_P1 % ( odtStrTitle ) )
        self.exportLiteralHtml( outfile, 0, name_='detector' )
        outfile.write( TEMPLATE_PAGE_P2  )
        outfile.close()


    def outputFileHtml( self, _outfileName ):
        self.outputPageHtml( _outfileName )



    #Static method for parsing a string
    def parseString( _inString ):
        doc = minidom.parseString(_inString)
        rootNode = doc.documentElement
        rootObj = detector.factory()
        rootObj.build(rootNode)
        return rootObj
    parseString = staticmethod( parseString ) 


    #Method for marshalling an object
    def marshal( self ):
        oStreamString = StringIO.StringIO()
        oStreamString.write('<?xml version="1.0" ?>\n')
        self.export( oStreamString, 0, name_="detector" )
        oStringXML = oStreamString.getvalue()
        oStreamString.close()
        return oStringXML

    def exportLiteral(self, outfile, level = 0, name_='detector'):
        level += 1
        self.exportLiteralAttributes(outfile, level, name_)
        self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('ttype = %s,\n' % quote_python(self.getType()))
        showIndent(outfile, level)
        outfile.write('suffix = %s,\n' % quote_python(self.getSuffix()))
    def exportLiteralHtml(self, outfile, level = 0, name_='detector'):
        level += 1
        self.exportLiteralAttributesHtml(outfile, level, name_)
        self.exportLiteralChildrenHtml(outfile, level, name_)
    def exportLiteralAttributesHtml(self, outfile, level, name_):
        pass
    def exportLiteralChildrenHtml(self, outfile, level, name_):
        showIndentHtml(outfile, level)
        outfile.write('ttype = <a  href:"#">%s</a><br>\n' % quote_python(self.getType()))
        showIndentHtml(outfile, level)
        outfile.write('suffix = <a  href:"#">%s</a><br>\n' % quote_python(self.getSuffix()))
    def build(self, node_):
        attrs = node_.attributes
        self.buildAttributes(attrs)
        for child_ in node_.childNodes:
            nodeName_ = child_.nodeName.split(':')[-1]
            self.buildChildren(child_, nodeName_)
    def buildAttributes(self, attrs):
        pass
    def buildChildren(self, child_, nodeName_):
        if child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'type':
            type_ = ''
            for text__content_ in child_.childNodes:
                type_ += text__content_.nodeValue
            self.ttype = type_
        elif child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'suffix':
            suffix_ = ''
            for text__content_ in child_.childNodes:
                suffix_ += text__content_.nodeValue
            self.suffix = suffix_
# end class detector


class beam(object):
    subclass = None
    def __init__(self, x=0.0, y=0.0):
        self.x = x
        self.y = y
    def factory(*args_, **kwargs_):
        if beam.subclass:
            return beam.subclass(*args_, **kwargs_)
        else:
            return beam(*args_, **kwargs_)
    factory = staticmethod(factory)
    def getX(self): return self.x
    def setX(self, x): self.x = x
    def getY(self): return self.y
    def setY(self, y): self.y = y
    def export(self, outfile, level = 0, name_='beam'):
        showIndent(outfile, level)
        outfile.write('<%s>\n' % name_)
        self.exportChildren(outfile, level + 1, name_)
        showIndent(outfile, level)
        outfile.write('</%s>\n' % name_)
    def exportAttributes(self, outfile, level, name_='beam'):
        pass
    def exportChildren(self, outfile, level, name_='beam'):
        showIndent(outfile, level)
        outfile.write('<x>%e</x>\n' % self.getX())
        showIndent(outfile, level)
        outfile.write('<y>%e</y>\n' % self.getY())

    #Only to export the entire XML tree to a file stream on disk
    def outputFile( self, _outfileName ):
        outfile = open( _outfileName, "w" )
        outfile.write("<?xml version=\"1.0\" ?>\n")
        self.export( outfile, 0, name_='beam' )
        outfile.close()


    #Only to export the entire XML tree to a Html Page in a file stream on disk
    def outputPageHtml( self, _outfileName ):
        odtStrTitle = "    <span class=\"title\">beam:</span> <br> <br> <br>\n" 
        outfile = open( _outfileName, "w" )
        outfile.write( TEMPLATE_PAGE_P1 % ( odtStrTitle ) )
        self.exportLiteralHtml( outfile, 0, name_='beam' )
        outfile.write( TEMPLATE_PAGE_P2  )
        outfile.close()


    def outputFileHtml( self, _outfileName ):
        self.outputPageHtml( _outfileName )



    #Static method for parsing a string
    def parseString( _inString ):
        doc = minidom.parseString(_inString)
        rootNode = doc.documentElement
        rootObj = beam.factory()
        rootObj.build(rootNode)
        return rootObj
    parseString = staticmethod( parseString ) 


    #Method for marshalling an object
    def marshal( self ):
        oStreamString = StringIO.StringIO()
        oStreamString.write('<?xml version="1.0" ?>\n')
        self.export( oStreamString, 0, name_="beam" )
        oStringXML = oStreamString.getvalue()
        oStreamString.close()
        return oStringXML

    def exportLiteral(self, outfile, level = 0, name_='beam'):
        level += 1
        self.exportLiteralAttributes(outfile, level, name_)
        self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('x = %e,\n' % self.getX())
        showIndent(outfile, level)
        outfile.write('y = %e,\n' % self.getY())
    def exportLiteralHtml(self, outfile, level = 0, name_='beam'):
        level += 1
        self.exportLiteralAttributesHtml(outfile, level, name_)
        self.exportLiteralChildrenHtml(outfile, level, name_)
    def exportLiteralAttributesHtml(self, outfile, level, name_):
        pass
    def exportLiteralChildrenHtml(self, outfile, level, name_):
        showIndentHtml(outfile, level)
        outfile.write('x = <a  href:"#">%e</a><br>\n' % self.getX())
        showIndentHtml(outfile, level)
        outfile.write('y = <a  href:"#">%e</a><br>\n' % self.getY())
    def build(self, node_):
        attrs = node_.attributes
        self.buildAttributes(attrs)
        for child_ in node_.childNodes:
            nodeName_ = child_.nodeName.split(':')[-1]
            self.buildChildren(child_, nodeName_)
    def buildAttributes(self, attrs):
        pass
    def buildChildren(self, child_, nodeName_):
        if child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'x':
            if child_.firstChild:
                sval_ = child_.firstChild.nodeValue
                try:
                    fval_ = float(sval_)
                except ValueError:
                    raise ValueError('requires float (or double) -- %s' % child_.toxml())
                self.x = fval_
        elif child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'y':
            if child_.firstChild:
                sval_ = child_.firstChild.nodeValue
                try:
                    fval_ = float(sval_)
                except ValueError:
                    raise ValueError('requires float (or double) -- %s' % child_.toxml())
                self.y = fval_
# end class beam


class cell(object):
    subclass = None
    def __init__(self, a=0.0, b=0.0, c=0.0, alpha=0.0, beta=0.0, gamma=0.0):
        self.a = a
        self.b = b
        self.c = c
        self.alpha = alpha
        self.beta = beta
        self.gamma = gamma
    def factory(*args_, **kwargs_):
        if cell.subclass:
            return cell.subclass(*args_, **kwargs_)
        else:
            return cell(*args_, **kwargs_)
    factory = staticmethod(factory)
    def getA(self): return self.a
    def setA(self, a): self.a = a
    def getB(self): return self.b
    def setB(self, b): self.b = b
    def getC(self): return self.c
    def setC(self, c): self.c = c
    def getAlpha(self): return self.alpha
    def setAlpha(self, alpha): self.alpha = alpha
    def getBeta(self): return self.beta
    def setBeta(self, beta): self.beta = beta
    def getGamma(self): return self.gamma
    def setGamma(self, gamma): self.gamma = gamma
    def export(self, outfile, level = 0, name_='cell'):
        showIndent(outfile, level)
        outfile.write('<%s>\n' % name_)
        self.exportChildren(outfile, level + 1, name_)
        showIndent(outfile, level)
        outfile.write('</%s>\n' % name_)
    def exportAttributes(self, outfile, level, name_='cell'):
        pass
    def exportChildren(self, outfile, level, name_='cell'):
        showIndent(outfile, level)
        outfile.write('<a>%e</a>\n' % self.getA())
        showIndent(outfile, level)
        outfile.write('<b>%e</b>\n' % self.getB())
        showIndent(outfile, level)
        outfile.write('<c>%e</c>\n' % self.getC())
        showIndent(outfile, level)
        outfile.write('<alpha>%e</alpha>\n' % self.getAlpha())
        showIndent(outfile, level)
        outfile.write('<beta>%e</beta>\n' % self.getBeta())
        showIndent(outfile, level)
        outfile.write('<gamma>%e</gamma>\n' % self.getGamma())

    #Only to export the entire XML tree to a file stream on disk
    def outputFile( self, _outfileName ):
        outfile = open( _outfileName, "w" )
        outfile.write("<?xml version=\"1.0\" ?>\n")
        self.export( outfile, 0, name_='cell' )
        outfile.close()


    #Only to export the entire XML tree to a Html Page in a file stream on disk
    def outputPageHtml( self, _outfileName ):
        odtStrTitle = "    <span class=\"title\">cell:</span> <br> <br> <br>\n" 
        outfile = open( _outfileName, "w" )
        outfile.write( TEMPLATE_PAGE_P1 % ( odtStrTitle ) )
        self.exportLiteralHtml( outfile, 0, name_='cell' )
        outfile.write( TEMPLATE_PAGE_P2  )
        outfile.close()


    def outputFileHtml( self, _outfileName ):
        self.outputPageHtml( _outfileName )



    #Static method for parsing a string
    def parseString( _inString ):
        doc = minidom.parseString(_inString)
        rootNode = doc.documentElement
        rootObj = cell.factory()
        rootObj.build(rootNode)
        return rootObj
    parseString = staticmethod( parseString ) 


    #Method for marshalling an object
    def marshal( self ):
        oStreamString = StringIO.StringIO()
        oStreamString.write('<?xml version="1.0" ?>\n')
        self.export( oStreamString, 0, name_="cell" )
        oStringXML = oStreamString.getvalue()
        oStreamString.close()
        return oStringXML

    def exportLiteral(self, outfile, level = 0, name_='cell'):
        level += 1
        self.exportLiteralAttributes(outfile, level, name_)
        self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('a = %e,\n' % self.getA())
        showIndent(outfile, level)
        outfile.write('b = %e,\n' % self.getB())
        showIndent(outfile, level)
        outfile.write('c = %e,\n' % self.getC())
        showIndent(outfile, level)
        outfile.write('alpha = %e,\n' % self.getAlpha())
        showIndent(outfile, level)
        outfile.write('beta = %e,\n' % self.getBeta())
        showIndent(outfile, level)
        outfile.write('gamma = %e,\n' % self.getGamma())
    def exportLiteralHtml(self, outfile, level = 0, name_='cell'):
        level += 1
        self.exportLiteralAttributesHtml(outfile, level, name_)
        self.exportLiteralChildrenHtml(outfile, level, name_)
    def exportLiteralAttributesHtml(self, outfile, level, name_):
        pass
    def exportLiteralChildrenHtml(self, outfile, level, name_):
        showIndentHtml(outfile, level)
        outfile.write('a = <a  href:"#">%e</a><br>\n' % self.getA())
        showIndentHtml(outfile, level)
        outfile.write('b = <a  href:"#">%e</a><br>\n' % self.getB())
        showIndentHtml(outfile, level)
        outfile.write('c = <a  href:"#">%e</a><br>\n' % self.getC())
        showIndentHtml(outfile, level)
        outfile.write('alpha = <a  href:"#">%e</a><br>\n' % self.getAlpha())
        showIndentHtml(outfile, level)
        outfile.write('beta = <a  href:"#">%e</a><br>\n' % self.getBeta())
        showIndentHtml(outfile, level)
        outfile.write('gamma = <a  href:"#">%e</a><br>\n' % self.getGamma())
    def build(self, node_):
        attrs = node_.attributes
        self.buildAttributes(attrs)
        for child_ in node_.childNodes:
            nodeName_ = child_.nodeName.split(':')[-1]
            self.buildChildren(child_, nodeName_)
    def buildAttributes(self, attrs):
        pass
    def buildChildren(self, child_, nodeName_):
        if child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'a':
            if child_.firstChild:
                sval_ = child_.firstChild.nodeValue
                try:
                    fval_ = float(sval_)
                except ValueError:
                    raise ValueError('requires float (or double) -- %s' % child_.toxml())
                self.a = fval_
        elif child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'b':
            if child_.firstChild:
                sval_ = child_.firstChild.nodeValue
                try:
                    fval_ = float(sval_)
                except ValueError:
                    raise ValueError('requires float (or double) -- %s' % child_.toxml())
                self.b = fval_
        elif child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'c':
            if child_.firstChild:
                sval_ = child_.firstChild.nodeValue
                try:
                    fval_ = float(sval_)
                except ValueError:
                    raise ValueError('requires float (or double) -- %s' % child_.toxml())
                self.c = fval_
        elif child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'alpha':
            if child_.firstChild:
                sval_ = child_.firstChild.nodeValue
                try:
                    fval_ = float(sval_)
                except ValueError:
                    raise ValueError('requires float (or double) -- %s' % child_.toxml())
                self.alpha = fval_
        elif child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'beta':
            if child_.firstChild:
                sval_ = child_.firstChild.nodeValue
                try:
                    fval_ = float(sval_)
                except ValueError:
                    raise ValueError('requires float (or double) -- %s' % child_.toxml())
                self.beta = fval_
        elif child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'gamma':
            if child_.firstChild:
                sval_ = child_.firstChild.nodeValue
                try:
                    fval_ = float(sval_)
                except ValueError:
                    raise ValueError('requires float (or double) -- %s' % child_.toxml())
                self.gamma = fval_
# end class cell


class experiment(object):
    subclass = None
    def __init__(self, wavelength=0.0, distance=0.0, resolution=None):
        self.wavelength = wavelength
        self.distance = distance
        self.resolution = resolution
    def factory(*args_, **kwargs_):
        if experiment.subclass:
            return experiment.subclass(*args_, **kwargs_)
        else:
            return experiment(*args_, **kwargs_)
    factory = staticmethod(factory)
    def getWavelength(self): return self.wavelength
    def setWavelength(self, wavelength): self.wavelength = wavelength
    def getDistance(self): return self.distance
    def setDistance(self, distance): self.distance = distance
    def getResolution(self): return self.resolution
    def setResolution(self, resolution): self.resolution = resolution
    def export(self, outfile, level = 0, name_='experiment'):
        showIndent(outfile, level)
        outfile.write('<%s>\n' % name_)
        self.exportChildren(outfile, level + 1, name_)
        showIndent(outfile, level)
        outfile.write('</%s>\n' % name_)
    def exportAttributes(self, outfile, level, name_='experiment'):
        pass
    def exportChildren(self, outfile, level, name_='experiment'):
        showIndent(outfile, level)
        outfile.write('<wavelength>%e</wavelength>\n' % self.getWavelength())
        showIndent(outfile, level)
        outfile.write('<distance>%e</distance>\n' % self.getDistance())
        if self.resolution:
            self.resolution.export(outfile, level)

    #Only to export the entire XML tree to a file stream on disk
    def outputFile( self, _outfileName ):
        outfile = open( _outfileName, "w" )
        outfile.write("<?xml version=\"1.0\" ?>\n")
        self.export( outfile, 0, name_='experiment' )
        outfile.close()


    #Only to export the entire XML tree to a Html Page in a file stream on disk
    def outputPageHtml( self, _outfileName ):
        odtStrTitle = "    <span class=\"title\">experiment:</span> <br> <br> <br>\n" 
        outfile = open( _outfileName, "w" )
        outfile.write( TEMPLATE_PAGE_P1 % ( odtStrTitle ) )
        self.exportLiteralHtml( outfile, 0, name_='experiment' )
        outfile.write( TEMPLATE_PAGE_P2  )
        outfile.close()


    def outputFileHtml( self, _outfileName ):
        self.outputPageHtml( _outfileName )



    #Static method for parsing a string
    def parseString( _inString ):
        doc = minidom.parseString(_inString)
        rootNode = doc.documentElement
        rootObj = experiment.factory()
        rootObj.build(rootNode)
        return rootObj
    parseString = staticmethod( parseString ) 


    #Method for marshalling an object
    def marshal( self ):
        oStreamString = StringIO.StringIO()
        oStreamString.write('<?xml version="1.0" ?>\n')
        self.export( oStreamString, 0, name_="experiment" )
        oStringXML = oStreamString.getvalue()
        oStreamString.close()
        return oStringXML

    def exportLiteral(self, outfile, level = 0, name_='experiment'):
        level += 1
        self.exportLiteralAttributes(outfile, level, name_)
        self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('wavelength = %e,\n' % self.getWavelength())
        showIndent(outfile, level)
        outfile.write('distance = %e,\n' % self.getDistance())
        if self.resolution:
            showIndent(outfile, level)
            outfile.write('resolution = resolution(\n')
            self.resolution.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
    def exportLiteralHtml(self, outfile, level = 0, name_='experiment'):
        level += 1
        self.exportLiteralAttributesHtml(outfile, level, name_)
        self.exportLiteralChildrenHtml(outfile, level, name_)
    def exportLiteralAttributesHtml(self, outfile, level, name_):
        pass
    def exportLiteralChildrenHtml(self, outfile, level, name_):
        showIndentHtml(outfile, level)
        outfile.write('wavelength = <a  href:"#">%e</a><br>\n' % self.getWavelength())
        showIndentHtml(outfile, level)
        outfile.write('distance = <a  href:"#">%e</a><br>\n' % self.getDistance())
        if self.resolution:
            showIndentHtml(outfile, level)
            outfile.write('resolution<br>\n')
            self.resolution.exportLiteralHtml(outfile, level)
            showIndentHtml(outfile, level)
            outfile.write('<br>\n')
    def build(self, node_):
        attrs = node_.attributes
        self.buildAttributes(attrs)
        for child_ in node_.childNodes:
            nodeName_ = child_.nodeName.split(':')[-1]
            self.buildChildren(child_, nodeName_)
    def buildAttributes(self, attrs):
        pass
    def buildChildren(self, child_, nodeName_):
        if child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'wavelength':
            if child_.firstChild:
                sval_ = child_.firstChild.nodeValue
                try:
                    fval_ = float(sval_)
                except ValueError:
                    raise ValueError('requires float (or double) -- %s' % child_.toxml())
                self.wavelength = fval_
        elif child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'distance':
            if child_.firstChild:
                sval_ = child_.firstChild.nodeValue
                try:
                    fval_ = float(sval_)
                except ValueError:
                    raise ValueError('requires float (or double) -- %s' % child_.toxml())
                self.distance = fval_
        elif child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'resolution':
            obj_ = resolution.factory()
            obj_.build(child_)
            self.setResolution(obj_)
# end class experiment


class matrix(object):
    subclass = None
    def __init__(self, e11=0.0, e12=0.0, e13=0.0, e21=0.0, e22=0.0, e23=0.0, e31=0.0, e32=0.0, e33=0.0):
        self.e11 = e11
        self.e12 = e12
        self.e13 = e13
        self.e21 = e21
        self.e22 = e22
        self.e23 = e23
        self.e31 = e31
        self.e32 = e32
        self.e33 = e33
    def factory(*args_, **kwargs_):
        if matrix.subclass:
            return matrix.subclass(*args_, **kwargs_)
        else:
            return matrix(*args_, **kwargs_)
    factory = staticmethod(factory)
    def getE11(self): return self.e11
    def setE11(self, e11): self.e11 = e11
    def getE12(self): return self.e12
    def setE12(self, e12): self.e12 = e12
    def getE13(self): return self.e13
    def setE13(self, e13): self.e13 = e13
    def getE21(self): return self.e21
    def setE21(self, e21): self.e21 = e21
    def getE22(self): return self.e22
    def setE22(self, e22): self.e22 = e22
    def getE23(self): return self.e23
    def setE23(self, e23): self.e23 = e23
    def getE31(self): return self.e31
    def setE31(self, e31): self.e31 = e31
    def getE32(self): return self.e32
    def setE32(self, e32): self.e32 = e32
    def getE33(self): return self.e33
    def setE33(self, e33): self.e33 = e33
    def export(self, outfile, level = 0, name_='matrix'):
        showIndent(outfile, level)
        outfile.write('<%s>\n' % name_)
        self.exportChildren(outfile, level + 1, name_)
        showIndent(outfile, level)
        outfile.write('</%s>\n' % name_)
    def exportAttributes(self, outfile, level, name_='matrix'):
        pass
    def exportChildren(self, outfile, level, name_='matrix'):
        showIndent(outfile, level)
        outfile.write('<e11>%e</e11>\n' % self.getE11())
        showIndent(outfile, level)
        outfile.write('<e12>%e</e12>\n' % self.getE12())
        showIndent(outfile, level)
        outfile.write('<e13>%e</e13>\n' % self.getE13())
        showIndent(outfile, level)
        outfile.write('<e21>%e</e21>\n' % self.getE21())
        showIndent(outfile, level)
        outfile.write('<e22>%e</e22>\n' % self.getE22())
        showIndent(outfile, level)
        outfile.write('<e23>%e</e23>\n' % self.getE23())
        showIndent(outfile, level)
        outfile.write('<e31>%e</e31>\n' % self.getE31())
        showIndent(outfile, level)
        outfile.write('<e32>%e</e32>\n' % self.getE32())
        showIndent(outfile, level)
        outfile.write('<e33>%e</e33>\n' % self.getE33())

    #Only to export the entire XML tree to a file stream on disk
    def outputFile( self, _outfileName ):
        outfile = open( _outfileName, "w" )
        outfile.write("<?xml version=\"1.0\" ?>\n")
        self.export( outfile, 0, name_='matrix' )
        outfile.close()


    #Only to export the entire XML tree to a Html Page in a file stream on disk
    def outputPageHtml( self, _outfileName ):
        odtStrTitle = "    <span class=\"title\">matrix:</span> <br> <br> <br>\n" 
        outfile = open( _outfileName, "w" )
        outfile.write( TEMPLATE_PAGE_P1 % ( odtStrTitle ) )
        self.exportLiteralHtml( outfile, 0, name_='matrix' )
        outfile.write( TEMPLATE_PAGE_P2  )
        outfile.close()


    def outputFileHtml( self, _outfileName ):
        self.outputPageHtml( _outfileName )



    #Static method for parsing a string
    def parseString( _inString ):
        doc = minidom.parseString(_inString)
        rootNode = doc.documentElement
        rootObj = matrix.factory()
        rootObj.build(rootNode)
        return rootObj
    parseString = staticmethod( parseString ) 


    #Method for marshalling an object
    def marshal( self ):
        oStreamString = StringIO.StringIO()
        oStreamString.write('<?xml version="1.0" ?>\n')
        self.export( oStreamString, 0, name_="matrix" )
        oStringXML = oStreamString.getvalue()
        oStreamString.close()
        return oStringXML

    def exportLiteral(self, outfile, level = 0, name_='matrix'):
        level += 1
        self.exportLiteralAttributes(outfile, level, name_)
        self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('e11 = %e,\n' % self.getE11())
        showIndent(outfile, level)
        outfile.write('e12 = %e,\n' % self.getE12())
        showIndent(outfile, level)
        outfile.write('e13 = %e,\n' % self.getE13())
        showIndent(outfile, level)
        outfile.write('e21 = %e,\n' % self.getE21())
        showIndent(outfile, level)
        outfile.write('e22 = %e,\n' % self.getE22())
        showIndent(outfile, level)
        outfile.write('e23 = %e,\n' % self.getE23())
        showIndent(outfile, level)
        outfile.write('e31 = %e,\n' % self.getE31())
        showIndent(outfile, level)
        outfile.write('e32 = %e,\n' % self.getE32())
        showIndent(outfile, level)
        outfile.write('e33 = %e,\n' % self.getE33())
    def exportLiteralHtml(self, outfile, level = 0, name_='matrix'):
        level += 1
        self.exportLiteralAttributesHtml(outfile, level, name_)
        self.exportLiteralChildrenHtml(outfile, level, name_)
    def exportLiteralAttributesHtml(self, outfile, level, name_):
        pass
    def exportLiteralChildrenHtml(self, outfile, level, name_):
        showIndentHtml(outfile, level)
        outfile.write('e11 = <a  href:"#">%e</a><br>\n' % self.getE11())
        showIndentHtml(outfile, level)
        outfile.write('e12 = <a  href:"#">%e</a><br>\n' % self.getE12())
        showIndentHtml(outfile, level)
        outfile.write('e13 = <a  href:"#">%e</a><br>\n' % self.getE13())
        showIndentHtml(outfile, level)
        outfile.write('e21 = <a  href:"#">%e</a><br>\n' % self.getE21())
        showIndentHtml(outfile, level)
        outfile.write('e22 = <a  href:"#">%e</a><br>\n' % self.getE22())
        showIndentHtml(outfile, level)
        outfile.write('e23 = <a  href:"#">%e</a><br>\n' % self.getE23())
        showIndentHtml(outfile, level)
        outfile.write('e31 = <a  href:"#">%e</a><br>\n' % self.getE31())
        showIndentHtml(outfile, level)
        outfile.write('e32 = <a  href:"#">%e</a><br>\n' % self.getE32())
        showIndentHtml(outfile, level)
        outfile.write('e33 = <a  href:"#">%e</a><br>\n' % self.getE33())
    def build(self, node_):
        attrs = node_.attributes
        self.buildAttributes(attrs)
        for child_ in node_.childNodes:
            nodeName_ = child_.nodeName.split(':')[-1]
            self.buildChildren(child_, nodeName_)
    def buildAttributes(self, attrs):
        pass
    def buildChildren(self, child_, nodeName_):
        if child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'e11':
            if child_.firstChild:
                sval_ = child_.firstChild.nodeValue
                try:
                    fval_ = float(sval_)
                except ValueError:
                    raise ValueError('requires float (or double) -- %s' % child_.toxml())
                self.e11 = fval_
        elif child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'e12':
            if child_.firstChild:
                sval_ = child_.firstChild.nodeValue
                try:
                    fval_ = float(sval_)
                except ValueError:
                    raise ValueError('requires float (or double) -- %s' % child_.toxml())
                self.e12 = fval_
        elif child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'e13':
            if child_.firstChild:
                sval_ = child_.firstChild.nodeValue
                try:
                    fval_ = float(sval_)
                except ValueError:
                    raise ValueError('requires float (or double) -- %s' % child_.toxml())
                self.e13 = fval_
        elif child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'e21':
            if child_.firstChild:
                sval_ = child_.firstChild.nodeValue
                try:
                    fval_ = float(sval_)
                except ValueError:
                    raise ValueError('requires float (or double) -- %s' % child_.toxml())
                self.e21 = fval_
        elif child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'e22':
            if child_.firstChild:
                sval_ = child_.firstChild.nodeValue
                try:
                    fval_ = float(sval_)
                except ValueError:
                    raise ValueError('requires float (or double) -- %s' % child_.toxml())
                self.e22 = fval_
        elif child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'e23':
            if child_.firstChild:
                sval_ = child_.firstChild.nodeValue
                try:
                    fval_ = float(sval_)
                except ValueError:
                    raise ValueError('requires float (or double) -- %s' % child_.toxml())
                self.e23 = fval_
        elif child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'e31':
            if child_.firstChild:
                sval_ = child_.firstChild.nodeValue
                try:
                    fval_ = float(sval_)
                except ValueError:
                    raise ValueError('requires float (or double) -- %s' % child_.toxml())
                self.e31 = fval_
        elif child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'e32':
            if child_.firstChild:
                sval_ = child_.firstChild.nodeValue
                try:
                    fval_ = float(sval_)
                except ValueError:
                    raise ValueError('requires float (or double) -- %s' % child_.toxml())
                self.e32 = fval_
        elif child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'e33':
            if child_.firstChild:
                sval_ = child_.firstChild.nodeValue
                try:
                    fval_ = float(sval_)
                except ValueError:
                    raise ValueError('requires float (or double) -- %s' % child_.toxml())
                self.e33 = fval_
# end class matrix


class dna_message(object):
    subclass = None
    def __init__(self, ttype='', content_type='', level='', message=''):
        self.ttype = ttype
        self.content_type = content_type
        self.level = level
        self.message = message
    def factory(*args_, **kwargs_):
        if dna_message.subclass:
            return dna_message.subclass(*args_, **kwargs_)
        else:
            return dna_message(*args_, **kwargs_)
    factory = staticmethod(factory)
    def getType(self): return self.ttype
    def setType(self, ttype): self.ttype = ttype
    def getContent_type(self): return self.content_type
    def setContent_type(self, content_type): self.content_type = content_type
    def getLevel(self): return self.level
    def setLevel(self, level): self.level = level
    def getMessage(self): return self.message
    def setMessage(self, message): self.message = message
    def export(self, outfile, level = 0, name_='dna_message'):
        showIndent(outfile, level)
        outfile.write('<%s>\n' % name_)
        self.exportChildren(outfile, level + 1, name_)
        showIndent(outfile, level)
        outfile.write('</%s>\n' % name_)
    def exportAttributes(self, outfile, level, name_='dna_message'):
        pass
    def exportChildren(self, outfile, level, name_='dna_message'):
        showIndent(outfile, level)
        outfile.write('<type>%s</type>\n' % quote_xml(self.getType()))
        showIndent(outfile, level)
        outfile.write('<content_type>%s</content_type>\n' % quote_xml(self.getContent_type()))
        showIndent(outfile, level)
        outfile.write('<level>%s</level>\n' % quote_xml(self.getLevel()))
        showIndent(outfile, level)
        outfile.write('<message>%s</message>\n' % quote_xml(self.getMessage()))

    #Only to export the entire XML tree to a file stream on disk
    def outputFile( self, _outfileName ):
        outfile = open( _outfileName, "w" )
        outfile.write("<?xml version=\"1.0\" ?>\n")
        self.export( outfile, 0, name_='dna_message' )
        outfile.close()


    #Only to export the entire XML tree to a Html Page in a file stream on disk
    def outputPageHtml( self, _outfileName ):
        odtStrTitle = "    <span class=\"title\">dna_message:</span> <br> <br> <br>\n" 
        outfile = open( _outfileName, "w" )
        outfile.write( TEMPLATE_PAGE_P1 % ( odtStrTitle ) )
        self.exportLiteralHtml( outfile, 0, name_='dna_message' )
        outfile.write( TEMPLATE_PAGE_P2  )
        outfile.close()


    def outputFileHtml( self, _outfileName ):
        self.outputPageHtml( _outfileName )



    #Static method for parsing a string
    def parseString( _inString ):
        doc = minidom.parseString(_inString)
        rootNode = doc.documentElement
        rootObj = dna_message.factory()
        rootObj.build(rootNode)
        return rootObj
    parseString = staticmethod( parseString ) 


    #Method for marshalling an object
    def marshal( self ):
        oStreamString = StringIO.StringIO()
        oStreamString.write('<?xml version="1.0" ?>\n')
        self.export( oStreamString, 0, name_="dna_message" )
        oStringXML = oStreamString.getvalue()
        oStreamString.close()
        return oStringXML

    def exportLiteral(self, outfile, level = 0, name_='dna_message'):
        level += 1
        self.exportLiteralAttributes(outfile, level, name_)
        self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('ttype = %s,\n' % quote_python(self.getType()))
        showIndent(outfile, level)
        outfile.write('content_type = %s,\n' % quote_python(self.getContent_type()))
        showIndent(outfile, level)
        outfile.write('level = %s,\n' % quote_python(self.getLevel()))
        showIndent(outfile, level)
        outfile.write('message = %s,\n' % quote_python(self.getMessage()))
    def exportLiteralHtml(self, outfile, level = 0, name_='dna_message'):
        level += 1
        self.exportLiteralAttributesHtml(outfile, level, name_)
        self.exportLiteralChildrenHtml(outfile, level, name_)
    def exportLiteralAttributesHtml(self, outfile, level, name_):
        pass
    def exportLiteralChildrenHtml(self, outfile, level, name_):
        showIndentHtml(outfile, level)
        outfile.write('ttype = <a  href:"#">%s</a><br>\n' % quote_python(self.getType()))
        showIndentHtml(outfile, level)
        outfile.write('content_type = <a  href:"#">%s</a><br>\n' % quote_python(self.getContent_type()))
        showIndentHtml(outfile, level)
        outfile.write('level = <a  href:"#">%s</a><br>\n' % quote_python(self.getLevel()))
        showIndentHtml(outfile, level)
        outfile.write('message = <a  href:"#">%s</a><br>\n' % quote_python(self.getMessage()))
    def build(self, node_):
        attrs = node_.attributes
        self.buildAttributes(attrs)
        for child_ in node_.childNodes:
            nodeName_ = child_.nodeName.split(':')[-1]
            self.buildChildren(child_, nodeName_)
    def buildAttributes(self, attrs):
        pass
    def buildChildren(self, child_, nodeName_):
        if child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'type':
            type_ = ''
            for text__content_ in child_.childNodes:
                type_ += text__content_.nodeValue
            self.ttype = type_
        elif child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'content_type':
            content_type_ = ''
            for text__content_ in child_.childNodes:
                content_type_ += text__content_.nodeValue
            self.content_type = content_type_
        elif child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'level':
            level_ = ''
            for text__content_ in child_.childNodes:
                level_ += text__content_.nodeValue
            self.level = level_
        elif child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'message':
            message_ = ''
            for text__content_ in child_.childNodes:
                message_ += text__content_.nodeValue
            self.message = message_
# end class dna_message


class input_reflections(object):
    subclass = None
    def __init__(self, hklin=None):
        if hklin is None:
            self.hklin = []
        else:
            self.hklin = hklin
    def factory(*args_, **kwargs_):
        if input_reflections.subclass:
            return input_reflections.subclass(*args_, **kwargs_)
        else:
            return input_reflections(*args_, **kwargs_)
    factory = staticmethod(factory)
    def getHklin(self): return self.hklin
    def setHklin(self, hklin): self.hklin = hklin
    def addHklin(self, value): self.hklin.append(value)
    def insertHklin(self, index, value): self.hklin[index] = value
    def export(self, outfile, level = 0, name_='input_reflections'):
        showIndent(outfile, level)
        outfile.write('<%s>\n' % name_)
        self.exportChildren(outfile, level + 1, name_)
        showIndent(outfile, level)
        outfile.write('</%s>\n' % name_)
    def exportAttributes(self, outfile, level, name_='input_reflections'):
        pass
    def exportChildren(self, outfile, level, name_='input_reflections'):
        for hklin_ in self.getHklin():
            showIndent(outfile, level)
            outfile.write('<hklin>%s</hklin>\n' % quote_xml(hklin_))

    #Only to export the entire XML tree to a file stream on disk
    def outputFile( self, _outfileName ):
        outfile = open( _outfileName, "w" )
        outfile.write("<?xml version=\"1.0\" ?>\n")
        self.export( outfile, 0, name_='input_reflections' )
        outfile.close()


    #Only to export the entire XML tree to a Html Page in a file stream on disk
    def outputPageHtml( self, _outfileName ):
        odtStrTitle = "    <span class=\"title\">input_reflections:</span> <br> <br> <br>\n" 
        outfile = open( _outfileName, "w" )
        outfile.write( TEMPLATE_PAGE_P1 % ( odtStrTitle ) )
        self.exportLiteralHtml( outfile, 0, name_='input_reflections' )
        outfile.write( TEMPLATE_PAGE_P2  )
        outfile.close()


    def outputFileHtml( self, _outfileName ):
        self.outputPageHtml( _outfileName )



    #Static method for parsing a string
    def parseString( _inString ):
        doc = minidom.parseString(_inString)
        rootNode = doc.documentElement
        rootObj = input_reflections.factory()
        rootObj.build(rootNode)
        return rootObj
    parseString = staticmethod( parseString ) 


    #Method for marshalling an object
    def marshal( self ):
        oStreamString = StringIO.StringIO()
        oStreamString.write('<?xml version="1.0" ?>\n')
        self.export( oStreamString, 0, name_="input_reflections" )
        oStringXML = oStreamString.getvalue()
        oStreamString.close()
        return oStringXML

    def exportLiteral(self, outfile, level = 0, name_='input_reflections'):
        level += 1
        self.exportLiteralAttributes(outfile, level, name_)
        self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('hklin=[\n')
        level += 1
        for hklin in self.hklin:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(hklin))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def exportLiteralHtml(self, outfile, level = 0, name_='input_reflections'):
        level += 1
        self.exportLiteralAttributesHtml(outfile, level, name_)
        self.exportLiteralChildrenHtml(outfile, level, name_)
    def exportLiteralAttributesHtml(self, outfile, level, name_):
        pass
    def exportLiteralChildrenHtml(self, outfile, level, name_):
        showIndentHtml(outfile, level)
        outfile.write('hklin<br>\n')
        level += 1
        for hklin in self.hklin:
            showIndentHtml(outfile, level)
            outfile.write('<a  href:"#">%s</a><br>\n' % quote_python(hklin))
        level -= 1
        showIndentHtml(outfile, level)
        outfile.write('<br>\n')
    def build(self, node_):
        attrs = node_.attributes
        self.buildAttributes(attrs)
        for child_ in node_.childNodes:
            nodeName_ = child_.nodeName.split(':')[-1]
            self.buildChildren(child_, nodeName_)
    def buildAttributes(self, attrs):
        pass
    def buildChildren(self, child_, nodeName_):
        if child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'hklin':
            hklin_ = ''
            for text__content_ in child_.childNodes:
                hklin_ += text__content_.nodeValue
            self.hklin.append(hklin_)
# end class input_reflections


class output_reflections(object):
    subclass = None
    def __init__(self, hklout=''):
        self.hklout = hklout
    def factory(*args_, **kwargs_):
        if output_reflections.subclass:
            return output_reflections.subclass(*args_, **kwargs_)
        else:
            return output_reflections(*args_, **kwargs_)
    factory = staticmethod(factory)
    def getHklout(self): return self.hklout
    def setHklout(self, hklout): self.hklout = hklout
    def export(self, outfile, level = 0, name_='output_reflections'):
        showIndent(outfile, level)
        outfile.write('<%s>\n' % name_)
        self.exportChildren(outfile, level + 1, name_)
        showIndent(outfile, level)
        outfile.write('</%s>\n' % name_)
    def exportAttributes(self, outfile, level, name_='output_reflections'):
        pass
    def exportChildren(self, outfile, level, name_='output_reflections'):
        showIndent(outfile, level)
        outfile.write('<hklout>%s</hklout>\n' % quote_xml(self.getHklout()))

    #Only to export the entire XML tree to a file stream on disk
    def outputFile( self, _outfileName ):
        outfile = open( _outfileName, "w" )
        outfile.write("<?xml version=\"1.0\" ?>\n")
        self.export( outfile, 0, name_='output_reflections' )
        outfile.close()


    #Only to export the entire XML tree to a Html Page in a file stream on disk
    def outputPageHtml( self, _outfileName ):
        odtStrTitle = "    <span class=\"title\">output_reflections:</span> <br> <br> <br>\n" 
        outfile = open( _outfileName, "w" )
        outfile.write( TEMPLATE_PAGE_P1 % ( odtStrTitle ) )
        self.exportLiteralHtml( outfile, 0, name_='output_reflections' )
        outfile.write( TEMPLATE_PAGE_P2  )
        outfile.close()


    def outputFileHtml( self, _outfileName ):
        self.outputPageHtml( _outfileName )



    #Static method for parsing a string
    def parseString( _inString ):
        doc = minidom.parseString(_inString)
        rootNode = doc.documentElement
        rootObj = output_reflections.factory()
        rootObj.build(rootNode)
        return rootObj
    parseString = staticmethod( parseString ) 


    #Method for marshalling an object
    def marshal( self ):
        oStreamString = StringIO.StringIO()
        oStreamString.write('<?xml version="1.0" ?>\n')
        self.export( oStreamString, 0, name_="output_reflections" )
        oStringXML = oStreamString.getvalue()
        oStreamString.close()
        return oStringXML

    def exportLiteral(self, outfile, level = 0, name_='output_reflections'):
        level += 1
        self.exportLiteralAttributes(outfile, level, name_)
        self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('hklout = %s,\n' % quote_python(self.getHklout()))
    def exportLiteralHtml(self, outfile, level = 0, name_='output_reflections'):
        level += 1
        self.exportLiteralAttributesHtml(outfile, level, name_)
        self.exportLiteralChildrenHtml(outfile, level, name_)
    def exportLiteralAttributesHtml(self, outfile, level, name_):
        pass
    def exportLiteralChildrenHtml(self, outfile, level, name_):
        showIndentHtml(outfile, level)
        outfile.write('hklout = <a  href:"#">%s</a><br>\n' % quote_python(self.getHklout()))
    def build(self, node_):
        attrs = node_.attributes
        self.buildAttributes(attrs)
        for child_ in node_.childNodes:
            nodeName_ = child_.nodeName.split(':')[-1]
            self.buildChildren(child_, nodeName_)
    def buildAttributes(self, attrs):
        pass
    def buildChildren(self, child_, nodeName_):
        if child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'hklout':
            hklout_ = ''
            for text__content_ in child_.childNodes:
                hklout_ += text__content_.nodeValue
            self.hklout = hklout_
# end class output_reflections


class resolution(object):
    subclass = None
    def __init__(self, lower=0.0, upper=0.0):
        self.lower = lower
        self.upper = upper
    def factory(*args_, **kwargs_):
        if resolution.subclass:
            return resolution.subclass(*args_, **kwargs_)
        else:
            return resolution(*args_, **kwargs_)
    factory = staticmethod(factory)
    def getLower(self): return self.lower
    def setLower(self, lower): self.lower = lower
    def getUpper(self): return self.upper
    def setUpper(self, upper): self.upper = upper
    def export(self, outfile, level = 0, name_='resolution'):
        showIndent(outfile, level)
        outfile.write('<%s>\n' % name_)
        self.exportChildren(outfile, level + 1, name_)
        showIndent(outfile, level)
        outfile.write('</%s>\n' % name_)
    def exportAttributes(self, outfile, level, name_='resolution'):
        pass
    def exportChildren(self, outfile, level, name_='resolution'):
        showIndent(outfile, level)
        outfile.write('<lower>%e</lower>\n' % self.getLower())
        showIndent(outfile, level)
        outfile.write('<upper>%e</upper>\n' % self.getUpper())

    #Only to export the entire XML tree to a file stream on disk
    def outputFile( self, _outfileName ):
        outfile = open( _outfileName, "w" )
        outfile.write("<?xml version=\"1.0\" ?>\n")
        self.export( outfile, 0, name_='resolution' )
        outfile.close()


    #Only to export the entire XML tree to a Html Page in a file stream on disk
    def outputPageHtml( self, _outfileName ):
        odtStrTitle = "    <span class=\"title\">resolution:</span> <br> <br> <br>\n" 
        outfile = open( _outfileName, "w" )
        outfile.write( TEMPLATE_PAGE_P1 % ( odtStrTitle ) )
        self.exportLiteralHtml( outfile, 0, name_='resolution' )
        outfile.write( TEMPLATE_PAGE_P2  )
        outfile.close()


    def outputFileHtml( self, _outfileName ):
        self.outputPageHtml( _outfileName )



    #Static method for parsing a string
    def parseString( _inString ):
        doc = minidom.parseString(_inString)
        rootNode = doc.documentElement
        rootObj = resolution.factory()
        rootObj.build(rootNode)
        return rootObj
    parseString = staticmethod( parseString ) 


    #Method for marshalling an object
    def marshal( self ):
        oStreamString = StringIO.StringIO()
        oStreamString.write('<?xml version="1.0" ?>\n')
        self.export( oStreamString, 0, name_="resolution" )
        oStringXML = oStreamString.getvalue()
        oStreamString.close()
        return oStringXML

    def exportLiteral(self, outfile, level = 0, name_='resolution'):
        level += 1
        self.exportLiteralAttributes(outfile, level, name_)
        self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('lower = %e,\n' % self.getLower())
        showIndent(outfile, level)
        outfile.write('upper = %e,\n' % self.getUpper())
    def exportLiteralHtml(self, outfile, level = 0, name_='resolution'):
        level += 1
        self.exportLiteralAttributesHtml(outfile, level, name_)
        self.exportLiteralChildrenHtml(outfile, level, name_)
    def exportLiteralAttributesHtml(self, outfile, level, name_):
        pass
    def exportLiteralChildrenHtml(self, outfile, level, name_):
        showIndentHtml(outfile, level)
        outfile.write('lower = <a  href:"#">%e</a><br>\n' % self.getLower())
        showIndentHtml(outfile, level)
        outfile.write('upper = <a  href:"#">%e</a><br>\n' % self.getUpper())
    def build(self, node_):
        attrs = node_.attributes
        self.buildAttributes(attrs)
        for child_ in node_.childNodes:
            nodeName_ = child_.nodeName.split(':')[-1]
            self.buildChildren(child_, nodeName_)
    def buildAttributes(self, attrs):
        pass
    def buildChildren(self, child_, nodeName_):
        if child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'lower':
            if child_.firstChild:
                sval_ = child_.firstChild.nodeValue
                try:
                    fval_ = float(sval_)
                except ValueError:
                    raise ValueError('requires float (or double) -- %s' % child_.toxml())
                self.lower = fval_
        elif child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'upper':
            if child_.firstChild:
                sval_ = child_.firstChild.nodeValue
                try:
                    fval_ = float(sval_)
                except ValueError:
                    raise ValueError('requires float (or double) -- %s' % child_.toxml())
                self.upper = fval_
# end class resolution


class abort_request(object):
    subclass = None
    def __init__(self, level=''):
        self.level = level
    def factory(*args_, **kwargs_):
        if abort_request.subclass:
            return abort_request.subclass(*args_, **kwargs_)
        else:
            return abort_request(*args_, **kwargs_)
    factory = staticmethod(factory)
    def getLevel(self): return self.level
    def setLevel(self, level): self.level = level
    def export(self, outfile, level = 0, name_='abort_request'):
        showIndent(outfile, level)
        outfile.write('<%s>\n' % name_)
        self.exportChildren(outfile, level + 1, name_)
        showIndent(outfile, level)
        outfile.write('</%s>\n' % name_)
    def exportAttributes(self, outfile, level, name_='abort_request'):
        pass
    def exportChildren(self, outfile, level, name_='abort_request'):
        showIndent(outfile, level)
        outfile.write('<level>%s</level>\n' % quote_xml(self.getLevel()))

    #Only to export the entire XML tree to a file stream on disk
    def outputFile( self, _outfileName ):
        outfile = open( _outfileName, "w" )
        outfile.write("<?xml version=\"1.0\" ?>\n")
        self.export( outfile, 0, name_='abort_request' )
        outfile.close()


    #Only to export the entire XML tree to a Html Page in a file stream on disk
    def outputPageHtml( self, _outfileName ):
        odtStrTitle = "    <span class=\"title\">abort_request:</span> <br> <br> <br>\n" 
        outfile = open( _outfileName, "w" )
        outfile.write( TEMPLATE_PAGE_P1 % ( odtStrTitle ) )
        self.exportLiteralHtml( outfile, 0, name_='abort_request' )
        outfile.write( TEMPLATE_PAGE_P2  )
        outfile.close()


    def outputFileHtml( self, _outfileName ):
        self.outputPageHtml( _outfileName )



    #Static method for parsing a string
    def parseString( _inString ):
        doc = minidom.parseString(_inString)
        rootNode = doc.documentElement
        rootObj = abort_request.factory()
        rootObj.build(rootNode)
        return rootObj
    parseString = staticmethod( parseString ) 


    #Method for marshalling an object
    def marshal( self ):
        oStreamString = StringIO.StringIO()
        oStreamString.write('<?xml version="1.0" ?>\n')
        self.export( oStreamString, 0, name_="abort_request" )
        oStringXML = oStreamString.getvalue()
        oStreamString.close()
        return oStringXML

    def exportLiteral(self, outfile, level = 0, name_='abort_request'):
        level += 1
        self.exportLiteralAttributes(outfile, level, name_)
        self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('level = %s,\n' % quote_python(self.getLevel()))
    def exportLiteralHtml(self, outfile, level = 0, name_='abort_request'):
        level += 1
        self.exportLiteralAttributesHtml(outfile, level, name_)
        self.exportLiteralChildrenHtml(outfile, level, name_)
    def exportLiteralAttributesHtml(self, outfile, level, name_):
        pass
    def exportLiteralChildrenHtml(self, outfile, level, name_):
        showIndentHtml(outfile, level)
        outfile.write('level = <a  href:"#">%s</a><br>\n' % quote_python(self.getLevel()))
    def build(self, node_):
        attrs = node_.attributes
        self.buildAttributes(attrs)
        for child_ in node_.childNodes:
            nodeName_ = child_.nodeName.split(':')[-1]
            self.buildChildren(child_, nodeName_)
    def buildAttributes(self, attrs):
        pass
    def buildChildren(self, child_, nodeName_):
        if child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'level':
            level_ = ''
            for text__content_ in child_.childNodes:
                level_ += text__content_.nodeValue
            self.level = level_
# end class abort_request


class abort_response(object):
    subclass = None
    def __init__(self, status=None):
        self.status = status
    def factory(*args_, **kwargs_):
        if abort_response.subclass:
            return abort_response.subclass(*args_, **kwargs_)
        else:
            return abort_response(*args_, **kwargs_)
    factory = staticmethod(factory)
    def getStatus(self): return self.status
    def setStatus(self, status): self.status = status
    def export(self, outfile, level = 0, name_='abort_response'):
        showIndent(outfile, level)
        outfile.write('<%s>\n' % name_)
        self.exportChildren(outfile, level + 1, name_)
        showIndent(outfile, level)
        outfile.write('</%s>\n' % name_)
    def exportAttributes(self, outfile, level, name_='abort_response'):
        pass
    def exportChildren(self, outfile, level, name_='abort_response'):
        if self.status:
            self.status.export(outfile, level)

    #Only to export the entire XML tree to a file stream on disk
    def outputFile( self, _outfileName ):
        outfile = open( _outfileName, "w" )
        outfile.write("<?xml version=\"1.0\" ?>\n")
        self.export( outfile, 0, name_='abort_response' )
        outfile.close()


    #Only to export the entire XML tree to a Html Page in a file stream on disk
    def outputPageHtml( self, _outfileName ):
        odtStrTitle = "    <span class=\"title\">abort_response:</span> <br> <br> <br>\n" 
        outfile = open( _outfileName, "w" )
        outfile.write( TEMPLATE_PAGE_P1 % ( odtStrTitle ) )
        self.exportLiteralHtml( outfile, 0, name_='abort_response' )
        outfile.write( TEMPLATE_PAGE_P2  )
        outfile.close()


    def outputFileHtml( self, _outfileName ):
        self.outputPageHtml( _outfileName )



    #Static method for parsing a string
    def parseString( _inString ):
        doc = minidom.parseString(_inString)
        rootNode = doc.documentElement
        rootObj = abort_response.factory()
        rootObj.build(rootNode)
        return rootObj
    parseString = staticmethod( parseString ) 


    #Method for marshalling an object
    def marshal( self ):
        oStreamString = StringIO.StringIO()
        oStreamString.write('<?xml version="1.0" ?>\n')
        self.export( oStreamString, 0, name_="abort_response" )
        oStringXML = oStreamString.getvalue()
        oStreamString.close()
        return oStringXML

    def exportLiteral(self, outfile, level = 0, name_='abort_response'):
        level += 1
        self.exportLiteralAttributes(outfile, level, name_)
        self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.status:
            showIndent(outfile, level)
            outfile.write('status = status(\n')
            self.status.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
    def exportLiteralHtml(self, outfile, level = 0, name_='abort_response'):
        level += 1
        self.exportLiteralAttributesHtml(outfile, level, name_)
        self.exportLiteralChildrenHtml(outfile, level, name_)
    def exportLiteralAttributesHtml(self, outfile, level, name_):
        pass
    def exportLiteralChildrenHtml(self, outfile, level, name_):
        if self.status:
            showIndentHtml(outfile, level)
            outfile.write('status<br>\n')
            self.status.exportLiteralHtml(outfile, level)
            showIndentHtml(outfile, level)
            outfile.write('<br>\n')
    def build(self, node_):
        attrs = node_.attributes
        self.buildAttributes(attrs)
        for child_ in node_.childNodes:
            nodeName_ = child_.nodeName.split(':')[-1]
            self.buildChildren(child_, nodeName_)
    def buildAttributes(self, attrs):
        pass
    def buildChildren(self, child_, nodeName_):
        if child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'status':
            obj_ = status.factory()
            obj_.build(child_)
            self.setStatus(obj_)
# end class abort_response


class sample_reference(object):
    subclass = None
    def __init__(self, code='', container_reference='', container_code='', sample_location='', blSampleId=''):
        self.code = code
        self.container_reference = container_reference
        self.container_code = container_code
        self.sample_location = sample_location
        self.blSampleId = blSampleId
    def factory(*args_, **kwargs_):
        if sample_reference.subclass:
            return sample_reference.subclass(*args_, **kwargs_)
        else:
            return sample_reference(*args_, **kwargs_)
    factory = staticmethod(factory)
    def getCode(self): return self.code
    def setCode(self, code): self.code = code
    def getContainer_reference(self): return self.container_reference
    def setContainer_reference(self, container_reference): self.container_reference = container_reference
    def getContainer_code(self): return self.container_code
    def setContainer_code(self, container_code): self.container_code = container_code
    def getSample_location(self): return self.sample_location
    def setSample_location(self, sample_location): self.sample_location = sample_location
    def getBlSampleId(self): return self.blSampleId
    def setBlSampleId(self, blSampleId): self.blSampleId = blSampleId
    def export(self, outfile, level = 0, name_='sample_reference'):
        showIndent(outfile, level)
        outfile.write('<%s>\n' % name_)
        self.exportChildren(outfile, level + 1, name_)
        showIndent(outfile, level)
        outfile.write('</%s>\n' % name_)
    def exportAttributes(self, outfile, level, name_='sample_reference'):
        pass
    def exportChildren(self, outfile, level, name_='sample_reference'):
        showIndent(outfile, level)
        outfile.write('<code>%s</code>\n' % quote_xml(self.getCode()))
        showIndent(outfile, level)
        outfile.write('<container_reference>%s</container_reference>\n' % quote_xml(self.getContainer_reference()))
        showIndent(outfile, level)
        outfile.write('<container_code>%s</container_code>\n' % quote_xml(self.getContainer_code()))
        showIndent(outfile, level)
        outfile.write('<sample_location>%s</sample_location>\n' % quote_xml(self.getSample_location()))
        showIndent(outfile, level)
        outfile.write('<blSampleId>%s</blSampleId>\n' % quote_xml(self.getBlSampleId()))

    #Only to export the entire XML tree to a file stream on disk
    def outputFile( self, _outfileName ):
        outfile = open( _outfileName, "w" )
        outfile.write("<?xml version=\"1.0\" ?>\n")
        self.export( outfile, 0, name_='sample_reference' )
        outfile.close()


    #Only to export the entire XML tree to a Html Page in a file stream on disk
    def outputPageHtml( self, _outfileName ):
        odtStrTitle = "    <span class=\"title\">sample_reference:</span> <br> <br> <br>\n" 
        outfile = open( _outfileName, "w" )
        outfile.write( TEMPLATE_PAGE_P1 % ( odtStrTitle ) )
        self.exportLiteralHtml( outfile, 0, name_='sample_reference' )
        outfile.write( TEMPLATE_PAGE_P2  )
        outfile.close()


    def outputFileHtml( self, _outfileName ):
        self.outputPageHtml( _outfileName )



    #Static method for parsing a string
    def parseString( _inString ):
        doc = minidom.parseString(_inString)
        rootNode = doc.documentElement
        rootObj = sample_reference.factory()
        rootObj.build(rootNode)
        return rootObj
    parseString = staticmethod( parseString ) 


    #Method for marshalling an object
    def marshal( self ):
        oStreamString = StringIO.StringIO()
        oStreamString.write('<?xml version="1.0" ?>\n')
        self.export( oStreamString, 0, name_="sample_reference" )
        oStringXML = oStreamString.getvalue()
        oStreamString.close()
        return oStringXML

    def exportLiteral(self, outfile, level = 0, name_='sample_reference'):
        level += 1
        self.exportLiteralAttributes(outfile, level, name_)
        self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('code = %s,\n' % quote_python(self.getCode()))
        showIndent(outfile, level)
        outfile.write('container_reference = %s,\n' % quote_python(self.getContainer_reference()))
        showIndent(outfile, level)
        outfile.write('container_code = %s,\n' % quote_python(self.getContainer_code()))
        showIndent(outfile, level)
        outfile.write('sample_location = %s,\n' % quote_python(self.getSample_location()))
        showIndent(outfile, level)
        outfile.write('blSampleId = %s,\n' % quote_python(self.getBlSampleId()))
    def exportLiteralHtml(self, outfile, level = 0, name_='sample_reference'):
        level += 1
        self.exportLiteralAttributesHtml(outfile, level, name_)
        self.exportLiteralChildrenHtml(outfile, level, name_)
    def exportLiteralAttributesHtml(self, outfile, level, name_):
        pass
    def exportLiteralChildrenHtml(self, outfile, level, name_):
        showIndentHtml(outfile, level)
        outfile.write('code = <a  href:"#">%s</a><br>\n' % quote_python(self.getCode()))
        showIndentHtml(outfile, level)
        outfile.write('container_reference = <a  href:"#">%s</a><br>\n' % quote_python(self.getContainer_reference()))
        showIndentHtml(outfile, level)
        outfile.write('container_code = <a  href:"#">%s</a><br>\n' % quote_python(self.getContainer_code()))
        showIndentHtml(outfile, level)
        outfile.write('sample_location = <a  href:"#">%s</a><br>\n' % quote_python(self.getSample_location()))
        showIndentHtml(outfile, level)
        outfile.write('blSampleId = <a  href:"#">%s</a><br>\n' % quote_python(self.getBlSampleId()))
    def build(self, node_):
        attrs = node_.attributes
        self.buildAttributes(attrs)
        for child_ in node_.childNodes:
            nodeName_ = child_.nodeName.split(':')[-1]
            self.buildChildren(child_, nodeName_)
    def buildAttributes(self, attrs):
        pass
    def buildChildren(self, child_, nodeName_):
        if child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'code':
            code_ = ''
            for text__content_ in child_.childNodes:
                code_ += text__content_.nodeValue
            self.code = code_
        elif child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'container_reference':
            container_reference_ = ''
            for text__content_ in child_.childNodes:
                container_reference_ += text__content_.nodeValue
            self.container_reference = container_reference_
        elif child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'container_code':
            container_code_ = ''
            for text__content_ in child_.childNodes:
                container_code_ += text__content_.nodeValue
            self.container_code = container_code_
        elif child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'sample_location':
            sample_location_ = ''
            for text__content_ in child_.childNodes:
                sample_location_ += text__content_.nodeValue
            self.sample_location = sample_location_
        elif child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'blSampleId':
            blSampleId_ = ''
            for text__content_ in child_.childNodes:
                blSampleId_ += text__content_.nodeValue
            self.blSampleId = blSampleId_
# end class sample_reference


class beamline_parameters(object):
    subclass = None
    def __init__(self, maximum_exposure=0.0, minimum_exposure_time=0.0, minimum_phi_speed=0.0, maximum_phi_speed=0.0, minimum_phi_oscillation=0.0):
        self.maximum_exposure = maximum_exposure
        self.minimum_exposure_time = minimum_exposure_time
        self.minimum_phi_speed = minimum_phi_speed
        self.maximum_phi_speed = maximum_phi_speed
        self.minimum_phi_oscillation = minimum_phi_oscillation
    def factory(*args_, **kwargs_):
        if beamline_parameters.subclass:
            return beamline_parameters.subclass(*args_, **kwargs_)
        else:
            return beamline_parameters(*args_, **kwargs_)
    factory = staticmethod(factory)
    def getMaximum_exposure(self): return self.maximum_exposure
    def setMaximum_exposure(self, maximum_exposure): self.maximum_exposure = maximum_exposure
    def getMinimum_exposure_time(self): return self.minimum_exposure_time
    def setMinimum_exposure_time(self, minimum_exposure_time): self.minimum_exposure_time = minimum_exposure_time
    def getMinimum_phi_speed(self): return self.minimum_phi_speed
    def setMinimum_phi_speed(self, minimum_phi_speed): self.minimum_phi_speed = minimum_phi_speed
    def getMaximum_phi_speed(self): return self.maximum_phi_speed
    def setMaximum_phi_speed(self, maximum_phi_speed): self.maximum_phi_speed = maximum_phi_speed
    def getMinimum_phi_oscillation(self): return self.minimum_phi_oscillation
    def setMinimum_phi_oscillation(self, minimum_phi_oscillation): self.minimum_phi_oscillation = minimum_phi_oscillation
    def export(self, outfile, level = 0, name_='beamline_parameters'):
        showIndent(outfile, level)
        outfile.write('<%s>\n' % name_)
        self.exportChildren(outfile, level + 1, name_)
        showIndent(outfile, level)
        outfile.write('</%s>\n' % name_)
    def exportAttributes(self, outfile, level, name_='beamline_parameters'):
        pass
    def exportChildren(self, outfile, level, name_='beamline_parameters'):
        showIndent(outfile, level)
        outfile.write('<maximum_exposure>%e</maximum_exposure>\n' % self.getMaximum_exposure())
        showIndent(outfile, level)
        outfile.write('<minimum_exposure_time>%e</minimum_exposure_time>\n' % self.getMinimum_exposure_time())
        showIndent(outfile, level)
        outfile.write('<minimum_phi_speed>%e</minimum_phi_speed>\n' % self.getMinimum_phi_speed())
        showIndent(outfile, level)
        outfile.write('<maximum_phi_speed>%e</maximum_phi_speed>\n' % self.getMaximum_phi_speed())
        showIndent(outfile, level)
        outfile.write('<minimum_phi_oscillation>%e</minimum_phi_oscillation>\n' % self.getMinimum_phi_oscillation())

    #Only to export the entire XML tree to a file stream on disk
    def outputFile( self, _outfileName ):
        outfile = open( _outfileName, "w" )
        outfile.write("<?xml version=\"1.0\" ?>\n")
        self.export( outfile, 0, name_='beamline_parameters' )
        outfile.close()


    #Only to export the entire XML tree to a Html Page in a file stream on disk
    def outputPageHtml( self, _outfileName ):
        odtStrTitle = "    <span class=\"title\">beamline_parameters:</span> <br> <br> <br>\n" 
        outfile = open( _outfileName, "w" )
        outfile.write( TEMPLATE_PAGE_P1 % ( odtStrTitle ) )
        self.exportLiteralHtml( outfile, 0, name_='beamline_parameters' )
        outfile.write( TEMPLATE_PAGE_P2  )
        outfile.close()


    def outputFileHtml( self, _outfileName ):
        self.outputPageHtml( _outfileName )



    #Static method for parsing a string
    def parseString( _inString ):
        doc = minidom.parseString(_inString)
        rootNode = doc.documentElement
        rootObj = beamline_parameters.factory()
        rootObj.build(rootNode)
        return rootObj
    parseString = staticmethod( parseString ) 


    #Method for marshalling an object
    def marshal( self ):
        oStreamString = StringIO.StringIO()
        oStreamString.write('<?xml version="1.0" ?>\n')
        self.export( oStreamString, 0, name_="beamline_parameters" )
        oStringXML = oStreamString.getvalue()
        oStreamString.close()
        return oStringXML

    def exportLiteral(self, outfile, level = 0, name_='beamline_parameters'):
        level += 1
        self.exportLiteralAttributes(outfile, level, name_)
        self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('maximum_exposure = %e,\n' % self.getMaximum_exposure())
        showIndent(outfile, level)
        outfile.write('minimum_exposure_time = %e,\n' % self.getMinimum_exposure_time())
        showIndent(outfile, level)
        outfile.write('minimum_phi_speed = %e,\n' % self.getMinimum_phi_speed())
        showIndent(outfile, level)
        outfile.write('maximum_phi_speed = %e,\n' % self.getMaximum_phi_speed())
        showIndent(outfile, level)
        outfile.write('minimum_phi_oscillation = %e,\n' % self.getMinimum_phi_oscillation())
    def exportLiteralHtml(self, outfile, level = 0, name_='beamline_parameters'):
        level += 1
        self.exportLiteralAttributesHtml(outfile, level, name_)
        self.exportLiteralChildrenHtml(outfile, level, name_)
    def exportLiteralAttributesHtml(self, outfile, level, name_):
        pass
    def exportLiteralChildrenHtml(self, outfile, level, name_):
        showIndentHtml(outfile, level)
        outfile.write('maximum_exposure = <a  href:"#">%e</a><br>\n' % self.getMaximum_exposure())
        showIndentHtml(outfile, level)
        outfile.write('minimum_exposure_time = <a  href:"#">%e</a><br>\n' % self.getMinimum_exposure_time())
        showIndentHtml(outfile, level)
        outfile.write('minimum_phi_speed = <a  href:"#">%e</a><br>\n' % self.getMinimum_phi_speed())
        showIndentHtml(outfile, level)
        outfile.write('maximum_phi_speed = <a  href:"#">%e</a><br>\n' % self.getMaximum_phi_speed())
        showIndentHtml(outfile, level)
        outfile.write('minimum_phi_oscillation = <a  href:"#">%e</a><br>\n' % self.getMinimum_phi_oscillation())
    def build(self, node_):
        attrs = node_.attributes
        self.buildAttributes(attrs)
        for child_ in node_.childNodes:
            nodeName_ = child_.nodeName.split(':')[-1]
            self.buildChildren(child_, nodeName_)
    def buildAttributes(self, attrs):
        pass
    def buildChildren(self, child_, nodeName_):
        if child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'maximum_exposure':
            if child_.firstChild:
                sval_ = child_.firstChild.nodeValue
                try:
                    fval_ = float(sval_)
                except ValueError:
                    raise ValueError('requires float (or double) -- %s' % child_.toxml())
                self.maximum_exposure = fval_
        elif child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'minimum_exposure_time':
            if child_.firstChild:
                sval_ = child_.firstChild.nodeValue
                try:
                    fval_ = float(sval_)
                except ValueError:
                    raise ValueError('requires float (or double) -- %s' % child_.toxml())
                self.minimum_exposure_time = fval_
        elif child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'minimum_phi_speed':
            if child_.firstChild:
                sval_ = child_.firstChild.nodeValue
                try:
                    fval_ = float(sval_)
                except ValueError:
                    raise ValueError('requires float (or double) -- %s' % child_.toxml())
                self.minimum_phi_speed = fval_
        elif child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'maximum_phi_speed':
            if child_.firstChild:
                sval_ = child_.firstChild.nodeValue
                try:
                    fval_ = float(sval_)
                except ValueError:
                    raise ValueError('requires float (or double) -- %s' % child_.toxml())
                self.maximum_phi_speed = fval_
        elif child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'minimum_phi_oscillation':
            if child_.firstChild:
                sval_ = child_.firstChild.nodeValue
                try:
                    fval_ = float(sval_)
                except ValueError:
                    raise ValueError('requires float (or double) -- %s' % child_.toxml())
                self.minimum_phi_oscillation = fval_
# end class beamline_parameters




def parse(inFileName):
    doc = minidom.parse(inFileName)
    rootNode = doc.documentElement
    rootObj = integrate_request.factory()
    rootObj.build(rootNode)
    # Enable Python to collect the space used by the DOM.
    doc.unlink()
#    doc = None
    return rootObj


def parseString(inString):
    doc = minidom.parseString(inString)
    rootNode = doc.documentElement
    rootObj = integrate_request.factory()
    rootObj.build(rootNode)
    # Enable Python to collect the space used by the DOM.
    doc.unlink()
#    doc = None
#    sys.stdout.write('<?xml version="1.0" ?>\n')
#    rootObj.export(sys.stdout, 0, name_="integrate_request")
    return rootObj


# AAlib Modifications for marshalling and unmarshalling
# Creating program data constructs from XML
def unMarshalling( _inFileName ):
    return parse(  _inFileName )


# Serializing program data constructs to XML
def marshalling( _oObject, _inFileName ):
    oFile = open( _inFileName, "w" )
    oFile.write('<?xml version="1.0" ?>\n')
    _oObject.export( oFile, 0, name_="integrate_request" )
    oFile.close()

