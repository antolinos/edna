#!/usr/bin/env python



#################################################################
#
#   Project:   Python-Jython Asynchronous Action Library Project
#              http://pyaalib.sourceforge.net/
#              http://jyaalib.sourceforge.net/
#
#   Author(s): Romeu A. Pieritz - romeu.pieritz@gmail.com
#
#   Code Generated in Date:      Mon Jun  1 23:18:42 2009
#
#   License:
#   ----------------------------------------------
#   Python-Jython Asynchronous Action Library Project
#   Copyright (c) 2005-2008, PyAALib-JyAALib developers
#   All rights reserved.
#
#   Redistribution and use in source and binary forms,
#   with or without modification, are permitted
#   provided that the following conditions are met:
#
#   Redistributions of source code must retain the
#   above copyright notice,this list of conditions
#   and the following disclaimer.
#
#   Redistributions in binary form must reproduce
#   the above copyright notice,this list of conditions
#   and the following disclaimer in the documentation
#   and/or other materials provided with the distribution.
#
#   Neither the names of PyAALib-JyAALib's copyright owner
#   nor the names of its contributors may be used to endorse
#   or promote products derived from this software without
#   specific prior written permission.
#
#   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS
#   AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED
#   WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
#   IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
#   FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO
#   EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS
#   BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
#   SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
#   (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
#   SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA,
#   OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
#   CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER
#   IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
#   NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT
#   OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
#   THE POSSIBILITY OF SUCH DAMAGE.
#
################################################################
#
#
# Generated by ALExternalPackGenerateDS.py.
#
# This file is generated by a modified version of the original file:
# generateDS.py, proposed by Dave Kuhlman:
#
## LICENSE
#
## Copyright (c) 2003 Dave Kuhlman
#
## Permission is hereby granted, free of charge, to any person obtaining
## a copy of this software and associated documentation files (the
## "Software"), to deal in the Software without restriction, including
## without limitation the rights to use, copy, modify, merge, publish,
## distribute, sublicense, and/or sell copies of the Software, and to
## permit persons to whom the Software is furnished to do so, subject to
## the following conditions:
#
## The above copyright notice and this permission notice shall be
## included in all copies or substantial portions of the Software.
#
## THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
## EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
## MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
## IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
## CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
## TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
## SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
#
##############################################################################

import sys
import getopt
from xml.dom import minidom
from xml.dom import Node


#
# Support/utility functions.
#

def showIndent(outfile, level):
    for idx in range(level):
        outfile.write('    ')


def showIndentHtml(outfile, level):
    for idx in range(level):
        outfile.write(' &nbsp; &nbsp; &nbsp; &nbsp;')


def quote_xml(inStr):
    s1 = inStr
    s1 = s1.replace('&', '&amp;')
    s1 = s1.replace('<', '&lt;')
    s1 = s1.replace('"', '&quot;')
    return s1

def quote_python(inStr):
    s1 = inStr
    if s1.find("'") == -1:
        if s1.find('\n') == -1:
            return "'%s'" % s1
        else:
            return "'''%s'''" % s1
    else:
        if s1.find('"') != -1:
            s1 = s1.replace('"', '\\"')
        if s1.find('\n') == -1:
            return '"%s"' % s1
        else:
            return '"""%s"""' % s1


class MixedContainer(object):
    # Constants for category:
    CategoryNone = 0
    CategoryText = 1
    CategorySimple = 2
    CategoryComplex = 3
    # Constants for content_type:
    TypeNone = 0
    TypeText = 1
    TypeString = 2
    TypeInteger = 3
    TypeFloat = 4
    TypeDecimal = 5
    TypeDouble = 6
    TypeBoolean = 7
    def __init__(self, category, content_type, name, value):
        self.category = category
        self.content_type = content_type
        self.name = name
        self.value = value
    def getCategory(self):
        return self.category
    def getContenttype(self, content_type):
        return self.content_type
    def getValue(self):
        return self.value
    def getName(self):
        return self.name
    def export(self, outfile, level, name):
        if self.category == MixedContainer.CategoryText:
            outfile.write(self.value)
        elif self.category == MixedContainer.CategorySimple:
            self.exportSimple(outfile, level, name)
        else:    # category == MixedContainer.CategoryComplex
            self.value.export(outfile, level, name)
    def exportSimple(self, outfile, level, name):
        if self.content_type == MixedContainer.TypeString:
            outfile.write('<%s>%s</%s>' % (self.name, self.value, self.name))
        elif self.content_type == MixedContainer.TypeInteger or \
                self.content_type == MixedContainer.TypeBoolean:
            outfile.write('<%s>%d</%s>' % (self.name, self.value, self.name))
        elif self.content_type == MixedContainer.TypeFloat or \
                self.content_type == MixedContainer.TypeDecimal:
            outfile.write('<%s>%f</%s>' % (self.name, self.value, self.name))
        elif self.content_type == MixedContainer.TypeDouble:
            outfile.write('<%s>%g</%s>' % (self.name, self.value, self.name))
    def exportLiteral(self, outfile, level, name):
        if self.category == MixedContainer.CategoryText:
            showIndent(outfile, level)
            outfile.write('MixedContainer(%d, %d, "%s", "%s"),\n' % \
                (self.category, self.content_type, self.name, self.value))
        elif self.category == MixedContainer.CategorySimple:
            showIndent(outfile, level)
            outfile.write('MixedContainer(%d, %d, "%s", "%s"),\n' % \
                (self.category, self.content_type, self.name, self.value))
        else:    # category == MixedContainer.CategoryComplex
            showIndent(outfile, level)
            outfile.write('MixedContainer(%d, %d, "%s",\n' % \
                (self.category, self.content_type, self.name,))
            self.value.exportLiteral(outfile, level + 1)
            showIndent(outfile, level)
            outfile.write(')\n')



TEMPLATE_PAGE_P1 = """
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN" "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en">
<head>
    <title>AALib Plugin Data Description</title>
    <meta http-equiv="content-type" content="text/html; charset=utf-8">
    <meta name="description" content="AALib Plugin generation from XSD files">
    <meta name="keywords" content="AALib, xsd, plugin">
    <meta name="author" content="Romeu Pieritz(romeu_pieritz@yahoo.fr)">
    <link href="style.css" rel="stylesheet" type="text/css">
    <base target="main">
</head>
<body>
    <div id="main">
        <div id="block">
          %s
    </div>
"""

TEMPLATE_PAGE_P2 = """
    </div>
</body>
</html>
"""



#
# Class definition
#

class scale_reflections_request(object):
    subclass = None
    def __init__(self, input_reflections=None, output_reflections=None, scaling_options=None):
        self.input_reflections = input_reflections
        self.output_reflections = output_reflections
        self.scaling_options = scaling_options
    def factory(*args_, **kwargs_):
        if scale_reflections_request.subclass:
            return scale_reflections_request.subclass(*args_, **kwargs_)
        else:
            return scale_reflections_request(*args_, **kwargs_)
    factory = staticmethod(factory)
    def getInput_reflections(self): return self.input_reflections
    def setInput_reflections(self, input_reflections): self.input_reflections = input_reflections
    def getOutput_reflections(self): return self.output_reflections
    def setOutput_reflections(self, output_reflections): self.output_reflections = output_reflections
    def getScaling_options(self): return self.scaling_options
    def setScaling_options(self, scaling_options): self.scaling_options = scaling_options
    def export(self, outfile, level = 0, name_='scale_reflections_request'):
        showIndent(outfile, level)
        outfile.write('<%s>\n' % name_)
        self.exportChildren(outfile, level + 1, name_)
        showIndent(outfile, level)
        outfile.write('</%s>\n' % name_)
    def exportAttributes(self, outfile, level, name_='scale_reflections_request'):
        pass
    def exportChildren(self, outfile, level, name_='scale_reflections_request'):
        if self.input_reflections:
            self.input_reflections.export(outfile, level)
        if self.output_reflections:
            self.output_reflections.export(outfile, level)
        if self.scaling_options:
            self.scaling_options.export(outfile, level)

    #Only to export the entire XML tree to a file stream on disk
    def outputFile( self, _outfileName ):
        outfile = open( _outfileName, "w" )
        outfile.write("<?xml version=\"1.0\" ?>\n")
        self.export( outfile, 0, name_='scale_reflections_request' )
        outfile.close()


    #Only to export the entire XML tree to a Html Page in a file stream on disk
    def outputPageHtml( self, _outfileName ):
        odtStrTitle = "    <span class=\"title\">scale_reflections_request:</span> <br> <br> <br>\n" 
        outfile = open( _outfileName, "w" )
        outfile.write( TEMPLATE_PAGE_P1 % ( odtStrTitle ) )
        self.exportLiteralHtml( outfile, 0, name_='scale_reflections_request' )
        outfile.write( TEMPLATE_PAGE_P2  )
        outfile.close()


    def outputFileHtml( self, _outfileName ):
        self.outputPageHtml( _outfileName )



    #Static method for parsing a string
    def parseString( _inString ):
        doc = minidom.parseString(_inString)
        rootNode = doc.documentElement
        rootObj = scale_reflections_request.factory()
        rootObj.build(rootNode)
        return rootObj
    parseString = staticmethod( parseString ) 


    #Method for marshalling an object
    def marshal( self ):
        oStreamString = StringIO.StringIO()
        oStreamString.write('<?xml version="1.0" ?>\n')
        self.export( oStreamString, 0, name_="scale_reflections_request" )
        oStringXML = oStreamString.getvalue()
        oStreamString.close()
        return oStringXML

    def exportLiteral(self, outfile, level = 0, name_='scale_reflections_request'):
        level += 1
        self.exportLiteralAttributes(outfile, level, name_)
        self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.input_reflections:
            showIndent(outfile, level)
            outfile.write('input_reflections = input_reflections(\n')
            self.input_reflections.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.output_reflections:
            showIndent(outfile, level)
            outfile.write('output_reflections = output_reflections(\n')
            self.output_reflections.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.scaling_options:
            showIndent(outfile, level)
            outfile.write('scaling_options = scaling_options(\n')
            self.scaling_options.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
    def exportLiteralHtml(self, outfile, level = 0, name_='scale_reflections_request'):
        level += 1
        self.exportLiteralAttributesHtml(outfile, level, name_)
        self.exportLiteralChildrenHtml(outfile, level, name_)
    def exportLiteralAttributesHtml(self, outfile, level, name_):
        pass
    def exportLiteralChildrenHtml(self, outfile, level, name_):
        if self.input_reflections:
            showIndentHtml(outfile, level)
            outfile.write('input_reflections<br>\n')
            self.input_reflections.exportLiteralHtml(outfile, level)
            showIndentHtml(outfile, level)
            outfile.write('<br>\n')
        if self.output_reflections:
            showIndentHtml(outfile, level)
            outfile.write('output_reflections<br>\n')
            self.output_reflections.exportLiteralHtml(outfile, level)
            showIndentHtml(outfile, level)
            outfile.write('<br>\n')
        if self.scaling_options:
            showIndentHtml(outfile, level)
            outfile.write('scaling_options<br>\n')
            self.scaling_options.exportLiteralHtml(outfile, level)
            showIndentHtml(outfile, level)
            outfile.write('<br>\n')
    def build(self, node_):
        attrs = node_.attributes
        self.buildAttributes(attrs)
        for child_ in node_.childNodes:
            nodeName_ = child_.nodeName.split(':')[-1]
            self.buildChildren(child_, nodeName_)
    def buildAttributes(self, attrs):
        pass
    def buildChildren(self, child_, nodeName_):
        if child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'input_reflections':
            obj_ = input_reflections.factory()
            obj_.build(child_)
            self.setInput_reflections(obj_)
        elif child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'output_reflections':
            obj_ = output_reflections.factory()
            obj_.build(child_)
            self.setOutput_reflections(obj_)
        elif child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'scaling_options':
            obj_ = scaling_options.factory()
            obj_.build(child_)
            self.setScaling_options(obj_)
# end class scale_reflections_request


class scaling_options(object):
    subclass = None
    def __init__(self, cycle_limit=-1, spacing=0.0, secondary=0.0, bfactor_refinement='', anomalous_scattering='', resolution=None, standard_deviation_parameters=None, unmerged_polish_output='', start=-1, end=-1):
        self.cycle_limit = cycle_limit
        self.spacing = spacing
        self.secondary = secondary
        self.bfactor_refinement = bfactor_refinement
        self.anomalous_scattering = anomalous_scattering
        self.resolution = resolution
        self.standard_deviation_parameters = standard_deviation_parameters
        self.unmerged_polish_output = unmerged_polish_output
        self.start = start
        self.end = end
    def factory(*args_, **kwargs_):
        if scaling_options.subclass:
            return scaling_options.subclass(*args_, **kwargs_)
        else:
            return scaling_options(*args_, **kwargs_)
    factory = staticmethod(factory)
    def getCycle_limit(self): return self.cycle_limit
    def setCycle_limit(self, cycle_limit): self.cycle_limit = cycle_limit
    def getSpacing(self): return self.spacing
    def setSpacing(self, spacing): self.spacing = spacing
    def getSecondary(self): return self.secondary
    def setSecondary(self, secondary): self.secondary = secondary
    def getBfactor_refinement(self): return self.bfactor_refinement
    def setBfactor_refinement(self, bfactor_refinement): self.bfactor_refinement = bfactor_refinement
    def getAnomalous_scattering(self): return self.anomalous_scattering
    def setAnomalous_scattering(self, anomalous_scattering): self.anomalous_scattering = anomalous_scattering
    def getResolution(self): return self.resolution
    def setResolution(self, resolution): self.resolution = resolution
    def getStandard_deviation_parameters(self): return self.standard_deviation_parameters
    def setStandard_deviation_parameters(self, standard_deviation_parameters): self.standard_deviation_parameters = standard_deviation_parameters
    def getUnmerged_polish_output(self): return self.unmerged_polish_output
    def setUnmerged_polish_output(self, unmerged_polish_output): self.unmerged_polish_output = unmerged_polish_output
    def getStart(self): return self.start
    def setStart(self, start): self.start = start
    def getEnd(self): return self.end
    def setEnd(self, end): self.end = end
    def export(self, outfile, level = 0, name_='scaling_options'):
        showIndent(outfile, level)
        outfile.write('<%s>\n' % name_)
        self.exportChildren(outfile, level + 1, name_)
        showIndent(outfile, level)
        outfile.write('</%s>\n' % name_)
    def exportAttributes(self, outfile, level, name_='scaling_options'):
        pass
    def exportChildren(self, outfile, level, name_='scaling_options'):
        showIndent(outfile, level)
        outfile.write('<cycle_limit>%d</cycle_limit>\n' % self.getCycle_limit())
        showIndent(outfile, level)
        outfile.write('<spacing>%e</spacing>\n' % self.getSpacing())
        showIndent(outfile, level)
        outfile.write('<secondary>%e</secondary>\n' % self.getSecondary())
        showIndent(outfile, level)
        outfile.write('<bfactor_refinement>%s</bfactor_refinement>\n' % quote_xml(self.getBfactor_refinement()))
        showIndent(outfile, level)
        outfile.write('<anomalous_scattering>%s</anomalous_scattering>\n' % quote_xml(self.getAnomalous_scattering()))
        if self.resolution:
            self.resolution.export(outfile, level)
        if self.standard_deviation_parameters:
            self.standard_deviation_parameters.export(outfile, level)
        showIndent(outfile, level)
        outfile.write('<unmerged_polish_output>%s</unmerged_polish_output>\n' % quote_xml(self.getUnmerged_polish_output()))
        showIndent(outfile, level)
        outfile.write('<start>%d</start>\n' % self.getStart())
        showIndent(outfile, level)
        outfile.write('<end>%d</end>\n' % self.getEnd())

    #Only to export the entire XML tree to a file stream on disk
    def outputFile( self, _outfileName ):
        outfile = open( _outfileName, "w" )
        outfile.write("<?xml version=\"1.0\" ?>\n")
        self.export( outfile, 0, name_='scaling_options' )
        outfile.close()


    #Only to export the entire XML tree to a Html Page in a file stream on disk
    def outputPageHtml( self, _outfileName ):
        odtStrTitle = "    <span class=\"title\">scaling_options:</span> <br> <br> <br>\n" 
        outfile = open( _outfileName, "w" )
        outfile.write( TEMPLATE_PAGE_P1 % ( odtStrTitle ) )
        self.exportLiteralHtml( outfile, 0, name_='scaling_options' )
        outfile.write( TEMPLATE_PAGE_P2  )
        outfile.close()


    def outputFileHtml( self, _outfileName ):
        self.outputPageHtml( _outfileName )



    #Static method for parsing a string
    def parseString( _inString ):
        doc = minidom.parseString(_inString)
        rootNode = doc.documentElement
        rootObj = scaling_options.factory()
        rootObj.build(rootNode)
        return rootObj
    parseString = staticmethod( parseString ) 


    #Method for marshalling an object
    def marshal( self ):
        oStreamString = StringIO.StringIO()
        oStreamString.write('<?xml version="1.0" ?>\n')
        self.export( oStreamString, 0, name_="scaling_options" )
        oStringXML = oStreamString.getvalue()
        oStreamString.close()
        return oStringXML

    def exportLiteral(self, outfile, level = 0, name_='scaling_options'):
        level += 1
        self.exportLiteralAttributes(outfile, level, name_)
        self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('cycle_limit = %d,\n' % self.getCycle_limit())
        showIndent(outfile, level)
        outfile.write('spacing = %e,\n' % self.getSpacing())
        showIndent(outfile, level)
        outfile.write('secondary = %e,\n' % self.getSecondary())
        showIndent(outfile, level)
        outfile.write('bfactor_refinement = %s,\n' % quote_python(self.getBfactor_refinement()))
        showIndent(outfile, level)
        outfile.write('anomalous_scattering = %s,\n' % quote_python(self.getAnomalous_scattering()))
        if self.resolution:
            showIndent(outfile, level)
            outfile.write('resolution = resolution(\n')
            self.resolution.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.standard_deviation_parameters:
            showIndent(outfile, level)
            outfile.write('standard_deviation_parameters = standard_deviation_parameters(\n')
            self.standard_deviation_parameters.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        showIndent(outfile, level)
        outfile.write('unmerged_polish_output = %s,\n' % quote_python(self.getUnmerged_polish_output()))
        showIndent(outfile, level)
        outfile.write('start = %d,\n' % self.getStart())
        showIndent(outfile, level)
        outfile.write('end = %d,\n' % self.getEnd())
    def exportLiteralHtml(self, outfile, level = 0, name_='scaling_options'):
        level += 1
        self.exportLiteralAttributesHtml(outfile, level, name_)
        self.exportLiteralChildrenHtml(outfile, level, name_)
    def exportLiteralAttributesHtml(self, outfile, level, name_):
        pass
    def exportLiteralChildrenHtml(self, outfile, level, name_):
        showIndentHtml(outfile, level)
        outfile.write('cycle_limit = <a  href:"#">%d</a><br>\n' % self.getCycle_limit())
        showIndentHtml(outfile, level)
        outfile.write('spacing = <a  href:"#">%e</a><br>\n' % self.getSpacing())
        showIndentHtml(outfile, level)
        outfile.write('secondary = <a  href:"#">%e</a><br>\n' % self.getSecondary())
        showIndentHtml(outfile, level)
        outfile.write('bfactor_refinement = <a  href:"#">%s</a><br>\n' % quote_python(self.getBfactor_refinement()))
        showIndentHtml(outfile, level)
        outfile.write('anomalous_scattering = <a  href:"#">%s</a><br>\n' % quote_python(self.getAnomalous_scattering()))
        if self.resolution:
            showIndentHtml(outfile, level)
            outfile.write('resolution<br>\n')
            self.resolution.exportLiteralHtml(outfile, level)
            showIndentHtml(outfile, level)
            outfile.write('<br>\n')
        if self.standard_deviation_parameters:
            showIndentHtml(outfile, level)
            outfile.write('standard_deviation_parameters<br>\n')
            self.standard_deviation_parameters.exportLiteralHtml(outfile, level)
            showIndentHtml(outfile, level)
            outfile.write('<br>\n')
        showIndentHtml(outfile, level)
        outfile.write('unmerged_polish_output = <a  href:"#">%s</a><br>\n' % quote_python(self.getUnmerged_polish_output()))
        showIndentHtml(outfile, level)
        outfile.write('start = <a  href:"#">%d</a><br>\n' % self.getStart())
        showIndentHtml(outfile, level)
        outfile.write('end = <a  href:"#">%d</a><br>\n' % self.getEnd())
    def build(self, node_):
        attrs = node_.attributes
        self.buildAttributes(attrs)
        for child_ in node_.childNodes:
            nodeName_ = child_.nodeName.split(':')[-1]
            self.buildChildren(child_, nodeName_)
    def buildAttributes(self, attrs):
        pass
    def buildChildren(self, child_, nodeName_):
        if child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'cycle_limit':
            if child_.firstChild:
                sval_ = child_.firstChild.nodeValue
                try:
                    ival_ = int(sval_)
                except ValueError:
                    raise ValueError('requires integer -- %s' % child_.toxml())
                self.cycle_limit = ival_
        elif child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'spacing':
            if child_.firstChild:
                sval_ = child_.firstChild.nodeValue
                try:
                    fval_ = float(sval_)
                except ValueError:
                    raise ValueError('requires float (or double) -- %s' % child_.toxml())
                self.spacing = fval_
        elif child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'secondary':
            if child_.firstChild:
                sval_ = child_.firstChild.nodeValue
                try:
                    fval_ = float(sval_)
                except ValueError:
                    raise ValueError('requires float (or double) -- %s' % child_.toxml())
                self.secondary = fval_
        elif child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'bfactor_refinement':
            bfactor_refinement_ = ''
            for text__content_ in child_.childNodes:
                bfactor_refinement_ += text__content_.nodeValue
            self.bfactor_refinement = bfactor_refinement_
        elif child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'anomalous_scattering':
            anomalous_scattering_ = ''
            for text__content_ in child_.childNodes:
                anomalous_scattering_ += text__content_.nodeValue
            self.anomalous_scattering = anomalous_scattering_
        elif child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'resolution':
            obj_ = resolution.factory()
            obj_.build(child_)
            self.setResolution(obj_)
        elif child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'standard_deviation_parameters':
            obj_ = standard_deviation_parameters.factory()
            obj_.build(child_)
            self.setStandard_deviation_parameters(obj_)
        elif child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'unmerged_polish_output':
            unmerged_polish_output_ = ''
            for text__content_ in child_.childNodes:
                unmerged_polish_output_ += text__content_.nodeValue
            self.unmerged_polish_output = unmerged_polish_output_
        elif child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'start':
            if child_.firstChild:
                sval_ = child_.firstChild.nodeValue
                try:
                    ival_ = int(sval_)
                except ValueError:
                    raise ValueError('requires integer -- %s' % child_.toxml())
                self.start = ival_
        elif child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'end':
            if child_.firstChild:
                sval_ = child_.firstChild.nodeValue
                try:
                    ival_ = int(sval_)
                except ValueError:
                    raise ValueError('requires integer -- %s' % child_.toxml())
                self.end = ival_
# end class scaling_options


class scale_factor(object):
    subclass = None
    def __init__(self, batch=-1, mean_k=0.0):
        self.batch = batch
        self.mean_k = mean_k
    def factory(*args_, **kwargs_):
        if scale_factor.subclass:
            return scale_factor.subclass(*args_, **kwargs_)
        else:
            return scale_factor(*args_, **kwargs_)
    factory = staticmethod(factory)
    def getBatch(self): return self.batch
    def setBatch(self, batch): self.batch = batch
    def getMean_k(self): return self.mean_k
    def setMean_k(self, mean_k): self.mean_k = mean_k
    def export(self, outfile, level = 0, name_='scale_factor'):
        showIndent(outfile, level)
        outfile.write('<%s>\n' % name_)
        self.exportChildren(outfile, level + 1, name_)
        showIndent(outfile, level)
        outfile.write('</%s>\n' % name_)
    def exportAttributes(self, outfile, level, name_='scale_factor'):
        pass
    def exportChildren(self, outfile, level, name_='scale_factor'):
        showIndent(outfile, level)
        outfile.write('<batch>%d</batch>\n' % self.getBatch())
        showIndent(outfile, level)
        outfile.write('<mean_k>%e</mean_k>\n' % self.getMean_k())

    #Only to export the entire XML tree to a file stream on disk
    def outputFile( self, _outfileName ):
        outfile = open( _outfileName, "w" )
        outfile.write("<?xml version=\"1.0\" ?>\n")
        self.export( outfile, 0, name_='scale_factor' )
        outfile.close()


    #Only to export the entire XML tree to a Html Page in a file stream on disk
    def outputPageHtml( self, _outfileName ):
        odtStrTitle = "    <span class=\"title\">scale_factor:</span> <br> <br> <br>\n" 
        outfile = open( _outfileName, "w" )
        outfile.write( TEMPLATE_PAGE_P1 % ( odtStrTitle ) )
        self.exportLiteralHtml( outfile, 0, name_='scale_factor' )
        outfile.write( TEMPLATE_PAGE_P2  )
        outfile.close()


    def outputFileHtml( self, _outfileName ):
        self.outputPageHtml( _outfileName )



    #Static method for parsing a string
    def parseString( _inString ):
        doc = minidom.parseString(_inString)
        rootNode = doc.documentElement
        rootObj = scale_factor.factory()
        rootObj.build(rootNode)
        return rootObj
    parseString = staticmethod( parseString ) 


    #Method for marshalling an object
    def marshal( self ):
        oStreamString = StringIO.StringIO()
        oStreamString.write('<?xml version="1.0" ?>\n')
        self.export( oStreamString, 0, name_="scale_factor" )
        oStringXML = oStreamString.getvalue()
        oStreamString.close()
        return oStringXML

    def exportLiteral(self, outfile, level = 0, name_='scale_factor'):
        level += 1
        self.exportLiteralAttributes(outfile, level, name_)
        self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('batch = %d,\n' % self.getBatch())
        showIndent(outfile, level)
        outfile.write('mean_k = %e,\n' % self.getMean_k())
    def exportLiteralHtml(self, outfile, level = 0, name_='scale_factor'):
        level += 1
        self.exportLiteralAttributesHtml(outfile, level, name_)
        self.exportLiteralChildrenHtml(outfile, level, name_)
    def exportLiteralAttributesHtml(self, outfile, level, name_):
        pass
    def exportLiteralChildrenHtml(self, outfile, level, name_):
        showIndentHtml(outfile, level)
        outfile.write('batch = <a  href:"#">%d</a><br>\n' % self.getBatch())
        showIndentHtml(outfile, level)
        outfile.write('mean_k = <a  href:"#">%e</a><br>\n' % self.getMean_k())
    def build(self, node_):
        attrs = node_.attributes
        self.buildAttributes(attrs)
        for child_ in node_.childNodes:
            nodeName_ = child_.nodeName.split(':')[-1]
            self.buildChildren(child_, nodeName_)
    def buildAttributes(self, attrs):
        pass
    def buildChildren(self, child_, nodeName_):
        if child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'batch':
            if child_.firstChild:
                sval_ = child_.firstChild.nodeValue
                try:
                    ival_ = int(sval_)
                except ValueError:
                    raise ValueError('requires integer -- %s' % child_.toxml())
                self.batch = ival_
        elif child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'mean_k':
            if child_.firstChild:
                sval_ = child_.firstChild.nodeValue
                try:
                    fval_ = float(sval_)
                except ValueError:
                    raise ValueError('requires float (or double) -- %s' % child_.toxml())
                self.mean_k = fval_
# end class scale_factor


class scale_factor_list(object):
    subclass = None
    def __init__(self, scale_factor=None):
        if scale_factor is None:
            self.scale_factor = []
        else:
            self.scale_factor = scale_factor
    def factory(*args_, **kwargs_):
        if scale_factor_list.subclass:
            return scale_factor_list.subclass(*args_, **kwargs_)
        else:
            return scale_factor_list(*args_, **kwargs_)
    factory = staticmethod(factory)
    def getScale_factor(self): return self.scale_factor
    def setScale_factor(self, scale_factor): self.scale_factor = scale_factor
    def addScale_factor(self, value): self.scale_factor.append(value)
    def insertScale_factor(self, index, value): self.scale_factor[index] = value
    def export(self, outfile, level = 0, name_='scale_factor_list'):
        showIndent(outfile, level)
        outfile.write('<%s>\n' % name_)
        self.exportChildren(outfile, level + 1, name_)
        showIndent(outfile, level)
        outfile.write('</%s>\n' % name_)
    def exportAttributes(self, outfile, level, name_='scale_factor_list'):
        pass
    def exportChildren(self, outfile, level, name_='scale_factor_list'):
        for scale_factor_ in self.getScale_factor():
            scale_factor_.export(outfile, level)

    #Only to export the entire XML tree to a file stream on disk
    def outputFile( self, _outfileName ):
        outfile = open( _outfileName, "w" )
        outfile.write("<?xml version=\"1.0\" ?>\n")
        self.export( outfile, 0, name_='scale_factor_list' )
        outfile.close()


    #Only to export the entire XML tree to a Html Page in a file stream on disk
    def outputPageHtml( self, _outfileName ):
        odtStrTitle = "    <span class=\"title\">scale_factor_list:</span> <br> <br> <br>\n" 
        outfile = open( _outfileName, "w" )
        outfile.write( TEMPLATE_PAGE_P1 % ( odtStrTitle ) )
        self.exportLiteralHtml( outfile, 0, name_='scale_factor_list' )
        outfile.write( TEMPLATE_PAGE_P2  )
        outfile.close()


    def outputFileHtml( self, _outfileName ):
        self.outputPageHtml( _outfileName )



    #Static method for parsing a string
    def parseString( _inString ):
        doc = minidom.parseString(_inString)
        rootNode = doc.documentElement
        rootObj = scale_factor_list.factory()
        rootObj.build(rootNode)
        return rootObj
    parseString = staticmethod( parseString ) 


    #Method for marshalling an object
    def marshal( self ):
        oStreamString = StringIO.StringIO()
        oStreamString.write('<?xml version="1.0" ?>\n')
        self.export( oStreamString, 0, name_="scale_factor_list" )
        oStringXML = oStreamString.getvalue()
        oStreamString.close()
        return oStringXML

    def exportLiteral(self, outfile, level = 0, name_='scale_factor_list'):
        level += 1
        self.exportLiteralAttributes(outfile, level, name_)
        self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('scale_factor=[\n')
        level += 1
        for scale_factor in self.scale_factor:
            showIndent(outfile, level)
            outfile.write('scale_factor(\n')
            scale_factor.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def exportLiteralHtml(self, outfile, level = 0, name_='scale_factor_list'):
        level += 1
        self.exportLiteralAttributesHtml(outfile, level, name_)
        self.exportLiteralChildrenHtml(outfile, level, name_)
    def exportLiteralAttributesHtml(self, outfile, level, name_):
        pass
    def exportLiteralChildrenHtml(self, outfile, level, name_):
        showIndentHtml(outfile, level)
        outfile.write('scale_factor<br>\n')
        level += 1
        for scale_factor in self.scale_factor:
            scale_factor.exportLiteralHtml(outfile, level)
            showIndentHtml(outfile, level)
            outfile.write('<br>\n')
        level -= 1
        showIndentHtml(outfile, level)
        outfile.write('<br>\n')
    def build(self, node_):
        attrs = node_.attributes
        self.buildAttributes(attrs)
        for child_ in node_.childNodes:
            nodeName_ = child_.nodeName.split(':')[-1]
            self.buildChildren(child_, nodeName_)
    def buildAttributes(self, attrs):
        pass
    def buildChildren(self, child_, nodeName_):
        if child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'scale_factor':
            obj_ = scale_factor.factory()
            obj_.build(child_)
            self.scale_factor.append(obj_)
# end class scale_factor_list


class scale_reflections_response(object):
    subclass = None
    def __init__(self, status=None, rmerge=0.0, scale_factor_list=None, standard_deviation_parameters=None, per_batch_results=None):
        self.status = status
        self.rmerge = rmerge
        self.scale_factor_list = scale_factor_list
        self.standard_deviation_parameters = standard_deviation_parameters
        self.per_batch_results = per_batch_results
    def factory(*args_, **kwargs_):
        if scale_reflections_response.subclass:
            return scale_reflections_response.subclass(*args_, **kwargs_)
        else:
            return scale_reflections_response(*args_, **kwargs_)
    factory = staticmethod(factory)
    def getStatus(self): return self.status
    def setStatus(self, status): self.status = status
    def getRmerge(self): return self.rmerge
    def setRmerge(self, rmerge): self.rmerge = rmerge
    def getScale_factor_list(self): return self.scale_factor_list
    def setScale_factor_list(self, scale_factor_list): self.scale_factor_list = scale_factor_list
    def getStandard_deviation_parameters(self): return self.standard_deviation_parameters
    def setStandard_deviation_parameters(self, standard_deviation_parameters): self.standard_deviation_parameters = standard_deviation_parameters
    def getPer_batch_results(self): return self.per_batch_results
    def setPer_batch_results(self, per_batch_results): self.per_batch_results = per_batch_results
    def export(self, outfile, level = 0, name_='scale_reflections_response'):
        showIndent(outfile, level)
        outfile.write('<%s>\n' % name_)
        self.exportChildren(outfile, level + 1, name_)
        showIndent(outfile, level)
        outfile.write('</%s>\n' % name_)
    def exportAttributes(self, outfile, level, name_='scale_reflections_response'):
        pass
    def exportChildren(self, outfile, level, name_='scale_reflections_response'):
        if self.status:
            self.status.export(outfile, level)
        showIndent(outfile, level)
        outfile.write('<rmerge>%e</rmerge>\n' % self.getRmerge())
        if self.scale_factor_list:
            self.scale_factor_list.export(outfile, level)
        if self.standard_deviation_parameters:
            self.standard_deviation_parameters.export(outfile, level)
        if self.per_batch_results:
            self.per_batch_results.export(outfile, level)

    #Only to export the entire XML tree to a file stream on disk
    def outputFile( self, _outfileName ):
        outfile = open( _outfileName, "w" )
        outfile.write("<?xml version=\"1.0\" ?>\n")
        self.export( outfile, 0, name_='scale_reflections_response' )
        outfile.close()


    #Only to export the entire XML tree to a Html Page in a file stream on disk
    def outputPageHtml( self, _outfileName ):
        odtStrTitle = "    <span class=\"title\">scale_reflections_response:</span> <br> <br> <br>\n" 
        outfile = open( _outfileName, "w" )
        outfile.write( TEMPLATE_PAGE_P1 % ( odtStrTitle ) )
        self.exportLiteralHtml( outfile, 0, name_='scale_reflections_response' )
        outfile.write( TEMPLATE_PAGE_P2  )
        outfile.close()


    def outputFileHtml( self, _outfileName ):
        self.outputPageHtml( _outfileName )



    #Static method for parsing a string
    def parseString( _inString ):
        doc = minidom.parseString(_inString)
        rootNode = doc.documentElement
        rootObj = scale_reflections_response.factory()
        rootObj.build(rootNode)
        return rootObj
    parseString = staticmethod( parseString ) 


    #Method for marshalling an object
    def marshal( self ):
        oStreamString = StringIO.StringIO()
        oStreamString.write('<?xml version="1.0" ?>\n')
        self.export( oStreamString, 0, name_="scale_reflections_response" )
        oStringXML = oStreamString.getvalue()
        oStreamString.close()
        return oStringXML

    def exportLiteral(self, outfile, level = 0, name_='scale_reflections_response'):
        level += 1
        self.exportLiteralAttributes(outfile, level, name_)
        self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.status:
            showIndent(outfile, level)
            outfile.write('status = status(\n')
            self.status.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        showIndent(outfile, level)
        outfile.write('rmerge = %e,\n' % self.getRmerge())
        if self.scale_factor_list:
            showIndent(outfile, level)
            outfile.write('scale_factor_list = scale_factor_list(\n')
            self.scale_factor_list.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.standard_deviation_parameters:
            showIndent(outfile, level)
            outfile.write('standard_deviation_parameters = standard_deviation_parameters(\n')
            self.standard_deviation_parameters.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.per_batch_results:
            showIndent(outfile, level)
            outfile.write('per_batch_results = per_batch_results(\n')
            self.per_batch_results.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
    def exportLiteralHtml(self, outfile, level = 0, name_='scale_reflections_response'):
        level += 1
        self.exportLiteralAttributesHtml(outfile, level, name_)
        self.exportLiteralChildrenHtml(outfile, level, name_)
    def exportLiteralAttributesHtml(self, outfile, level, name_):
        pass
    def exportLiteralChildrenHtml(self, outfile, level, name_):
        if self.status:
            showIndentHtml(outfile, level)
            outfile.write('status<br>\n')
            self.status.exportLiteralHtml(outfile, level)
            showIndentHtml(outfile, level)
            outfile.write('<br>\n')
        showIndentHtml(outfile, level)
        outfile.write('rmerge = <a  href:"#">%e</a><br>\n' % self.getRmerge())
        if self.scale_factor_list:
            showIndentHtml(outfile, level)
            outfile.write('scale_factor_list<br>\n')
            self.scale_factor_list.exportLiteralHtml(outfile, level)
            showIndentHtml(outfile, level)
            outfile.write('<br>\n')
        if self.standard_deviation_parameters:
            showIndentHtml(outfile, level)
            outfile.write('standard_deviation_parameters<br>\n')
            self.standard_deviation_parameters.exportLiteralHtml(outfile, level)
            showIndentHtml(outfile, level)
            outfile.write('<br>\n')
        if self.per_batch_results:
            showIndentHtml(outfile, level)
            outfile.write('per_batch_results<br>\n')
            self.per_batch_results.exportLiteralHtml(outfile, level)
            showIndentHtml(outfile, level)
            outfile.write('<br>\n')
    def build(self, node_):
        attrs = node_.attributes
        self.buildAttributes(attrs)
        for child_ in node_.childNodes:
            nodeName_ = child_.nodeName.split(':')[-1]
            self.buildChildren(child_, nodeName_)
    def buildAttributes(self, attrs):
        pass
    def buildChildren(self, child_, nodeName_):
        if child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'status':
            obj_ = status.factory()
            obj_.build(child_)
            self.setStatus(obj_)
        elif child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'rmerge':
            if child_.firstChild:
                sval_ = child_.firstChild.nodeValue
                try:
                    fval_ = float(sval_)
                except ValueError:
                    raise ValueError('requires float (or double) -- %s' % child_.toxml())
                self.rmerge = fval_
        elif child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'scale_factor_list':
            obj_ = scale_factor_list.factory()
            obj_.build(child_)
            self.setScale_factor_list(obj_)
        elif child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'standard_deviation_parameters':
            obj_ = standard_deviation_parameters.factory()
            obj_.build(child_)
            self.setStandard_deviation_parameters(obj_)
        elif child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'per_batch_results':
            obj_ = per_batch_results.factory()
            obj_.build(child_)
            self.setPer_batch_results(obj_)
# end class scale_reflections_response


class per_batch_results(object):
    subclass = None
    def __init__(self, batch_results=None):
        if batch_results is None:
            self.batch_results = []
        else:
            self.batch_results = batch_results
    def factory(*args_, **kwargs_):
        if per_batch_results.subclass:
            return per_batch_results.subclass(*args_, **kwargs_)
        else:
            return per_batch_results(*args_, **kwargs_)
    factory = staticmethod(factory)
    def getBatch_results(self): return self.batch_results
    def setBatch_results(self, batch_results): self.batch_results = batch_results
    def addBatch_results(self, value): self.batch_results.append(value)
    def insertBatch_results(self, index, value): self.batch_results[index] = value
    def export(self, outfile, level = 0, name_='per_batch_results'):
        showIndent(outfile, level)
        outfile.write('<%s>\n' % name_)
        self.exportChildren(outfile, level + 1, name_)
        showIndent(outfile, level)
        outfile.write('</%s>\n' % name_)
    def exportAttributes(self, outfile, level, name_='per_batch_results'):
        pass
    def exportChildren(self, outfile, level, name_='per_batch_results'):
        for batch_results_ in self.getBatch_results():
            batch_results_.export(outfile, level)

    #Only to export the entire XML tree to a file stream on disk
    def outputFile( self, _outfileName ):
        outfile = open( _outfileName, "w" )
        outfile.write("<?xml version=\"1.0\" ?>\n")
        self.export( outfile, 0, name_='per_batch_results' )
        outfile.close()


    #Only to export the entire XML tree to a Html Page in a file stream on disk
    def outputPageHtml( self, _outfileName ):
        odtStrTitle = "    <span class=\"title\">per_batch_results:</span> <br> <br> <br>\n" 
        outfile = open( _outfileName, "w" )
        outfile.write( TEMPLATE_PAGE_P1 % ( odtStrTitle ) )
        self.exportLiteralHtml( outfile, 0, name_='per_batch_results' )
        outfile.write( TEMPLATE_PAGE_P2  )
        outfile.close()


    def outputFileHtml( self, _outfileName ):
        self.outputPageHtml( _outfileName )



    #Static method for parsing a string
    def parseString( _inString ):
        doc = minidom.parseString(_inString)
        rootNode = doc.documentElement
        rootObj = per_batch_results.factory()
        rootObj.build(rootNode)
        return rootObj
    parseString = staticmethod( parseString ) 


    #Method for marshalling an object
    def marshal( self ):
        oStreamString = StringIO.StringIO()
        oStreamString.write('<?xml version="1.0" ?>\n')
        self.export( oStreamString, 0, name_="per_batch_results" )
        oStringXML = oStreamString.getvalue()
        oStreamString.close()
        return oStringXML

    def exportLiteral(self, outfile, level = 0, name_='per_batch_results'):
        level += 1
        self.exportLiteralAttributes(outfile, level, name_)
        self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('batch_results=[\n')
        level += 1
        for batch_results in self.batch_results:
            showIndent(outfile, level)
            outfile.write('batch_results(\n')
            batch_results.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def exportLiteralHtml(self, outfile, level = 0, name_='per_batch_results'):
        level += 1
        self.exportLiteralAttributesHtml(outfile, level, name_)
        self.exportLiteralChildrenHtml(outfile, level, name_)
    def exportLiteralAttributesHtml(self, outfile, level, name_):
        pass
    def exportLiteralChildrenHtml(self, outfile, level, name_):
        showIndentHtml(outfile, level)
        outfile.write('batch_results<br>\n')
        level += 1
        for batch_results in self.batch_results:
            batch_results.exportLiteralHtml(outfile, level)
            showIndentHtml(outfile, level)
            outfile.write('<br>\n')
        level -= 1
        showIndentHtml(outfile, level)
        outfile.write('<br>\n')
    def build(self, node_):
        attrs = node_.attributes
        self.buildAttributes(attrs)
        for child_ in node_.childNodes:
            nodeName_ = child_.nodeName.split(':')[-1]
            self.buildChildren(child_, nodeName_)
    def buildAttributes(self, attrs):
        pass
    def buildChildren(self, child_, nodeName_):
        if child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'batch_results':
            obj_ = batch_results.factory()
            obj_.build(child_)
            self.batch_results.append(obj_)
# end class per_batch_results


class batch_results(object):
    subclass = None
    def __init__(self, batch=-1, bfactor=0.0, number_rejected=-1, rmerge=0.0):
        self.batch = batch
        self.bfactor = bfactor
        self.number_rejected = number_rejected
        self.rmerge = rmerge
    def factory(*args_, **kwargs_):
        if batch_results.subclass:
            return batch_results.subclass(*args_, **kwargs_)
        else:
            return batch_results(*args_, **kwargs_)
    factory = staticmethod(factory)
    def getBatch(self): return self.batch
    def setBatch(self, batch): self.batch = batch
    def getBfactor(self): return self.bfactor
    def setBfactor(self, bfactor): self.bfactor = bfactor
    def getNumber_rejected(self): return self.number_rejected
    def setNumber_rejected(self, number_rejected): self.number_rejected = number_rejected
    def getRmerge(self): return self.rmerge
    def setRmerge(self, rmerge): self.rmerge = rmerge
    def export(self, outfile, level = 0, name_='batch_results'):
        showIndent(outfile, level)
        outfile.write('<%s>\n' % name_)
        self.exportChildren(outfile, level + 1, name_)
        showIndent(outfile, level)
        outfile.write('</%s>\n' % name_)
    def exportAttributes(self, outfile, level, name_='batch_results'):
        pass
    def exportChildren(self, outfile, level, name_='batch_results'):
        showIndent(outfile, level)
        outfile.write('<batch>%d</batch>\n' % self.getBatch())
        showIndent(outfile, level)
        outfile.write('<bfactor>%e</bfactor>\n' % self.getBfactor())
        showIndent(outfile, level)
        outfile.write('<number_rejected>%d</number_rejected>\n' % self.getNumber_rejected())
        showIndent(outfile, level)
        outfile.write('<rmerge>%e</rmerge>\n' % self.getRmerge())

    #Only to export the entire XML tree to a file stream on disk
    def outputFile( self, _outfileName ):
        outfile = open( _outfileName, "w" )
        outfile.write("<?xml version=\"1.0\" ?>\n")
        self.export( outfile, 0, name_='batch_results' )
        outfile.close()


    #Only to export the entire XML tree to a Html Page in a file stream on disk
    def outputPageHtml( self, _outfileName ):
        odtStrTitle = "    <span class=\"title\">batch_results:</span> <br> <br> <br>\n" 
        outfile = open( _outfileName, "w" )
        outfile.write( TEMPLATE_PAGE_P1 % ( odtStrTitle ) )
        self.exportLiteralHtml( outfile, 0, name_='batch_results' )
        outfile.write( TEMPLATE_PAGE_P2  )
        outfile.close()


    def outputFileHtml( self, _outfileName ):
        self.outputPageHtml( _outfileName )



    #Static method for parsing a string
    def parseString( _inString ):
        doc = minidom.parseString(_inString)
        rootNode = doc.documentElement
        rootObj = batch_results.factory()
        rootObj.build(rootNode)
        return rootObj
    parseString = staticmethod( parseString ) 


    #Method for marshalling an object
    def marshal( self ):
        oStreamString = StringIO.StringIO()
        oStreamString.write('<?xml version="1.0" ?>\n')
        self.export( oStreamString, 0, name_="batch_results" )
        oStringXML = oStreamString.getvalue()
        oStreamString.close()
        return oStringXML

    def exportLiteral(self, outfile, level = 0, name_='batch_results'):
        level += 1
        self.exportLiteralAttributes(outfile, level, name_)
        self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('batch = %d,\n' % self.getBatch())
        showIndent(outfile, level)
        outfile.write('bfactor = %e,\n' % self.getBfactor())
        showIndent(outfile, level)
        outfile.write('number_rejected = %d,\n' % self.getNumber_rejected())
        showIndent(outfile, level)
        outfile.write('rmerge = %e,\n' % self.getRmerge())
    def exportLiteralHtml(self, outfile, level = 0, name_='batch_results'):
        level += 1
        self.exportLiteralAttributesHtml(outfile, level, name_)
        self.exportLiteralChildrenHtml(outfile, level, name_)
    def exportLiteralAttributesHtml(self, outfile, level, name_):
        pass
    def exportLiteralChildrenHtml(self, outfile, level, name_):
        showIndentHtml(outfile, level)
        outfile.write('batch = <a  href:"#">%d</a><br>\n' % self.getBatch())
        showIndentHtml(outfile, level)
        outfile.write('bfactor = <a  href:"#">%e</a><br>\n' % self.getBfactor())
        showIndentHtml(outfile, level)
        outfile.write('number_rejected = <a  href:"#">%d</a><br>\n' % self.getNumber_rejected())
        showIndentHtml(outfile, level)
        outfile.write('rmerge = <a  href:"#">%e</a><br>\n' % self.getRmerge())
    def build(self, node_):
        attrs = node_.attributes
        self.buildAttributes(attrs)
        for child_ in node_.childNodes:
            nodeName_ = child_.nodeName.split(':')[-1]
            self.buildChildren(child_, nodeName_)
    def buildAttributes(self, attrs):
        pass
    def buildChildren(self, child_, nodeName_):
        if child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'batch':
            if child_.firstChild:
                sval_ = child_.firstChild.nodeValue
                try:
                    ival_ = int(sval_)
                except ValueError:
                    raise ValueError('requires integer -- %s' % child_.toxml())
                self.batch = ival_
        elif child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'bfactor':
            if child_.firstChild:
                sval_ = child_.firstChild.nodeValue
                try:
                    fval_ = float(sval_)
                except ValueError:
                    raise ValueError('requires float (or double) -- %s' % child_.toxml())
                self.bfactor = fval_
        elif child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'number_rejected':
            if child_.firstChild:
                sval_ = child_.firstChild.nodeValue
                try:
                    ival_ = int(sval_)
                except ValueError:
                    raise ValueError('requires integer -- %s' % child_.toxml())
                self.number_rejected = ival_
        elif child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'rmerge':
            if child_.firstChild:
                sval_ = child_.firstChild.nodeValue
                try:
                    fval_ = float(sval_)
                except ValueError:
                    raise ValueError('requires float (or double) -- %s' % child_.toxml())
                self.rmerge = fval_
# end class batch_results


class per_resolution_bin_results(object):
    subclass = None
    def __init__(self, resolution_bin_results=None):
        if resolution_bin_results is None:
            self.resolution_bin_results = []
        else:
            self.resolution_bin_results = resolution_bin_results
    def factory(*args_, **kwargs_):
        if per_resolution_bin_results.subclass:
            return per_resolution_bin_results.subclass(*args_, **kwargs_)
        else:
            return per_resolution_bin_results(*args_, **kwargs_)
    factory = staticmethod(factory)
    def getResolution_bin_results(self): return self.resolution_bin_results
    def setResolution_bin_results(self, resolution_bin_results): self.resolution_bin_results = resolution_bin_results
    def addResolution_bin_results(self, value): self.resolution_bin_results.append(value)
    def insertResolution_bin_results(self, index, value): self.resolution_bin_results[index] = value
    def export(self, outfile, level = 0, name_='per_resolution_bin_results'):
        showIndent(outfile, level)
        outfile.write('<%s>\n' % name_)
        self.exportChildren(outfile, level + 1, name_)
        showIndent(outfile, level)
        outfile.write('</%s>\n' % name_)
    def exportAttributes(self, outfile, level, name_='per_resolution_bin_results'):
        pass
    def exportChildren(self, outfile, level, name_='per_resolution_bin_results'):
        for resolution_bin_results_ in self.getResolution_bin_results():
            resolution_bin_results_.export(outfile, level)

    #Only to export the entire XML tree to a file stream on disk
    def outputFile( self, _outfileName ):
        outfile = open( _outfileName, "w" )
        outfile.write("<?xml version=\"1.0\" ?>\n")
        self.export( outfile, 0, name_='per_resolution_bin_results' )
        outfile.close()


    #Only to export the entire XML tree to a Html Page in a file stream on disk
    def outputPageHtml( self, _outfileName ):
        odtStrTitle = "    <span class=\"title\">per_resolution_bin_results:</span> <br> <br> <br>\n" 
        outfile = open( _outfileName, "w" )
        outfile.write( TEMPLATE_PAGE_P1 % ( odtStrTitle ) )
        self.exportLiteralHtml( outfile, 0, name_='per_resolution_bin_results' )
        outfile.write( TEMPLATE_PAGE_P2  )
        outfile.close()


    def outputFileHtml( self, _outfileName ):
        self.outputPageHtml( _outfileName )



    #Static method for parsing a string
    def parseString( _inString ):
        doc = minidom.parseString(_inString)
        rootNode = doc.documentElement
        rootObj = per_resolution_bin_results.factory()
        rootObj.build(rootNode)
        return rootObj
    parseString = staticmethod( parseString ) 


    #Method for marshalling an object
    def marshal( self ):
        oStreamString = StringIO.StringIO()
        oStreamString.write('<?xml version="1.0" ?>\n')
        self.export( oStreamString, 0, name_="per_resolution_bin_results" )
        oStringXML = oStreamString.getvalue()
        oStreamString.close()
        return oStringXML

    def exportLiteral(self, outfile, level = 0, name_='per_resolution_bin_results'):
        level += 1
        self.exportLiteralAttributes(outfile, level, name_)
        self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('resolution_bin_results=[\n')
        level += 1
        for resolution_bin_results in self.resolution_bin_results:
            showIndent(outfile, level)
            outfile.write('resolution_bin_results(\n')
            resolution_bin_results.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def exportLiteralHtml(self, outfile, level = 0, name_='per_resolution_bin_results'):
        level += 1
        self.exportLiteralAttributesHtml(outfile, level, name_)
        self.exportLiteralChildrenHtml(outfile, level, name_)
    def exportLiteralAttributesHtml(self, outfile, level, name_):
        pass
    def exportLiteralChildrenHtml(self, outfile, level, name_):
        showIndentHtml(outfile, level)
        outfile.write('resolution_bin_results<br>\n')
        level += 1
        for resolution_bin_results in self.resolution_bin_results:
            resolution_bin_results.exportLiteralHtml(outfile, level)
            showIndentHtml(outfile, level)
            outfile.write('<br>\n')
        level -= 1
        showIndentHtml(outfile, level)
        outfile.write('<br>\n')
    def build(self, node_):
        attrs = node_.attributes
        self.buildAttributes(attrs)
        for child_ in node_.childNodes:
            nodeName_ = child_.nodeName.split(':')[-1]
            self.buildChildren(child_, nodeName_)
    def buildAttributes(self, attrs):
        pass
    def buildChildren(self, child_, nodeName_):
        if child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'resolution_bin_results':
            obj_ = resolution_bin_results.factory()
            obj_.build(child_)
            self.resolution_bin_results.append(obj_)
# end class per_resolution_bin_results


class resolution_bin_results(object):
    subclass = None
    def __init__(self, bin=-1, resolution=None, rmerge=0.0, mean_i_over_sigma=0.0, fractional_bias=0.0):
        self.bin = bin
        self.resolution = resolution
        self.rmerge = rmerge
        self.mean_i_over_sigma = mean_i_over_sigma
        self.fractional_bias = fractional_bias
    def factory(*args_, **kwargs_):
        if resolution_bin_results.subclass:
            return resolution_bin_results.subclass(*args_, **kwargs_)
        else:
            return resolution_bin_results(*args_, **kwargs_)
    factory = staticmethod(factory)
    def getBin(self): return self.bin
    def setBin(self, bin): self.bin = bin
    def getResolution(self): return self.resolution
    def setResolution(self, resolution): self.resolution = resolution
    def getRmerge(self): return self.rmerge
    def setRmerge(self, rmerge): self.rmerge = rmerge
    def getMean_i_over_sigma(self): return self.mean_i_over_sigma
    def setMean_i_over_sigma(self, mean_i_over_sigma): self.mean_i_over_sigma = mean_i_over_sigma
    def getFractional_bias(self): return self.fractional_bias
    def setFractional_bias(self, fractional_bias): self.fractional_bias = fractional_bias
    def export(self, outfile, level = 0, name_='resolution_bin_results'):
        showIndent(outfile, level)
        outfile.write('<%s>\n' % name_)
        self.exportChildren(outfile, level + 1, name_)
        showIndent(outfile, level)
        outfile.write('</%s>\n' % name_)
    def exportAttributes(self, outfile, level, name_='resolution_bin_results'):
        pass
    def exportChildren(self, outfile, level, name_='resolution_bin_results'):
        showIndent(outfile, level)
        outfile.write('<bin>%d</bin>\n' % self.getBin())
        if self.resolution:
            self.resolution.export(outfile, level)
        showIndent(outfile, level)
        outfile.write('<rmerge>%e</rmerge>\n' % self.getRmerge())
        showIndent(outfile, level)
        outfile.write('<mean_i_over_sigma>%e</mean_i_over_sigma>\n' % self.getMean_i_over_sigma())
        showIndent(outfile, level)
        outfile.write('<fractional_bias>%e</fractional_bias>\n' % self.getFractional_bias())

    #Only to export the entire XML tree to a file stream on disk
    def outputFile( self, _outfileName ):
        outfile = open( _outfileName, "w" )
        outfile.write("<?xml version=\"1.0\" ?>\n")
        self.export( outfile, 0, name_='resolution_bin_results' )
        outfile.close()


    #Only to export the entire XML tree to a Html Page in a file stream on disk
    def outputPageHtml( self, _outfileName ):
        odtStrTitle = "    <span class=\"title\">resolution_bin_results:</span> <br> <br> <br>\n" 
        outfile = open( _outfileName, "w" )
        outfile.write( TEMPLATE_PAGE_P1 % ( odtStrTitle ) )
        self.exportLiteralHtml( outfile, 0, name_='resolution_bin_results' )
        outfile.write( TEMPLATE_PAGE_P2  )
        outfile.close()


    def outputFileHtml( self, _outfileName ):
        self.outputPageHtml( _outfileName )



    #Static method for parsing a string
    def parseString( _inString ):
        doc = minidom.parseString(_inString)
        rootNode = doc.documentElement
        rootObj = resolution_bin_results.factory()
        rootObj.build(rootNode)
        return rootObj
    parseString = staticmethod( parseString ) 


    #Method for marshalling an object
    def marshal( self ):
        oStreamString = StringIO.StringIO()
        oStreamString.write('<?xml version="1.0" ?>\n')
        self.export( oStreamString, 0, name_="resolution_bin_results" )
        oStringXML = oStreamString.getvalue()
        oStreamString.close()
        return oStringXML

    def exportLiteral(self, outfile, level = 0, name_='resolution_bin_results'):
        level += 1
        self.exportLiteralAttributes(outfile, level, name_)
        self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('bin = %d,\n' % self.getBin())
        if self.resolution:
            showIndent(outfile, level)
            outfile.write('resolution = resolution(\n')
            self.resolution.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        showIndent(outfile, level)
        outfile.write('rmerge = %e,\n' % self.getRmerge())
        showIndent(outfile, level)
        outfile.write('mean_i_over_sigma = %e,\n' % self.getMean_i_over_sigma())
        showIndent(outfile, level)
        outfile.write('fractional_bias = %e,\n' % self.getFractional_bias())
    def exportLiteralHtml(self, outfile, level = 0, name_='resolution_bin_results'):
        level += 1
        self.exportLiteralAttributesHtml(outfile, level, name_)
        self.exportLiteralChildrenHtml(outfile, level, name_)
    def exportLiteralAttributesHtml(self, outfile, level, name_):
        pass
    def exportLiteralChildrenHtml(self, outfile, level, name_):
        showIndentHtml(outfile, level)
        outfile.write('bin = <a  href:"#">%d</a><br>\n' % self.getBin())
        if self.resolution:
            showIndentHtml(outfile, level)
            outfile.write('resolution<br>\n')
            self.resolution.exportLiteralHtml(outfile, level)
            showIndentHtml(outfile, level)
            outfile.write('<br>\n')
        showIndentHtml(outfile, level)
        outfile.write('rmerge = <a  href:"#">%e</a><br>\n' % self.getRmerge())
        showIndentHtml(outfile, level)
        outfile.write('mean_i_over_sigma = <a  href:"#">%e</a><br>\n' % self.getMean_i_over_sigma())
        showIndentHtml(outfile, level)
        outfile.write('fractional_bias = <a  href:"#">%e</a><br>\n' % self.getFractional_bias())
    def build(self, node_):
        attrs = node_.attributes
        self.buildAttributes(attrs)
        for child_ in node_.childNodes:
            nodeName_ = child_.nodeName.split(':')[-1]
            self.buildChildren(child_, nodeName_)
    def buildAttributes(self, attrs):
        pass
    def buildChildren(self, child_, nodeName_):
        if child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'bin':
            if child_.firstChild:
                sval_ = child_.firstChild.nodeValue
                try:
                    ival_ = int(sval_)
                except ValueError:
                    raise ValueError('requires integer -- %s' % child_.toxml())
                self.bin = ival_
        elif child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'resolution':
            obj_ = resolution.factory()
            obj_.build(child_)
            self.setResolution(obj_)
        elif child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'rmerge':
            if child_.firstChild:
                sval_ = child_.firstChild.nodeValue
                try:
                    fval_ = float(sval_)
                except ValueError:
                    raise ValueError('requires float (or double) -- %s' % child_.toxml())
                self.rmerge = fval_
        elif child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'mean_i_over_sigma':
            if child_.firstChild:
                sval_ = child_.firstChild.nodeValue
                try:
                    fval_ = float(sval_)
                except ValueError:
                    raise ValueError('requires float (or double) -- %s' % child_.toxml())
                self.mean_i_over_sigma = fval_
        elif child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'fractional_bias':
            if child_.firstChild:
                sval_ = child_.firstChild.nodeValue
                try:
                    fval_ = float(sval_)
                except ValueError:
                    raise ValueError('requires float (or double) -- %s' % child_.toxml())
                self.fractional_bias = fval_
# end class resolution_bin_results


class per_intensity_bin_results(object):
    subclass = None
    def __init__(self, intensity_bin_results=None):
        if intensity_bin_results is None:
            self.intensity_bin_results = []
        else:
            self.intensity_bin_results = intensity_bin_results
    def factory(*args_, **kwargs_):
        if per_intensity_bin_results.subclass:
            return per_intensity_bin_results.subclass(*args_, **kwargs_)
        else:
            return per_intensity_bin_results(*args_, **kwargs_)
    factory = staticmethod(factory)
    def getIntensity_bin_results(self): return self.intensity_bin_results
    def setIntensity_bin_results(self, intensity_bin_results): self.intensity_bin_results = intensity_bin_results
    def addIntensity_bin_results(self, value): self.intensity_bin_results.append(value)
    def insertIntensity_bin_results(self, index, value): self.intensity_bin_results[index] = value
    def export(self, outfile, level = 0, name_='per_intensity_bin_results'):
        showIndent(outfile, level)
        outfile.write('<%s>\n' % name_)
        self.exportChildren(outfile, level + 1, name_)
        showIndent(outfile, level)
        outfile.write('</%s>\n' % name_)
    def exportAttributes(self, outfile, level, name_='per_intensity_bin_results'):
        pass
    def exportChildren(self, outfile, level, name_='per_intensity_bin_results'):
        for intensity_bin_results_ in self.getIntensity_bin_results():
            intensity_bin_results_.export(outfile, level)

    #Only to export the entire XML tree to a file stream on disk
    def outputFile( self, _outfileName ):
        outfile = open( _outfileName, "w" )
        outfile.write("<?xml version=\"1.0\" ?>\n")
        self.export( outfile, 0, name_='per_intensity_bin_results' )
        outfile.close()


    #Only to export the entire XML tree to a Html Page in a file stream on disk
    def outputPageHtml( self, _outfileName ):
        odtStrTitle = "    <span class=\"title\">per_intensity_bin_results:</span> <br> <br> <br>\n" 
        outfile = open( _outfileName, "w" )
        outfile.write( TEMPLATE_PAGE_P1 % ( odtStrTitle ) )
        self.exportLiteralHtml( outfile, 0, name_='per_intensity_bin_results' )
        outfile.write( TEMPLATE_PAGE_P2  )
        outfile.close()


    def outputFileHtml( self, _outfileName ):
        self.outputPageHtml( _outfileName )



    #Static method for parsing a string
    def parseString( _inString ):
        doc = minidom.parseString(_inString)
        rootNode = doc.documentElement
        rootObj = per_intensity_bin_results.factory()
        rootObj.build(rootNode)
        return rootObj
    parseString = staticmethod( parseString ) 


    #Method for marshalling an object
    def marshal( self ):
        oStreamString = StringIO.StringIO()
        oStreamString.write('<?xml version="1.0" ?>\n')
        self.export( oStreamString, 0, name_="per_intensity_bin_results" )
        oStringXML = oStreamString.getvalue()
        oStreamString.close()
        return oStringXML

    def exportLiteral(self, outfile, level = 0, name_='per_intensity_bin_results'):
        level += 1
        self.exportLiteralAttributes(outfile, level, name_)
        self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('intensity_bin_results=[\n')
        level += 1
        for intensity_bin_results in self.intensity_bin_results:
            showIndent(outfile, level)
            outfile.write('intensity_bin_results(\n')
            intensity_bin_results.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def exportLiteralHtml(self, outfile, level = 0, name_='per_intensity_bin_results'):
        level += 1
        self.exportLiteralAttributesHtml(outfile, level, name_)
        self.exportLiteralChildrenHtml(outfile, level, name_)
    def exportLiteralAttributesHtml(self, outfile, level, name_):
        pass
    def exportLiteralChildrenHtml(self, outfile, level, name_):
        showIndentHtml(outfile, level)
        outfile.write('intensity_bin_results<br>\n')
        level += 1
        for intensity_bin_results in self.intensity_bin_results:
            intensity_bin_results.exportLiteralHtml(outfile, level)
            showIndentHtml(outfile, level)
            outfile.write('<br>\n')
        level -= 1
        showIndentHtml(outfile, level)
        outfile.write('<br>\n')
    def build(self, node_):
        attrs = node_.attributes
        self.buildAttributes(attrs)
        for child_ in node_.childNodes:
            nodeName_ = child_.nodeName.split(':')[-1]
            self.buildChildren(child_, nodeName_)
    def buildAttributes(self, attrs):
        pass
    def buildChildren(self, child_, nodeName_):
        if child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'intensity_bin_results':
            obj_ = intensity_bin_results.factory()
            obj_.build(child_)
            self.intensity_bin_results.append(obj_)
# end class per_intensity_bin_results


class intensity_bin_results(object):
    subclass = None
    def __init__(self, bin=-1, min_intensity=0.0, max_intensity=0.0, mean_full=0.0, sigma_full=0.0, n_ref_full=-1, mean_partial=0.0, sigma_partial=0.0, n_ref_partial=-1):
        self.bin = bin
        self.min_intensity = min_intensity
        self.max_intensity = max_intensity
        self.mean_full = mean_full
        self.sigma_full = sigma_full
        self.n_ref_full = n_ref_full
        self.mean_partial = mean_partial
        self.sigma_partial = sigma_partial
        self.n_ref_partial = n_ref_partial
    def factory(*args_, **kwargs_):
        if intensity_bin_results.subclass:
            return intensity_bin_results.subclass(*args_, **kwargs_)
        else:
            return intensity_bin_results(*args_, **kwargs_)
    factory = staticmethod(factory)
    def getBin(self): return self.bin
    def setBin(self, bin): self.bin = bin
    def getMin_intensity(self): return self.min_intensity
    def setMin_intensity(self, min_intensity): self.min_intensity = min_intensity
    def getMax_intensity(self): return self.max_intensity
    def setMax_intensity(self, max_intensity): self.max_intensity = max_intensity
    def getMean_full(self): return self.mean_full
    def setMean_full(self, mean_full): self.mean_full = mean_full
    def getSigma_full(self): return self.sigma_full
    def setSigma_full(self, sigma_full): self.sigma_full = sigma_full
    def getN_ref_full(self): return self.n_ref_full
    def setN_ref_full(self, n_ref_full): self.n_ref_full = n_ref_full
    def getMean_partial(self): return self.mean_partial
    def setMean_partial(self, mean_partial): self.mean_partial = mean_partial
    def getSigma_partial(self): return self.sigma_partial
    def setSigma_partial(self, sigma_partial): self.sigma_partial = sigma_partial
    def getN_ref_partial(self): return self.n_ref_partial
    def setN_ref_partial(self, n_ref_partial): self.n_ref_partial = n_ref_partial
    def export(self, outfile, level = 0, name_='intensity_bin_results'):
        showIndent(outfile, level)
        outfile.write('<%s>\n' % name_)
        self.exportChildren(outfile, level + 1, name_)
        showIndent(outfile, level)
        outfile.write('</%s>\n' % name_)
    def exportAttributes(self, outfile, level, name_='intensity_bin_results'):
        pass
    def exportChildren(self, outfile, level, name_='intensity_bin_results'):
        showIndent(outfile, level)
        outfile.write('<bin>%d</bin>\n' % self.getBin())
        showIndent(outfile, level)
        outfile.write('<min_intensity>%e</min_intensity>\n' % self.getMin_intensity())
        showIndent(outfile, level)
        outfile.write('<max_intensity>%e</max_intensity>\n' % self.getMax_intensity())
        showIndent(outfile, level)
        outfile.write('<mean_full>%e</mean_full>\n' % self.getMean_full())
        showIndent(outfile, level)
        outfile.write('<sigma_full>%e</sigma_full>\n' % self.getSigma_full())
        showIndent(outfile, level)
        outfile.write('<n_ref_full>%d</n_ref_full>\n' % self.getN_ref_full())
        showIndent(outfile, level)
        outfile.write('<mean_partial>%e</mean_partial>\n' % self.getMean_partial())
        showIndent(outfile, level)
        outfile.write('<sigma_partial>%e</sigma_partial>\n' % self.getSigma_partial())
        showIndent(outfile, level)
        outfile.write('<n_ref_partial>%d</n_ref_partial>\n' % self.getN_ref_partial())

    #Only to export the entire XML tree to a file stream on disk
    def outputFile( self, _outfileName ):
        outfile = open( _outfileName, "w" )
        outfile.write("<?xml version=\"1.0\" ?>\n")
        self.export( outfile, 0, name_='intensity_bin_results' )
        outfile.close()


    #Only to export the entire XML tree to a Html Page in a file stream on disk
    def outputPageHtml( self, _outfileName ):
        odtStrTitle = "    <span class=\"title\">intensity_bin_results:</span> <br> <br> <br>\n" 
        outfile = open( _outfileName, "w" )
        outfile.write( TEMPLATE_PAGE_P1 % ( odtStrTitle ) )
        self.exportLiteralHtml( outfile, 0, name_='intensity_bin_results' )
        outfile.write( TEMPLATE_PAGE_P2  )
        outfile.close()


    def outputFileHtml( self, _outfileName ):
        self.outputPageHtml( _outfileName )



    #Static method for parsing a string
    def parseString( _inString ):
        doc = minidom.parseString(_inString)
        rootNode = doc.documentElement
        rootObj = intensity_bin_results.factory()
        rootObj.build(rootNode)
        return rootObj
    parseString = staticmethod( parseString ) 


    #Method for marshalling an object
    def marshal( self ):
        oStreamString = StringIO.StringIO()
        oStreamString.write('<?xml version="1.0" ?>\n')
        self.export( oStreamString, 0, name_="intensity_bin_results" )
        oStringXML = oStreamString.getvalue()
        oStreamString.close()
        return oStringXML

    def exportLiteral(self, outfile, level = 0, name_='intensity_bin_results'):
        level += 1
        self.exportLiteralAttributes(outfile, level, name_)
        self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('bin = %d,\n' % self.getBin())
        showIndent(outfile, level)
        outfile.write('min_intensity = %e,\n' % self.getMin_intensity())
        showIndent(outfile, level)
        outfile.write('max_intensity = %e,\n' % self.getMax_intensity())
        showIndent(outfile, level)
        outfile.write('mean_full = %e,\n' % self.getMean_full())
        showIndent(outfile, level)
        outfile.write('sigma_full = %e,\n' % self.getSigma_full())
        showIndent(outfile, level)
        outfile.write('n_ref_full = %d,\n' % self.getN_ref_full())
        showIndent(outfile, level)
        outfile.write('mean_partial = %e,\n' % self.getMean_partial())
        showIndent(outfile, level)
        outfile.write('sigma_partial = %e,\n' % self.getSigma_partial())
        showIndent(outfile, level)
        outfile.write('n_ref_partial = %d,\n' % self.getN_ref_partial())
    def exportLiteralHtml(self, outfile, level = 0, name_='intensity_bin_results'):
        level += 1
        self.exportLiteralAttributesHtml(outfile, level, name_)
        self.exportLiteralChildrenHtml(outfile, level, name_)
    def exportLiteralAttributesHtml(self, outfile, level, name_):
        pass
    def exportLiteralChildrenHtml(self, outfile, level, name_):
        showIndentHtml(outfile, level)
        outfile.write('bin = <a  href:"#">%d</a><br>\n' % self.getBin())
        showIndentHtml(outfile, level)
        outfile.write('min_intensity = <a  href:"#">%e</a><br>\n' % self.getMin_intensity())
        showIndentHtml(outfile, level)
        outfile.write('max_intensity = <a  href:"#">%e</a><br>\n' % self.getMax_intensity())
        showIndentHtml(outfile, level)
        outfile.write('mean_full = <a  href:"#">%e</a><br>\n' % self.getMean_full())
        showIndentHtml(outfile, level)
        outfile.write('sigma_full = <a  href:"#">%e</a><br>\n' % self.getSigma_full())
        showIndentHtml(outfile, level)
        outfile.write('n_ref_full = <a  href:"#">%d</a><br>\n' % self.getN_ref_full())
        showIndentHtml(outfile, level)
        outfile.write('mean_partial = <a  href:"#">%e</a><br>\n' % self.getMean_partial())
        showIndentHtml(outfile, level)
        outfile.write('sigma_partial = <a  href:"#">%e</a><br>\n' % self.getSigma_partial())
        showIndentHtml(outfile, level)
        outfile.write('n_ref_partial = <a  href:"#">%d</a><br>\n' % self.getN_ref_partial())
    def build(self, node_):
        attrs = node_.attributes
        self.buildAttributes(attrs)
        for child_ in node_.childNodes:
            nodeName_ = child_.nodeName.split(':')[-1]
            self.buildChildren(child_, nodeName_)
    def buildAttributes(self, attrs):
        pass
    def buildChildren(self, child_, nodeName_):
        if child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'bin':
            if child_.firstChild:
                sval_ = child_.firstChild.nodeValue
                try:
                    ival_ = int(sval_)
                except ValueError:
                    raise ValueError('requires integer -- %s' % child_.toxml())
                self.bin = ival_
        elif child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'min_intensity':
            if child_.firstChild:
                sval_ = child_.firstChild.nodeValue
                try:
                    fval_ = float(sval_)
                except ValueError:
                    raise ValueError('requires float (or double) -- %s' % child_.toxml())
                self.min_intensity = fval_
        elif child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'max_intensity':
            if child_.firstChild:
                sval_ = child_.firstChild.nodeValue
                try:
                    fval_ = float(sval_)
                except ValueError:
                    raise ValueError('requires float (or double) -- %s' % child_.toxml())
                self.max_intensity = fval_
        elif child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'mean_full':
            if child_.firstChild:
                sval_ = child_.firstChild.nodeValue
                try:
                    fval_ = float(sval_)
                except ValueError:
                    raise ValueError('requires float (or double) -- %s' % child_.toxml())
                self.mean_full = fval_
        elif child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'sigma_full':
            if child_.firstChild:
                sval_ = child_.firstChild.nodeValue
                try:
                    fval_ = float(sval_)
                except ValueError:
                    raise ValueError('requires float (or double) -- %s' % child_.toxml())
                self.sigma_full = fval_
        elif child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'n_ref_full':
            if child_.firstChild:
                sval_ = child_.firstChild.nodeValue
                try:
                    ival_ = int(sval_)
                except ValueError:
                    raise ValueError('requires integer -- %s' % child_.toxml())
                self.n_ref_full = ival_
        elif child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'mean_partial':
            if child_.firstChild:
                sval_ = child_.firstChild.nodeValue
                try:
                    fval_ = float(sval_)
                except ValueError:
                    raise ValueError('requires float (or double) -- %s' % child_.toxml())
                self.mean_partial = fval_
        elif child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'sigma_partial':
            if child_.firstChild:
                sval_ = child_.firstChild.nodeValue
                try:
                    fval_ = float(sval_)
                except ValueError:
                    raise ValueError('requires float (or double) -- %s' % child_.toxml())
                self.sigma_partial = fval_
        elif child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'n_ref_partial':
            if child_.firstChild:
                sval_ = child_.firstChild.nodeValue
                try:
                    ival_ = int(sval_)
                except ValueError:
                    raise ValueError('requires integer -- %s' % child_.toxml())
                self.n_ref_partial = ival_
# end class intensity_bin_results


class standard_deviation_parameters(object):
    subclass = None
    def __init__(self, sdfac_full=0.0, sdadd_full=0.0, sdfac_partial=0.0, sdadd_partial=0.0):
        self.sdfac_full = sdfac_full
        self.sdadd_full = sdadd_full
        self.sdfac_partial = sdfac_partial
        self.sdadd_partial = sdadd_partial
    def factory(*args_, **kwargs_):
        if standard_deviation_parameters.subclass:
            return standard_deviation_parameters.subclass(*args_, **kwargs_)
        else:
            return standard_deviation_parameters(*args_, **kwargs_)
    factory = staticmethod(factory)
    def getSdfac_full(self): return self.sdfac_full
    def setSdfac_full(self, sdfac_full): self.sdfac_full = sdfac_full
    def getSdadd_full(self): return self.sdadd_full
    def setSdadd_full(self, sdadd_full): self.sdadd_full = sdadd_full
    def getSdfac_partial(self): return self.sdfac_partial
    def setSdfac_partial(self, sdfac_partial): self.sdfac_partial = sdfac_partial
    def getSdadd_partial(self): return self.sdadd_partial
    def setSdadd_partial(self, sdadd_partial): self.sdadd_partial = sdadd_partial
    def export(self, outfile, level = 0, name_='standard_deviation_parameters'):
        showIndent(outfile, level)
        outfile.write('<%s>\n' % name_)
        self.exportChildren(outfile, level + 1, name_)
        showIndent(outfile, level)
        outfile.write('</%s>\n' % name_)
    def exportAttributes(self, outfile, level, name_='standard_deviation_parameters'):
        pass
    def exportChildren(self, outfile, level, name_='standard_deviation_parameters'):
        showIndent(outfile, level)
        outfile.write('<sdfac_full>%e</sdfac_full>\n' % self.getSdfac_full())
        showIndent(outfile, level)
        outfile.write('<sdadd_full>%e</sdadd_full>\n' % self.getSdadd_full())
        showIndent(outfile, level)
        outfile.write('<sdfac_partial>%e</sdfac_partial>\n' % self.getSdfac_partial())
        showIndent(outfile, level)
        outfile.write('<sdadd_partial>%e</sdadd_partial>\n' % self.getSdadd_partial())

    #Only to export the entire XML tree to a file stream on disk
    def outputFile( self, _outfileName ):
        outfile = open( _outfileName, "w" )
        outfile.write("<?xml version=\"1.0\" ?>\n")
        self.export( outfile, 0, name_='standard_deviation_parameters' )
        outfile.close()


    #Only to export the entire XML tree to a Html Page in a file stream on disk
    def outputPageHtml( self, _outfileName ):
        odtStrTitle = "    <span class=\"title\">standard_deviation_parameters:</span> <br> <br> <br>\n" 
        outfile = open( _outfileName, "w" )
        outfile.write( TEMPLATE_PAGE_P1 % ( odtStrTitle ) )
        self.exportLiteralHtml( outfile, 0, name_='standard_deviation_parameters' )
        outfile.write( TEMPLATE_PAGE_P2  )
        outfile.close()


    def outputFileHtml( self, _outfileName ):
        self.outputPageHtml( _outfileName )



    #Static method for parsing a string
    def parseString( _inString ):
        doc = minidom.parseString(_inString)
        rootNode = doc.documentElement
        rootObj = standard_deviation_parameters.factory()
        rootObj.build(rootNode)
        return rootObj
    parseString = staticmethod( parseString ) 


    #Method for marshalling an object
    def marshal( self ):
        oStreamString = StringIO.StringIO()
        oStreamString.write('<?xml version="1.0" ?>\n')
        self.export( oStreamString, 0, name_="standard_deviation_parameters" )
        oStringXML = oStreamString.getvalue()
        oStreamString.close()
        return oStringXML

    def exportLiteral(self, outfile, level = 0, name_='standard_deviation_parameters'):
        level += 1
        self.exportLiteralAttributes(outfile, level, name_)
        self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('sdfac_full = %e,\n' % self.getSdfac_full())
        showIndent(outfile, level)
        outfile.write('sdadd_full = %e,\n' % self.getSdadd_full())
        showIndent(outfile, level)
        outfile.write('sdfac_partial = %e,\n' % self.getSdfac_partial())
        showIndent(outfile, level)
        outfile.write('sdadd_partial = %e,\n' % self.getSdadd_partial())
    def exportLiteralHtml(self, outfile, level = 0, name_='standard_deviation_parameters'):
        level += 1
        self.exportLiteralAttributesHtml(outfile, level, name_)
        self.exportLiteralChildrenHtml(outfile, level, name_)
    def exportLiteralAttributesHtml(self, outfile, level, name_):
        pass
    def exportLiteralChildrenHtml(self, outfile, level, name_):
        showIndentHtml(outfile, level)
        outfile.write('sdfac_full = <a  href:"#">%e</a><br>\n' % self.getSdfac_full())
        showIndentHtml(outfile, level)
        outfile.write('sdadd_full = <a  href:"#">%e</a><br>\n' % self.getSdadd_full())
        showIndentHtml(outfile, level)
        outfile.write('sdfac_partial = <a  href:"#">%e</a><br>\n' % self.getSdfac_partial())
        showIndentHtml(outfile, level)
        outfile.write('sdadd_partial = <a  href:"#">%e</a><br>\n' % self.getSdadd_partial())
    def build(self, node_):
        attrs = node_.attributes
        self.buildAttributes(attrs)
        for child_ in node_.childNodes:
            nodeName_ = child_.nodeName.split(':')[-1]
            self.buildChildren(child_, nodeName_)
    def buildAttributes(self, attrs):
        pass
    def buildChildren(self, child_, nodeName_):
        if child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'sdfac_full':
            if child_.firstChild:
                sval_ = child_.firstChild.nodeValue
                try:
                    fval_ = float(sval_)
                except ValueError:
                    raise ValueError('requires float (or double) -- %s' % child_.toxml())
                self.sdfac_full = fval_
        elif child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'sdadd_full':
            if child_.firstChild:
                sval_ = child_.firstChild.nodeValue
                try:
                    fval_ = float(sval_)
                except ValueError:
                    raise ValueError('requires float (or double) -- %s' % child_.toxml())
                self.sdadd_full = fval_
        elif child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'sdfac_partial':
            if child_.firstChild:
                sval_ = child_.firstChild.nodeValue
                try:
                    fval_ = float(sval_)
                except ValueError:
                    raise ValueError('requires float (or double) -- %s' % child_.toxml())
                self.sdfac_partial = fval_
        elif child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'sdadd_partial':
            if child_.firstChild:
                sval_ = child_.firstChild.nodeValue
                try:
                    fval_ = float(sval_)
                except ValueError:
                    raise ValueError('requires float (or double) -- %s' % child_.toxml())
                self.sdadd_partial = fval_
# end class standard_deviation_parameters


class truncate_reflections_request(object):
    subclass = None
    def __init__(self, input_reflections=None, output_reflections=None, truncate_options=None):
        self.input_reflections = input_reflections
        self.output_reflections = output_reflections
        self.truncate_options = truncate_options
    def factory(*args_, **kwargs_):
        if truncate_reflections_request.subclass:
            return truncate_reflections_request.subclass(*args_, **kwargs_)
        else:
            return truncate_reflections_request(*args_, **kwargs_)
    factory = staticmethod(factory)
    def getInput_reflections(self): return self.input_reflections
    def setInput_reflections(self, input_reflections): self.input_reflections = input_reflections
    def getOutput_reflections(self): return self.output_reflections
    def setOutput_reflections(self, output_reflections): self.output_reflections = output_reflections
    def getTruncate_options(self): return self.truncate_options
    def setTruncate_options(self, truncate_options): self.truncate_options = truncate_options
    def export(self, outfile, level = 0, name_='truncate_reflections_request'):
        showIndent(outfile, level)
        outfile.write('<%s>\n' % name_)
        self.exportChildren(outfile, level + 1, name_)
        showIndent(outfile, level)
        outfile.write('</%s>\n' % name_)
    def exportAttributes(self, outfile, level, name_='truncate_reflections_request'):
        pass
    def exportChildren(self, outfile, level, name_='truncate_reflections_request'):
        if self.input_reflections:
            self.input_reflections.export(outfile, level)
        if self.output_reflections:
            self.output_reflections.export(outfile, level)
        if self.truncate_options:
            self.truncate_options.export(outfile, level)

    #Only to export the entire XML tree to a file stream on disk
    def outputFile( self, _outfileName ):
        outfile = open( _outfileName, "w" )
        outfile.write("<?xml version=\"1.0\" ?>\n")
        self.export( outfile, 0, name_='truncate_reflections_request' )
        outfile.close()


    #Only to export the entire XML tree to a Html Page in a file stream on disk
    def outputPageHtml( self, _outfileName ):
        odtStrTitle = "    <span class=\"title\">truncate_reflections_request:</span> <br> <br> <br>\n" 
        outfile = open( _outfileName, "w" )
        outfile.write( TEMPLATE_PAGE_P1 % ( odtStrTitle ) )
        self.exportLiteralHtml( outfile, 0, name_='truncate_reflections_request' )
        outfile.write( TEMPLATE_PAGE_P2  )
        outfile.close()


    def outputFileHtml( self, _outfileName ):
        self.outputPageHtml( _outfileName )



    #Static method for parsing a string
    def parseString( _inString ):
        doc = minidom.parseString(_inString)
        rootNode = doc.documentElement
        rootObj = truncate_reflections_request.factory()
        rootObj.build(rootNode)
        return rootObj
    parseString = staticmethod( parseString ) 


    #Method for marshalling an object
    def marshal( self ):
        oStreamString = StringIO.StringIO()
        oStreamString.write('<?xml version="1.0" ?>\n')
        self.export( oStreamString, 0, name_="truncate_reflections_request" )
        oStringXML = oStreamString.getvalue()
        oStreamString.close()
        return oStringXML

    def exportLiteral(self, outfile, level = 0, name_='truncate_reflections_request'):
        level += 1
        self.exportLiteralAttributes(outfile, level, name_)
        self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.input_reflections:
            showIndent(outfile, level)
            outfile.write('input_reflections = input_reflections(\n')
            self.input_reflections.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.output_reflections:
            showIndent(outfile, level)
            outfile.write('output_reflections = output_reflections(\n')
            self.output_reflections.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.truncate_options:
            showIndent(outfile, level)
            outfile.write('truncate_options = truncate_options(\n')
            self.truncate_options.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
    def exportLiteralHtml(self, outfile, level = 0, name_='truncate_reflections_request'):
        level += 1
        self.exportLiteralAttributesHtml(outfile, level, name_)
        self.exportLiteralChildrenHtml(outfile, level, name_)
    def exportLiteralAttributesHtml(self, outfile, level, name_):
        pass
    def exportLiteralChildrenHtml(self, outfile, level, name_):
        if self.input_reflections:
            showIndentHtml(outfile, level)
            outfile.write('input_reflections<br>\n')
            self.input_reflections.exportLiteralHtml(outfile, level)
            showIndentHtml(outfile, level)
            outfile.write('<br>\n')
        if self.output_reflections:
            showIndentHtml(outfile, level)
            outfile.write('output_reflections<br>\n')
            self.output_reflections.exportLiteralHtml(outfile, level)
            showIndentHtml(outfile, level)
            outfile.write('<br>\n')
        if self.truncate_options:
            showIndentHtml(outfile, level)
            outfile.write('truncate_options<br>\n')
            self.truncate_options.exportLiteralHtml(outfile, level)
            showIndentHtml(outfile, level)
            outfile.write('<br>\n')
    def build(self, node_):
        attrs = node_.attributes
        self.buildAttributes(attrs)
        for child_ in node_.childNodes:
            nodeName_ = child_.nodeName.split(':')[-1]
            self.buildChildren(child_, nodeName_)
    def buildAttributes(self, attrs):
        pass
    def buildChildren(self, child_, nodeName_):
        if child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'input_reflections':
            obj_ = input_reflections.factory()
            obj_.build(child_)
            self.setInput_reflections(obj_)
        elif child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'output_reflections':
            obj_ = output_reflections.factory()
            obj_.build(child_)
            self.setOutput_reflections(obj_)
        elif child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'truncate_options':
            obj_ = truncate_options.factory()
            obj_.build(child_)
            self.setTruncate_options(obj_)
# end class truncate_reflections_request


class truncate_options(object):
    subclass = None
    def __init__(self, residue_count=-1, aa_sequence=''):
        self.residue_count = residue_count
        self.aa_sequence = aa_sequence
    def factory(*args_, **kwargs_):
        if truncate_options.subclass:
            return truncate_options.subclass(*args_, **kwargs_)
        else:
            return truncate_options(*args_, **kwargs_)
    factory = staticmethod(factory)
    def getResidue_count(self): return self.residue_count
    def setResidue_count(self, residue_count): self.residue_count = residue_count
    def getAa_sequence(self): return self.aa_sequence
    def setAa_sequence(self, aa_sequence): self.aa_sequence = aa_sequence
    def export(self, outfile, level = 0, name_='truncate_options'):
        showIndent(outfile, level)
        outfile.write('<%s>\n' % name_)
        self.exportChildren(outfile, level + 1, name_)
        showIndent(outfile, level)
        outfile.write('</%s>\n' % name_)
    def exportAttributes(self, outfile, level, name_='truncate_options'):
        pass
    def exportChildren(self, outfile, level, name_='truncate_options'):
        showIndent(outfile, level)
        outfile.write('<residue_count>%d</residue_count>\n' % self.getResidue_count())
        showIndent(outfile, level)
        outfile.write('<aa_sequence>%s</aa_sequence>\n' % quote_xml(self.getAa_sequence()))

    #Only to export the entire XML tree to a file stream on disk
    def outputFile( self, _outfileName ):
        outfile = open( _outfileName, "w" )
        outfile.write("<?xml version=\"1.0\" ?>\n")
        self.export( outfile, 0, name_='truncate_options' )
        outfile.close()


    #Only to export the entire XML tree to a Html Page in a file stream on disk
    def outputPageHtml( self, _outfileName ):
        odtStrTitle = "    <span class=\"title\">truncate_options:</span> <br> <br> <br>\n" 
        outfile = open( _outfileName, "w" )
        outfile.write( TEMPLATE_PAGE_P1 % ( odtStrTitle ) )
        self.exportLiteralHtml( outfile, 0, name_='truncate_options' )
        outfile.write( TEMPLATE_PAGE_P2  )
        outfile.close()


    def outputFileHtml( self, _outfileName ):
        self.outputPageHtml( _outfileName )



    #Static method for parsing a string
    def parseString( _inString ):
        doc = minidom.parseString(_inString)
        rootNode = doc.documentElement
        rootObj = truncate_options.factory()
        rootObj.build(rootNode)
        return rootObj
    parseString = staticmethod( parseString ) 


    #Method for marshalling an object
    def marshal( self ):
        oStreamString = StringIO.StringIO()
        oStreamString.write('<?xml version="1.0" ?>\n')
        self.export( oStreamString, 0, name_="truncate_options" )
        oStringXML = oStreamString.getvalue()
        oStreamString.close()
        return oStringXML

    def exportLiteral(self, outfile, level = 0, name_='truncate_options'):
        level += 1
        self.exportLiteralAttributes(outfile, level, name_)
        self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('residue_count = %d,\n' % self.getResidue_count())
        showIndent(outfile, level)
        outfile.write('aa_sequence = %s,\n' % quote_python(self.getAa_sequence()))
    def exportLiteralHtml(self, outfile, level = 0, name_='truncate_options'):
        level += 1
        self.exportLiteralAttributesHtml(outfile, level, name_)
        self.exportLiteralChildrenHtml(outfile, level, name_)
    def exportLiteralAttributesHtml(self, outfile, level, name_):
        pass
    def exportLiteralChildrenHtml(self, outfile, level, name_):
        showIndentHtml(outfile, level)
        outfile.write('residue_count = <a  href:"#">%d</a><br>\n' % self.getResidue_count())
        showIndentHtml(outfile, level)
        outfile.write('aa_sequence = <a  href:"#">%s</a><br>\n' % quote_python(self.getAa_sequence()))
    def build(self, node_):
        attrs = node_.attributes
        self.buildAttributes(attrs)
        for child_ in node_.childNodes:
            nodeName_ = child_.nodeName.split(':')[-1]
            self.buildChildren(child_, nodeName_)
    def buildAttributes(self, attrs):
        pass
    def buildChildren(self, child_, nodeName_):
        if child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'residue_count':
            if child_.firstChild:
                sval_ = child_.firstChild.nodeValue
                try:
                    ival_ = int(sval_)
                except ValueError:
                    raise ValueError('requires integer -- %s' % child_.toxml())
                self.residue_count = ival_
        elif child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'aa_sequence':
            aa_sequence_ = ''
            for text__content_ in child_.childNodes:
                aa_sequence_ += text__content_.nodeValue
            self.aa_sequence = aa_sequence_
# end class truncate_options


class truncate_reflections_response(object):
    subclass = None
    def __init__(self, status=None, bfactor_value=0.0, solvent_content=0.0, twinning=''):
        self.status = status
        self.bfactor_value = bfactor_value
        self.solvent_content = solvent_content
        self.twinning = twinning
    def factory(*args_, **kwargs_):
        if truncate_reflections_response.subclass:
            return truncate_reflections_response.subclass(*args_, **kwargs_)
        else:
            return truncate_reflections_response(*args_, **kwargs_)
    factory = staticmethod(factory)
    def getStatus(self): return self.status
    def setStatus(self, status): self.status = status
    def getBfactor_value(self): return self.bfactor_value
    def setBfactor_value(self, bfactor_value): self.bfactor_value = bfactor_value
    def getSolvent_content(self): return self.solvent_content
    def setSolvent_content(self, solvent_content): self.solvent_content = solvent_content
    def getTwinning(self): return self.twinning
    def setTwinning(self, twinning): self.twinning = twinning
    def export(self, outfile, level = 0, name_='truncate_reflections_response'):
        showIndent(outfile, level)
        outfile.write('<%s>\n' % name_)
        self.exportChildren(outfile, level + 1, name_)
        showIndent(outfile, level)
        outfile.write('</%s>\n' % name_)
    def exportAttributes(self, outfile, level, name_='truncate_reflections_response'):
        pass
    def exportChildren(self, outfile, level, name_='truncate_reflections_response'):
        if self.status:
            self.status.export(outfile, level)
        showIndent(outfile, level)
        outfile.write('<bfactor_value>%e</bfactor_value>\n' % self.getBfactor_value())
        showIndent(outfile, level)
        outfile.write('<solvent_content>%e</solvent_content>\n' % self.getSolvent_content())
        showIndent(outfile, level)
        outfile.write('<twinning>%s</twinning>\n' % quote_xml(self.getTwinning()))

    #Only to export the entire XML tree to a file stream on disk
    def outputFile( self, _outfileName ):
        outfile = open( _outfileName, "w" )
        outfile.write("<?xml version=\"1.0\" ?>\n")
        self.export( outfile, 0, name_='truncate_reflections_response' )
        outfile.close()


    #Only to export the entire XML tree to a Html Page in a file stream on disk
    def outputPageHtml( self, _outfileName ):
        odtStrTitle = "    <span class=\"title\">truncate_reflections_response:</span> <br> <br> <br>\n" 
        outfile = open( _outfileName, "w" )
        outfile.write( TEMPLATE_PAGE_P1 % ( odtStrTitle ) )
        self.exportLiteralHtml( outfile, 0, name_='truncate_reflections_response' )
        outfile.write( TEMPLATE_PAGE_P2  )
        outfile.close()


    def outputFileHtml( self, _outfileName ):
        self.outputPageHtml( _outfileName )



    #Static method for parsing a string
    def parseString( _inString ):
        doc = minidom.parseString(_inString)
        rootNode = doc.documentElement
        rootObj = truncate_reflections_response.factory()
        rootObj.build(rootNode)
        return rootObj
    parseString = staticmethod( parseString ) 


    #Method for marshalling an object
    def marshal( self ):
        oStreamString = StringIO.StringIO()
        oStreamString.write('<?xml version="1.0" ?>\n')
        self.export( oStreamString, 0, name_="truncate_reflections_response" )
        oStringXML = oStreamString.getvalue()
        oStreamString.close()
        return oStringXML

    def exportLiteral(self, outfile, level = 0, name_='truncate_reflections_response'):
        level += 1
        self.exportLiteralAttributes(outfile, level, name_)
        self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.status:
            showIndent(outfile, level)
            outfile.write('status = status(\n')
            self.status.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        showIndent(outfile, level)
        outfile.write('bfactor_value = %e,\n' % self.getBfactor_value())
        showIndent(outfile, level)
        outfile.write('solvent_content = %e,\n' % self.getSolvent_content())
        showIndent(outfile, level)
        outfile.write('twinning = %s,\n' % quote_python(self.getTwinning()))
    def exportLiteralHtml(self, outfile, level = 0, name_='truncate_reflections_response'):
        level += 1
        self.exportLiteralAttributesHtml(outfile, level, name_)
        self.exportLiteralChildrenHtml(outfile, level, name_)
    def exportLiteralAttributesHtml(self, outfile, level, name_):
        pass
    def exportLiteralChildrenHtml(self, outfile, level, name_):
        if self.status:
            showIndentHtml(outfile, level)
            outfile.write('status<br>\n')
            self.status.exportLiteralHtml(outfile, level)
            showIndentHtml(outfile, level)
            outfile.write('<br>\n')
        showIndentHtml(outfile, level)
        outfile.write('bfactor_value = <a  href:"#">%e</a><br>\n' % self.getBfactor_value())
        showIndentHtml(outfile, level)
        outfile.write('solvent_content = <a  href:"#">%e</a><br>\n' % self.getSolvent_content())
        showIndentHtml(outfile, level)
        outfile.write('twinning = <a  href:"#">%s</a><br>\n' % quote_python(self.getTwinning()))
    def build(self, node_):
        attrs = node_.attributes
        self.buildAttributes(attrs)
        for child_ in node_.childNodes:
            nodeName_ = child_.nodeName.split(':')[-1]
            self.buildChildren(child_, nodeName_)
    def buildAttributes(self, attrs):
        pass
    def buildChildren(self, child_, nodeName_):
        if child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'status':
            obj_ = status.factory()
            obj_.build(child_)
            self.setStatus(obj_)
        elif child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'bfactor_value':
            if child_.firstChild:
                sval_ = child_.firstChild.nodeValue
                try:
                    fval_ = float(sval_)
                except ValueError:
                    raise ValueError('requires float (or double) -- %s' % child_.toxml())
                self.bfactor_value = fval_
        elif child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'solvent_content':
            if child_.firstChild:
                sval_ = child_.firstChild.nodeValue
                try:
                    fval_ = float(sval_)
                except ValueError:
                    raise ValueError('requires float (or double) -- %s' % child_.toxml())
                self.solvent_content = fval_
        elif child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'twinning':
            twinning_ = ''
            for text__content_ in child_.childNodes:
                twinning_ += text__content_.nodeValue
            self.twinning = twinning_
# end class truncate_reflections_response


class mosflm_commands(object):
    subclass = None
    def __init__(self, command=None):
        if command is None:
            self.command = []
        else:
            self.command = command
    def factory(*args_, **kwargs_):
        if mosflm_commands.subclass:
            return mosflm_commands.subclass(*args_, **kwargs_)
        else:
            return mosflm_commands(*args_, **kwargs_)
    factory = staticmethod(factory)
    def getCommand(self): return self.command
    def setCommand(self, command): self.command = command
    def addCommand(self, value): self.command.append(value)
    def insertCommand(self, index, value): self.command[index] = value
    def export(self, outfile, level = 0, name_='mosflm_commands'):
        showIndent(outfile, level)
        outfile.write('<%s>\n' % name_)
        self.exportChildren(outfile, level + 1, name_)
        showIndent(outfile, level)
        outfile.write('</%s>\n' % name_)
    def exportAttributes(self, outfile, level, name_='mosflm_commands'):
        pass
    def exportChildren(self, outfile, level, name_='mosflm_commands'):
        for command_ in self.getCommand():
            showIndent(outfile, level)
            outfile.write('<command>%s</command>\n' % quote_xml(command_))

    #Only to export the entire XML tree to a file stream on disk
    def outputFile( self, _outfileName ):
        outfile = open( _outfileName, "w" )
        outfile.write("<?xml version=\"1.0\" ?>\n")
        self.export( outfile, 0, name_='mosflm_commands' )
        outfile.close()


    #Only to export the entire XML tree to a Html Page in a file stream on disk
    def outputPageHtml( self, _outfileName ):
        odtStrTitle = "    <span class=\"title\">mosflm_commands:</span> <br> <br> <br>\n" 
        outfile = open( _outfileName, "w" )
        outfile.write( TEMPLATE_PAGE_P1 % ( odtStrTitle ) )
        self.exportLiteralHtml( outfile, 0, name_='mosflm_commands' )
        outfile.write( TEMPLATE_PAGE_P2  )
        outfile.close()


    def outputFileHtml( self, _outfileName ):
        self.outputPageHtml( _outfileName )



    #Static method for parsing a string
    def parseString( _inString ):
        doc = minidom.parseString(_inString)
        rootNode = doc.documentElement
        rootObj = mosflm_commands.factory()
        rootObj.build(rootNode)
        return rootObj
    parseString = staticmethod( parseString ) 


    #Method for marshalling an object
    def marshal( self ):
        oStreamString = StringIO.StringIO()
        oStreamString.write('<?xml version="1.0" ?>\n')
        self.export( oStreamString, 0, name_="mosflm_commands" )
        oStringXML = oStreamString.getvalue()
        oStreamString.close()
        return oStringXML

    def exportLiteral(self, outfile, level = 0, name_='mosflm_commands'):
        level += 1
        self.exportLiteralAttributes(outfile, level, name_)
        self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('command=[\n')
        level += 1
        for command in self.command:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(command))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def exportLiteralHtml(self, outfile, level = 0, name_='mosflm_commands'):
        level += 1
        self.exportLiteralAttributesHtml(outfile, level, name_)
        self.exportLiteralChildrenHtml(outfile, level, name_)
    def exportLiteralAttributesHtml(self, outfile, level, name_):
        pass
    def exportLiteralChildrenHtml(self, outfile, level, name_):
        showIndentHtml(outfile, level)
        outfile.write('command<br>\n')
        level += 1
        for command in self.command:
            showIndentHtml(outfile, level)
            outfile.write('<a  href:"#">%s</a><br>\n' % quote_python(command))
        level -= 1
        showIndentHtml(outfile, level)
        outfile.write('<br>\n')
    def build(self, node_):
        attrs = node_.attributes
        self.buildAttributes(attrs)
        for child_ in node_.childNodes:
            nodeName_ = child_.nodeName.split(':')[-1]
            self.buildChildren(child_, nodeName_)
    def buildAttributes(self, attrs):
        pass
    def buildChildren(self, child_, nodeName_):
        if child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'command':
            command_ = ''
            for text__content_ in child_.childNodes:
                command_ += text__content_.nodeValue
            self.command.append(command_)
# end class mosflm_commands


class scala_commands(object):
    subclass = None
    def __init__(self, command=None):
        if command is None:
            self.command = []
        else:
            self.command = command
    def factory(*args_, **kwargs_):
        if scala_commands.subclass:
            return scala_commands.subclass(*args_, **kwargs_)
        else:
            return scala_commands(*args_, **kwargs_)
    factory = staticmethod(factory)
    def getCommand(self): return self.command
    def setCommand(self, command): self.command = command
    def addCommand(self, value): self.command.append(value)
    def insertCommand(self, index, value): self.command[index] = value
    def export(self, outfile, level = 0, name_='scala_commands'):
        showIndent(outfile, level)
        outfile.write('<%s>\n' % name_)
        self.exportChildren(outfile, level + 1, name_)
        showIndent(outfile, level)
        outfile.write('</%s>\n' % name_)
    def exportAttributes(self, outfile, level, name_='scala_commands'):
        pass
    def exportChildren(self, outfile, level, name_='scala_commands'):
        for command_ in self.getCommand():
            showIndent(outfile, level)
            outfile.write('<command>%s</command>\n' % quote_xml(command_))

    #Only to export the entire XML tree to a file stream on disk
    def outputFile( self, _outfileName ):
        outfile = open( _outfileName, "w" )
        outfile.write("<?xml version=\"1.0\" ?>\n")
        self.export( outfile, 0, name_='scala_commands' )
        outfile.close()


    #Only to export the entire XML tree to a Html Page in a file stream on disk
    def outputPageHtml( self, _outfileName ):
        odtStrTitle = "    <span class=\"title\">scala_commands:</span> <br> <br> <br>\n" 
        outfile = open( _outfileName, "w" )
        outfile.write( TEMPLATE_PAGE_P1 % ( odtStrTitle ) )
        self.exportLiteralHtml( outfile, 0, name_='scala_commands' )
        outfile.write( TEMPLATE_PAGE_P2  )
        outfile.close()


    def outputFileHtml( self, _outfileName ):
        self.outputPageHtml( _outfileName )



    #Static method for parsing a string
    def parseString( _inString ):
        doc = minidom.parseString(_inString)
        rootNode = doc.documentElement
        rootObj = scala_commands.factory()
        rootObj.build(rootNode)
        return rootObj
    parseString = staticmethod( parseString ) 


    #Method for marshalling an object
    def marshal( self ):
        oStreamString = StringIO.StringIO()
        oStreamString.write('<?xml version="1.0" ?>\n')
        self.export( oStreamString, 0, name_="scala_commands" )
        oStringXML = oStreamString.getvalue()
        oStreamString.close()
        return oStringXML

    def exportLiteral(self, outfile, level = 0, name_='scala_commands'):
        level += 1
        self.exportLiteralAttributes(outfile, level, name_)
        self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('command=[\n')
        level += 1
        for command in self.command:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(command))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def exportLiteralHtml(self, outfile, level = 0, name_='scala_commands'):
        level += 1
        self.exportLiteralAttributesHtml(outfile, level, name_)
        self.exportLiteralChildrenHtml(outfile, level, name_)
    def exportLiteralAttributesHtml(self, outfile, level, name_):
        pass
    def exportLiteralChildrenHtml(self, outfile, level, name_):
        showIndentHtml(outfile, level)
        outfile.write('command<br>\n')
        level += 1
        for command in self.command:
            showIndentHtml(outfile, level)
            outfile.write('<a  href:"#">%s</a><br>\n' % quote_python(command))
        level -= 1
        showIndentHtml(outfile, level)
        outfile.write('<br>\n')
    def build(self, node_):
        attrs = node_.attributes
        self.buildAttributes(attrs)
        for child_ in node_.childNodes:
            nodeName_ = child_.nodeName.split(':')[-1]
            self.buildChildren(child_, nodeName_)
    def buildAttributes(self, attrs):
        pass
    def buildChildren(self, child_, nodeName_):
        if child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'command':
            command_ = ''
            for text__content_ in child_.childNodes:
                command_ += text__content_.nodeValue
            self.command.append(command_)
# end class scala_commands


class xds_commands(object):
    subclass = None
    def __init__(self, command=None):
        if command is None:
            self.command = []
        else:
            self.command = command
    def factory(*args_, **kwargs_):
        if xds_commands.subclass:
            return xds_commands.subclass(*args_, **kwargs_)
        else:
            return xds_commands(*args_, **kwargs_)
    factory = staticmethod(factory)
    def getCommand(self): return self.command
    def setCommand(self, command): self.command = command
    def addCommand(self, value): self.command.append(value)
    def insertCommand(self, index, value): self.command[index] = value
    def export(self, outfile, level = 0, name_='xds_commands'):
        showIndent(outfile, level)
        outfile.write('<%s>\n' % name_)
        self.exportChildren(outfile, level + 1, name_)
        showIndent(outfile, level)
        outfile.write('</%s>\n' % name_)
    def exportAttributes(self, outfile, level, name_='xds_commands'):
        pass
    def exportChildren(self, outfile, level, name_='xds_commands'):
        for command_ in self.getCommand():
            showIndent(outfile, level)
            outfile.write('<command>%s</command>\n' % quote_xml(command_))

    #Only to export the entire XML tree to a file stream on disk
    def outputFile( self, _outfileName ):
        outfile = open( _outfileName, "w" )
        outfile.write("<?xml version=\"1.0\" ?>\n")
        self.export( outfile, 0, name_='xds_commands' )
        outfile.close()


    #Only to export the entire XML tree to a Html Page in a file stream on disk
    def outputPageHtml( self, _outfileName ):
        odtStrTitle = "    <span class=\"title\">xds_commands:</span> <br> <br> <br>\n" 
        outfile = open( _outfileName, "w" )
        outfile.write( TEMPLATE_PAGE_P1 % ( odtStrTitle ) )
        self.exportLiteralHtml( outfile, 0, name_='xds_commands' )
        outfile.write( TEMPLATE_PAGE_P2  )
        outfile.close()


    def outputFileHtml( self, _outfileName ):
        self.outputPageHtml( _outfileName )



    #Static method for parsing a string
    def parseString( _inString ):
        doc = minidom.parseString(_inString)
        rootNode = doc.documentElement
        rootObj = xds_commands.factory()
        rootObj.build(rootNode)
        return rootObj
    parseString = staticmethod( parseString ) 


    #Method for marshalling an object
    def marshal( self ):
        oStreamString = StringIO.StringIO()
        oStreamString.write('<?xml version="1.0" ?>\n')
        self.export( oStreamString, 0, name_="xds_commands" )
        oStringXML = oStreamString.getvalue()
        oStreamString.close()
        return oStringXML

    def exportLiteral(self, outfile, level = 0, name_='xds_commands'):
        level += 1
        self.exportLiteralAttributes(outfile, level, name_)
        self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('command=[\n')
        level += 1
        for command in self.command:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(command))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def exportLiteralHtml(self, outfile, level = 0, name_='xds_commands'):
        level += 1
        self.exportLiteralAttributesHtml(outfile, level, name_)
        self.exportLiteralChildrenHtml(outfile, level, name_)
    def exportLiteralAttributesHtml(self, outfile, level, name_):
        pass
    def exportLiteralChildrenHtml(self, outfile, level, name_):
        showIndentHtml(outfile, level)
        outfile.write('command<br>\n')
        level += 1
        for command in self.command:
            showIndentHtml(outfile, level)
            outfile.write('<a  href:"#">%s</a><br>\n' % quote_python(command))
        level -= 1
        showIndentHtml(outfile, level)
        outfile.write('<br>\n')
    def build(self, node_):
        attrs = node_.attributes
        self.buildAttributes(attrs)
        for child_ in node_.childNodes:
            nodeName_ = child_.nodeName.split(':')[-1]
            self.buildChildren(child_, nodeName_)
    def buildAttributes(self, attrs):
        pass
    def buildChildren(self, child_, nodeName_):
        if child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'command':
            command_ = ''
            for text__content_ in child_.childNodes:
                command_ += text__content_.nodeValue
            self.command.append(command_)
# end class xds_commands


class extra_commands(object):
    subclass = None
    def __init__(self, mosflm_commands=None, scala_commands=None, xds_commands=None):
        self.mosflm_commands = mosflm_commands
        self.scala_commands = scala_commands
        self.xds_commands = xds_commands
    def factory(*args_, **kwargs_):
        if extra_commands.subclass:
            return extra_commands.subclass(*args_, **kwargs_)
        else:
            return extra_commands(*args_, **kwargs_)
    factory = staticmethod(factory)
    def getMosflm_commands(self): return self.mosflm_commands
    def setMosflm_commands(self, mosflm_commands): self.mosflm_commands = mosflm_commands
    def getScala_commands(self): return self.scala_commands
    def setScala_commands(self, scala_commands): self.scala_commands = scala_commands
    def getXds_commands(self): return self.xds_commands
    def setXds_commands(self, xds_commands): self.xds_commands = xds_commands
    def export(self, outfile, level = 0, name_='extra_commands'):
        showIndent(outfile, level)
        outfile.write('<%s>\n' % name_)
        self.exportChildren(outfile, level + 1, name_)
        showIndent(outfile, level)
        outfile.write('</%s>\n' % name_)
    def exportAttributes(self, outfile, level, name_='extra_commands'):
        pass
    def exportChildren(self, outfile, level, name_='extra_commands'):
        if self.mosflm_commands:
            self.mosflm_commands.export(outfile, level)
        if self.scala_commands:
            self.scala_commands.export(outfile, level)
        if self.xds_commands:
            self.xds_commands.export(outfile, level)

    #Only to export the entire XML tree to a file stream on disk
    def outputFile( self, _outfileName ):
        outfile = open( _outfileName, "w" )
        outfile.write("<?xml version=\"1.0\" ?>\n")
        self.export( outfile, 0, name_='extra_commands' )
        outfile.close()


    #Only to export the entire XML tree to a Html Page in a file stream on disk
    def outputPageHtml( self, _outfileName ):
        odtStrTitle = "    <span class=\"title\">extra_commands:</span> <br> <br> <br>\n" 
        outfile = open( _outfileName, "w" )
        outfile.write( TEMPLATE_PAGE_P1 % ( odtStrTitle ) )
        self.exportLiteralHtml( outfile, 0, name_='extra_commands' )
        outfile.write( TEMPLATE_PAGE_P2  )
        outfile.close()


    def outputFileHtml( self, _outfileName ):
        self.outputPageHtml( _outfileName )



    #Static method for parsing a string
    def parseString( _inString ):
        doc = minidom.parseString(_inString)
        rootNode = doc.documentElement
        rootObj = extra_commands.factory()
        rootObj.build(rootNode)
        return rootObj
    parseString = staticmethod( parseString ) 


    #Method for marshalling an object
    def marshal( self ):
        oStreamString = StringIO.StringIO()
        oStreamString.write('<?xml version="1.0" ?>\n')
        self.export( oStreamString, 0, name_="extra_commands" )
        oStringXML = oStreamString.getvalue()
        oStreamString.close()
        return oStringXML

    def exportLiteral(self, outfile, level = 0, name_='extra_commands'):
        level += 1
        self.exportLiteralAttributes(outfile, level, name_)
        self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.mosflm_commands:
            showIndent(outfile, level)
            outfile.write('mosflm_commands = mosflm_commands(\n')
            self.mosflm_commands.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.scala_commands:
            showIndent(outfile, level)
            outfile.write('scala_commands = scala_commands(\n')
            self.scala_commands.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.xds_commands:
            showIndent(outfile, level)
            outfile.write('xds_commands = xds_commands(\n')
            self.xds_commands.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
    def exportLiteralHtml(self, outfile, level = 0, name_='extra_commands'):
        level += 1
        self.exportLiteralAttributesHtml(outfile, level, name_)
        self.exportLiteralChildrenHtml(outfile, level, name_)
    def exportLiteralAttributesHtml(self, outfile, level, name_):
        pass
    def exportLiteralChildrenHtml(self, outfile, level, name_):
        if self.mosflm_commands:
            showIndentHtml(outfile, level)
            outfile.write('mosflm_commands<br>\n')
            self.mosflm_commands.exportLiteralHtml(outfile, level)
            showIndentHtml(outfile, level)
            outfile.write('<br>\n')
        if self.scala_commands:
            showIndentHtml(outfile, level)
            outfile.write('scala_commands<br>\n')
            self.scala_commands.exportLiteralHtml(outfile, level)
            showIndentHtml(outfile, level)
            outfile.write('<br>\n')
        if self.xds_commands:
            showIndentHtml(outfile, level)
            outfile.write('xds_commands<br>\n')
            self.xds_commands.exportLiteralHtml(outfile, level)
            showIndentHtml(outfile, level)
            outfile.write('<br>\n')
    def build(self, node_):
        attrs = node_.attributes
        self.buildAttributes(attrs)
        for child_ in node_.childNodes:
            nodeName_ = child_.nodeName.split(':')[-1]
            self.buildChildren(child_, nodeName_)
    def buildAttributes(self, attrs):
        pass
    def buildChildren(self, child_, nodeName_):
        if child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'mosflm_commands':
            obj_ = mosflm_commands.factory()
            obj_.build(child_)
            self.setMosflm_commands(obj_)
        elif child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'scala_commands':
            obj_ = scala_commands.factory()
            obj_.build(child_)
            self.setScala_commands(obj_)
        elif child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'xds_commands':
            obj_ = xds_commands.factory()
            obj_.build(child_)
            self.setXds_commands(obj_)
# end class extra_commands


class status(object):
    subclass = None
    def __init__(self, code='', message=''):
        self.code = code
        self.message = message
    def factory(*args_, **kwargs_):
        if status.subclass:
            return status.subclass(*args_, **kwargs_)
        else:
            return status(*args_, **kwargs_)
    factory = staticmethod(factory)
    def getCode(self): return self.code
    def setCode(self, code): self.code = code
    def getMessage(self): return self.message
    def setMessage(self, message): self.message = message
    def export(self, outfile, level = 0, name_='status'):
        showIndent(outfile, level)
        outfile.write('<%s>\n' % name_)
        self.exportChildren(outfile, level + 1, name_)
        showIndent(outfile, level)
        outfile.write('</%s>\n' % name_)
    def exportAttributes(self, outfile, level, name_='status'):
        pass
    def exportChildren(self, outfile, level, name_='status'):
        showIndent(outfile, level)
        outfile.write('<code>%s</code>\n' % quote_xml(self.getCode()))
        showIndent(outfile, level)
        outfile.write('<message>%s</message>\n' % quote_xml(self.getMessage()))

    #Only to export the entire XML tree to a file stream on disk
    def outputFile( self, _outfileName ):
        outfile = open( _outfileName, "w" )
        outfile.write("<?xml version=\"1.0\" ?>\n")
        self.export( outfile, 0, name_='status' )
        outfile.close()


    #Only to export the entire XML tree to a Html Page in a file stream on disk
    def outputPageHtml( self, _outfileName ):
        odtStrTitle = "    <span class=\"title\">status:</span> <br> <br> <br>\n" 
        outfile = open( _outfileName, "w" )
        outfile.write( TEMPLATE_PAGE_P1 % ( odtStrTitle ) )
        self.exportLiteralHtml( outfile, 0, name_='status' )
        outfile.write( TEMPLATE_PAGE_P2  )
        outfile.close()


    def outputFileHtml( self, _outfileName ):
        self.outputPageHtml( _outfileName )



    #Static method for parsing a string
    def parseString( _inString ):
        doc = minidom.parseString(_inString)
        rootNode = doc.documentElement
        rootObj = status.factory()
        rootObj.build(rootNode)
        return rootObj
    parseString = staticmethod( parseString ) 


    #Method for marshalling an object
    def marshal( self ):
        oStreamString = StringIO.StringIO()
        oStreamString.write('<?xml version="1.0" ?>\n')
        self.export( oStreamString, 0, name_="status" )
        oStringXML = oStreamString.getvalue()
        oStreamString.close()
        return oStringXML

    def exportLiteral(self, outfile, level = 0, name_='status'):
        level += 1
        self.exportLiteralAttributes(outfile, level, name_)
        self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('code = %s,\n' % quote_python(self.getCode()))
        showIndent(outfile, level)
        outfile.write('message = %s,\n' % quote_python(self.getMessage()))
    def exportLiteralHtml(self, outfile, level = 0, name_='status'):
        level += 1
        self.exportLiteralAttributesHtml(outfile, level, name_)
        self.exportLiteralChildrenHtml(outfile, level, name_)
    def exportLiteralAttributesHtml(self, outfile, level, name_):
        pass
    def exportLiteralChildrenHtml(self, outfile, level, name_):
        showIndentHtml(outfile, level)
        outfile.write('code = <a  href:"#">%s</a><br>\n' % quote_python(self.getCode()))
        showIndentHtml(outfile, level)
        outfile.write('message = <a  href:"#">%s</a><br>\n' % quote_python(self.getMessage()))
    def build(self, node_):
        attrs = node_.attributes
        self.buildAttributes(attrs)
        for child_ in node_.childNodes:
            nodeName_ = child_.nodeName.split(':')[-1]
            self.buildChildren(child_, nodeName_)
    def buildAttributes(self, attrs):
        pass
    def buildChildren(self, child_, nodeName_):
        if child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'code':
            code_ = ''
            for text__content_ in child_.childNodes:
                code_ += text__content_.nodeValue
            self.code = code_
        elif child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'message':
            message_ = ''
            for text__content_ in child_.childNodes:
                message_ += text__content_.nodeValue
            self.message = message_
# end class status


class fileinfo(object):
    subclass = None
    def __init__(self, directory='', prefix='', suffix='', template='', run_number=''):
        self.directory = directory
        self.prefix = prefix
        self.suffix = suffix
        self.template = template
        self.run_number = run_number
    def factory(*args_, **kwargs_):
        if fileinfo.subclass:
            return fileinfo.subclass(*args_, **kwargs_)
        else:
            return fileinfo(*args_, **kwargs_)
    factory = staticmethod(factory)
    def getDirectory(self): return self.directory
    def setDirectory(self, directory): self.directory = directory
    def getPrefix(self): return self.prefix
    def setPrefix(self, prefix): self.prefix = prefix
    def getSuffix(self): return self.suffix
    def setSuffix(self, suffix): self.suffix = suffix
    def getTemplate(self): return self.template
    def setTemplate(self, template): self.template = template
    def getRun_number(self): return self.run_number
    def setRun_number(self, run_number): self.run_number = run_number
    def export(self, outfile, level = 0, name_='fileinfo'):
        showIndent(outfile, level)
        outfile.write('<%s>\n' % name_)
        self.exportChildren(outfile, level + 1, name_)
        showIndent(outfile, level)
        outfile.write('</%s>\n' % name_)
    def exportAttributes(self, outfile, level, name_='fileinfo'):
        pass
    def exportChildren(self, outfile, level, name_='fileinfo'):
        showIndent(outfile, level)
        outfile.write('<directory>%s</directory>\n' % quote_xml(self.getDirectory()))
        showIndent(outfile, level)
        outfile.write('<prefix>%s</prefix>\n' % quote_xml(self.getPrefix()))
        showIndent(outfile, level)
        outfile.write('<suffix>%s</suffix>\n' % quote_xml(self.getSuffix()))
        showIndent(outfile, level)
        outfile.write('<template>%s</template>\n' % quote_xml(self.getTemplate()))
        showIndent(outfile, level)
        outfile.write('<run_number>%s</run_number>\n' % quote_xml(self.getRun_number()))

    #Only to export the entire XML tree to a file stream on disk
    def outputFile( self, _outfileName ):
        outfile = open( _outfileName, "w" )
        outfile.write("<?xml version=\"1.0\" ?>\n")
        self.export( outfile, 0, name_='fileinfo' )
        outfile.close()


    #Only to export the entire XML tree to a Html Page in a file stream on disk
    def outputPageHtml( self, _outfileName ):
        odtStrTitle = "    <span class=\"title\">fileinfo:</span> <br> <br> <br>\n" 
        outfile = open( _outfileName, "w" )
        outfile.write( TEMPLATE_PAGE_P1 % ( odtStrTitle ) )
        self.exportLiteralHtml( outfile, 0, name_='fileinfo' )
        outfile.write( TEMPLATE_PAGE_P2  )
        outfile.close()


    def outputFileHtml( self, _outfileName ):
        self.outputPageHtml( _outfileName )



    #Static method for parsing a string
    def parseString( _inString ):
        doc = minidom.parseString(_inString)
        rootNode = doc.documentElement
        rootObj = fileinfo.factory()
        rootObj.build(rootNode)
        return rootObj
    parseString = staticmethod( parseString ) 


    #Method for marshalling an object
    def marshal( self ):
        oStreamString = StringIO.StringIO()
        oStreamString.write('<?xml version="1.0" ?>\n')
        self.export( oStreamString, 0, name_="fileinfo" )
        oStringXML = oStreamString.getvalue()
        oStreamString.close()
        return oStringXML

    def exportLiteral(self, outfile, level = 0, name_='fileinfo'):
        level += 1
        self.exportLiteralAttributes(outfile, level, name_)
        self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('directory = %s,\n' % quote_python(self.getDirectory()))
        showIndent(outfile, level)
        outfile.write('prefix = %s,\n' % quote_python(self.getPrefix()))
        showIndent(outfile, level)
        outfile.write('suffix = %s,\n' % quote_python(self.getSuffix()))
        showIndent(outfile, level)
        outfile.write('template = %s,\n' % quote_python(self.getTemplate()))
        showIndent(outfile, level)
        outfile.write('run_number = %s,\n' % quote_python(self.getRun_number()))
    def exportLiteralHtml(self, outfile, level = 0, name_='fileinfo'):
        level += 1
        self.exportLiteralAttributesHtml(outfile, level, name_)
        self.exportLiteralChildrenHtml(outfile, level, name_)
    def exportLiteralAttributesHtml(self, outfile, level, name_):
        pass
    def exportLiteralChildrenHtml(self, outfile, level, name_):
        showIndentHtml(outfile, level)
        outfile.write('directory = <a  href:"#">%s</a><br>\n' % quote_python(self.getDirectory()))
        showIndentHtml(outfile, level)
        outfile.write('prefix = <a  href:"#">%s</a><br>\n' % quote_python(self.getPrefix()))
        showIndentHtml(outfile, level)
        outfile.write('suffix = <a  href:"#">%s</a><br>\n' % quote_python(self.getSuffix()))
        showIndentHtml(outfile, level)
        outfile.write('template = <a  href:"#">%s</a><br>\n' % quote_python(self.getTemplate()))
        showIndentHtml(outfile, level)
        outfile.write('run_number = <a  href:"#">%s</a><br>\n' % quote_python(self.getRun_number()))
    def build(self, node_):
        attrs = node_.attributes
        self.buildAttributes(attrs)
        for child_ in node_.childNodes:
            nodeName_ = child_.nodeName.split(':')[-1]
            self.buildChildren(child_, nodeName_)
    def buildAttributes(self, attrs):
        pass
    def buildChildren(self, child_, nodeName_):
        if child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'directory':
            directory_ = ''
            for text__content_ in child_.childNodes:
                directory_ += text__content_.nodeValue
            self.directory = directory_
        elif child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'prefix':
            prefix_ = ''
            for text__content_ in child_.childNodes:
                prefix_ += text__content_.nodeValue
            self.prefix = prefix_
        elif child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'suffix':
            suffix_ = ''
            for text__content_ in child_.childNodes:
                suffix_ += text__content_.nodeValue
            self.suffix = suffix_
        elif child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'template':
            template_ = ''
            for text__content_ in child_.childNodes:
                template_ += text__content_.nodeValue
            self.template = template_
        elif child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'run_number':
            run_number_ = ''
            for text__content_ in child_.childNodes:
                run_number_ += text__content_.nodeValue
            self.run_number = run_number_
# end class fileinfo


class oscillation_sequence(object):
    subclass = None
    def __init__(self, start=0.0, end=0.0, range=0.0, number_of_images='', overlap=0.0, exposure_time=0.0, start_image_number='', number_of_passes=''):
        self.start = start
        self.end = end
        self.range = range
        self.number_of_images = number_of_images
        self.overlap = overlap
        self.exposure_time = exposure_time
        self.start_image_number = start_image_number
        self.number_of_passes = number_of_passes
    def factory(*args_, **kwargs_):
        if oscillation_sequence.subclass:
            return oscillation_sequence.subclass(*args_, **kwargs_)
        else:
            return oscillation_sequence(*args_, **kwargs_)
    factory = staticmethod(factory)
    def getStart(self): return self.start
    def setStart(self, start): self.start = start
    def getEnd(self): return self.end
    def setEnd(self, end): self.end = end
    def getRange(self): return self.range
    def setRange(self, range): self.range = range
    def getNumber_of_images(self): return self.number_of_images
    def setNumber_of_images(self, number_of_images): self.number_of_images = number_of_images
    def getOverlap(self): return self.overlap
    def setOverlap(self, overlap): self.overlap = overlap
    def getExposure_time(self): return self.exposure_time
    def setExposure_time(self, exposure_time): self.exposure_time = exposure_time
    def getStart_image_number(self): return self.start_image_number
    def setStart_image_number(self, start_image_number): self.start_image_number = start_image_number
    def getNumber_of_passes(self): return self.number_of_passes
    def setNumber_of_passes(self, number_of_passes): self.number_of_passes = number_of_passes
    def export(self, outfile, level = 0, name_='oscillation_sequence'):
        showIndent(outfile, level)
        outfile.write('<%s>\n' % name_)
        self.exportChildren(outfile, level + 1, name_)
        showIndent(outfile, level)
        outfile.write('</%s>\n' % name_)
    def exportAttributes(self, outfile, level, name_='oscillation_sequence'):
        pass
    def exportChildren(self, outfile, level, name_='oscillation_sequence'):
        showIndent(outfile, level)
        outfile.write('<start>%e</start>\n' % self.getStart())
        showIndent(outfile, level)
        outfile.write('<end>%e</end>\n' % self.getEnd())
        showIndent(outfile, level)
        outfile.write('<range>%e</range>\n' % self.getRange())
        showIndent(outfile, level)
        outfile.write('<number_of_images>%s</number_of_images>\n' % quote_xml(self.getNumber_of_images()))
        showIndent(outfile, level)
        outfile.write('<overlap>%e</overlap>\n' % self.getOverlap())
        showIndent(outfile, level)
        outfile.write('<exposure_time>%e</exposure_time>\n' % self.getExposure_time())
        showIndent(outfile, level)
        outfile.write('<start_image_number>%s</start_image_number>\n' % quote_xml(self.getStart_image_number()))
        showIndent(outfile, level)
        outfile.write('<number_of_passes>%s</number_of_passes>\n' % quote_xml(self.getNumber_of_passes()))

    #Only to export the entire XML tree to a file stream on disk
    def outputFile( self, _outfileName ):
        outfile = open( _outfileName, "w" )
        outfile.write("<?xml version=\"1.0\" ?>\n")
        self.export( outfile, 0, name_='oscillation_sequence' )
        outfile.close()


    #Only to export the entire XML tree to a Html Page in a file stream on disk
    def outputPageHtml( self, _outfileName ):
        odtStrTitle = "    <span class=\"title\">oscillation_sequence:</span> <br> <br> <br>\n" 
        outfile = open( _outfileName, "w" )
        outfile.write( TEMPLATE_PAGE_P1 % ( odtStrTitle ) )
        self.exportLiteralHtml( outfile, 0, name_='oscillation_sequence' )
        outfile.write( TEMPLATE_PAGE_P2  )
        outfile.close()


    def outputFileHtml( self, _outfileName ):
        self.outputPageHtml( _outfileName )



    #Static method for parsing a string
    def parseString( _inString ):
        doc = minidom.parseString(_inString)
        rootNode = doc.documentElement
        rootObj = oscillation_sequence.factory()
        rootObj.build(rootNode)
        return rootObj
    parseString = staticmethod( parseString ) 


    #Method for marshalling an object
    def marshal( self ):
        oStreamString = StringIO.StringIO()
        oStreamString.write('<?xml version="1.0" ?>\n')
        self.export( oStreamString, 0, name_="oscillation_sequence" )
        oStringXML = oStreamString.getvalue()
        oStreamString.close()
        return oStringXML

    def exportLiteral(self, outfile, level = 0, name_='oscillation_sequence'):
        level += 1
        self.exportLiteralAttributes(outfile, level, name_)
        self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('start = %e,\n' % self.getStart())
        showIndent(outfile, level)
        outfile.write('end = %e,\n' % self.getEnd())
        showIndent(outfile, level)
        outfile.write('range = %e,\n' % self.getRange())
        showIndent(outfile, level)
        outfile.write('number_of_images = %s,\n' % quote_python(self.getNumber_of_images()))
        showIndent(outfile, level)
        outfile.write('overlap = %e,\n' % self.getOverlap())
        showIndent(outfile, level)
        outfile.write('exposure_time = %e,\n' % self.getExposure_time())
        showIndent(outfile, level)
        outfile.write('start_image_number = %s,\n' % quote_python(self.getStart_image_number()))
        showIndent(outfile, level)
        outfile.write('number_of_passes = %s,\n' % quote_python(self.getNumber_of_passes()))
    def exportLiteralHtml(self, outfile, level = 0, name_='oscillation_sequence'):
        level += 1
        self.exportLiteralAttributesHtml(outfile, level, name_)
        self.exportLiteralChildrenHtml(outfile, level, name_)
    def exportLiteralAttributesHtml(self, outfile, level, name_):
        pass
    def exportLiteralChildrenHtml(self, outfile, level, name_):
        showIndentHtml(outfile, level)
        outfile.write('start = <a  href:"#">%e</a><br>\n' % self.getStart())
        showIndentHtml(outfile, level)
        outfile.write('end = <a  href:"#">%e</a><br>\n' % self.getEnd())
        showIndentHtml(outfile, level)
        outfile.write('range = <a  href:"#">%e</a><br>\n' % self.getRange())
        showIndentHtml(outfile, level)
        outfile.write('number_of_images = <a  href:"#">%s</a><br>\n' % quote_python(self.getNumber_of_images()))
        showIndentHtml(outfile, level)
        outfile.write('overlap = <a  href:"#">%e</a><br>\n' % self.getOverlap())
        showIndentHtml(outfile, level)
        outfile.write('exposure_time = <a  href:"#">%e</a><br>\n' % self.getExposure_time())
        showIndentHtml(outfile, level)
        outfile.write('start_image_number = <a  href:"#">%s</a><br>\n' % quote_python(self.getStart_image_number()))
        showIndentHtml(outfile, level)
        outfile.write('number_of_passes = <a  href:"#">%s</a><br>\n' % quote_python(self.getNumber_of_passes()))
    def build(self, node_):
        attrs = node_.attributes
        self.buildAttributes(attrs)
        for child_ in node_.childNodes:
            nodeName_ = child_.nodeName.split(':')[-1]
            self.buildChildren(child_, nodeName_)
    def buildAttributes(self, attrs):
        pass
    def buildChildren(self, child_, nodeName_):
        if child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'start':
            if child_.firstChild:
                sval_ = child_.firstChild.nodeValue
                try:
                    fval_ = float(sval_)
                except ValueError:
                    raise ValueError('requires float (or double) -- %s' % child_.toxml())
                self.start = fval_
        elif child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'end':
            if child_.firstChild:
                sval_ = child_.firstChild.nodeValue
                try:
                    fval_ = float(sval_)
                except ValueError:
                    raise ValueError('requires float (or double) -- %s' % child_.toxml())
                self.end = fval_
        elif child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'range':
            if child_.firstChild:
                sval_ = child_.firstChild.nodeValue
                try:
                    fval_ = float(sval_)
                except ValueError:
                    raise ValueError('requires float (or double) -- %s' % child_.toxml())
                self.range = fval_
        elif child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'number_of_images':
            number_of_images_ = ''
            for text__content_ in child_.childNodes:
                number_of_images_ += text__content_.nodeValue
            self.number_of_images = number_of_images_
        elif child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'overlap':
            if child_.firstChild:
                sval_ = child_.firstChild.nodeValue
                try:
                    fval_ = float(sval_)
                except ValueError:
                    raise ValueError('requires float (or double) -- %s' % child_.toxml())
                self.overlap = fval_
        elif child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'exposure_time':
            if child_.firstChild:
                sval_ = child_.firstChild.nodeValue
                try:
                    fval_ = float(sval_)
                except ValueError:
                    raise ValueError('requires float (or double) -- %s' % child_.toxml())
                self.exposure_time = fval_
        elif child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'start_image_number':
            start_image_number_ = ''
            for text__content_ in child_.childNodes:
                start_image_number_ += text__content_.nodeValue
            self.start_image_number = start_image_number_
        elif child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'number_of_passes':
            number_of_passes_ = ''
            for text__content_ in child_.childNodes:
                number_of_passes_ += text__content_.nodeValue
            self.number_of_passes = number_of_passes_
# end class oscillation_sequence


class detector(object):
    subclass = None
    def __init__(self, ttype='', suffix=''):
        self.ttype = ttype
        self.suffix = suffix
    def factory(*args_, **kwargs_):
        if detector.subclass:
            return detector.subclass(*args_, **kwargs_)
        else:
            return detector(*args_, **kwargs_)
    factory = staticmethod(factory)
    def getType(self): return self.ttype
    def setType(self, ttype): self.ttype = ttype
    def getSuffix(self): return self.suffix
    def setSuffix(self, suffix): self.suffix = suffix
    def export(self, outfile, level = 0, name_='detector'):
        showIndent(outfile, level)
        outfile.write('<%s>\n' % name_)
        self.exportChildren(outfile, level + 1, name_)
        showIndent(outfile, level)
        outfile.write('</%s>\n' % name_)
    def exportAttributes(self, outfile, level, name_='detector'):
        pass
    def exportChildren(self, outfile, level, name_='detector'):
        showIndent(outfile, level)
        outfile.write('<type>%s</type>\n' % quote_xml(self.getType()))
        showIndent(outfile, level)
        outfile.write('<suffix>%s</suffix>\n' % quote_xml(self.getSuffix()))

    #Only to export the entire XML tree to a file stream on disk
    def outputFile( self, _outfileName ):
        outfile = open( _outfileName, "w" )
        outfile.write("<?xml version=\"1.0\" ?>\n")
        self.export( outfile, 0, name_='detector' )
        outfile.close()


    #Only to export the entire XML tree to a Html Page in a file stream on disk
    def outputPageHtml( self, _outfileName ):
        odtStrTitle = "    <span class=\"title\">detector:</span> <br> <br> <br>\n" 
        outfile = open( _outfileName, "w" )
        outfile.write( TEMPLATE_PAGE_P1 % ( odtStrTitle ) )
        self.exportLiteralHtml( outfile, 0, name_='detector' )
        outfile.write( TEMPLATE_PAGE_P2  )
        outfile.close()


    def outputFileHtml( self, _outfileName ):
        self.outputPageHtml( _outfileName )



    #Static method for parsing a string
    def parseString( _inString ):
        doc = minidom.parseString(_inString)
        rootNode = doc.documentElement
        rootObj = detector.factory()
        rootObj.build(rootNode)
        return rootObj
    parseString = staticmethod( parseString ) 


    #Method for marshalling an object
    def marshal( self ):
        oStreamString = StringIO.StringIO()
        oStreamString.write('<?xml version="1.0" ?>\n')
        self.export( oStreamString, 0, name_="detector" )
        oStringXML = oStreamString.getvalue()
        oStreamString.close()
        return oStringXML

    def exportLiteral(self, outfile, level = 0, name_='detector'):
        level += 1
        self.exportLiteralAttributes(outfile, level, name_)
        self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('ttype = %s,\n' % quote_python(self.getType()))
        showIndent(outfile, level)
        outfile.write('suffix = %s,\n' % quote_python(self.getSuffix()))
    def exportLiteralHtml(self, outfile, level = 0, name_='detector'):
        level += 1
        self.exportLiteralAttributesHtml(outfile, level, name_)
        self.exportLiteralChildrenHtml(outfile, level, name_)
    def exportLiteralAttributesHtml(self, outfile, level, name_):
        pass
    def exportLiteralChildrenHtml(self, outfile, level, name_):
        showIndentHtml(outfile, level)
        outfile.write('ttype = <a  href:"#">%s</a><br>\n' % quote_python(self.getType()))
        showIndentHtml(outfile, level)
        outfile.write('suffix = <a  href:"#">%s</a><br>\n' % quote_python(self.getSuffix()))
    def build(self, node_):
        attrs = node_.attributes
        self.buildAttributes(attrs)
        for child_ in node_.childNodes:
            nodeName_ = child_.nodeName.split(':')[-1]
            self.buildChildren(child_, nodeName_)
    def buildAttributes(self, attrs):
        pass
    def buildChildren(self, child_, nodeName_):
        if child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'type':
            type_ = ''
            for text__content_ in child_.childNodes:
                type_ += text__content_.nodeValue
            self.ttype = type_
        elif child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'suffix':
            suffix_ = ''
            for text__content_ in child_.childNodes:
                suffix_ += text__content_.nodeValue
            self.suffix = suffix_
# end class detector


class beam(object):
    subclass = None
    def __init__(self, x=0.0, y=0.0):
        self.x = x
        self.y = y
    def factory(*args_, **kwargs_):
        if beam.subclass:
            return beam.subclass(*args_, **kwargs_)
        else:
            return beam(*args_, **kwargs_)
    factory = staticmethod(factory)
    def getX(self): return self.x
    def setX(self, x): self.x = x
    def getY(self): return self.y
    def setY(self, y): self.y = y
    def export(self, outfile, level = 0, name_='beam'):
        showIndent(outfile, level)
        outfile.write('<%s>\n' % name_)
        self.exportChildren(outfile, level + 1, name_)
        showIndent(outfile, level)
        outfile.write('</%s>\n' % name_)
    def exportAttributes(self, outfile, level, name_='beam'):
        pass
    def exportChildren(self, outfile, level, name_='beam'):
        showIndent(outfile, level)
        outfile.write('<x>%e</x>\n' % self.getX())
        showIndent(outfile, level)
        outfile.write('<y>%e</y>\n' % self.getY())

    #Only to export the entire XML tree to a file stream on disk
    def outputFile( self, _outfileName ):
        outfile = open( _outfileName, "w" )
        outfile.write("<?xml version=\"1.0\" ?>\n")
        self.export( outfile, 0, name_='beam' )
        outfile.close()


    #Only to export the entire XML tree to a Html Page in a file stream on disk
    def outputPageHtml( self, _outfileName ):
        odtStrTitle = "    <span class=\"title\">beam:</span> <br> <br> <br>\n" 
        outfile = open( _outfileName, "w" )
        outfile.write( TEMPLATE_PAGE_P1 % ( odtStrTitle ) )
        self.exportLiteralHtml( outfile, 0, name_='beam' )
        outfile.write( TEMPLATE_PAGE_P2  )
        outfile.close()


    def outputFileHtml( self, _outfileName ):
        self.outputPageHtml( _outfileName )



    #Static method for parsing a string
    def parseString( _inString ):
        doc = minidom.parseString(_inString)
        rootNode = doc.documentElement
        rootObj = beam.factory()
        rootObj.build(rootNode)
        return rootObj
    parseString = staticmethod( parseString ) 


    #Method for marshalling an object
    def marshal( self ):
        oStreamString = StringIO.StringIO()
        oStreamString.write('<?xml version="1.0" ?>\n')
        self.export( oStreamString, 0, name_="beam" )
        oStringXML = oStreamString.getvalue()
        oStreamString.close()
        return oStringXML

    def exportLiteral(self, outfile, level = 0, name_='beam'):
        level += 1
        self.exportLiteralAttributes(outfile, level, name_)
        self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('x = %e,\n' % self.getX())
        showIndent(outfile, level)
        outfile.write('y = %e,\n' % self.getY())
    def exportLiteralHtml(self, outfile, level = 0, name_='beam'):
        level += 1
        self.exportLiteralAttributesHtml(outfile, level, name_)
        self.exportLiteralChildrenHtml(outfile, level, name_)
    def exportLiteralAttributesHtml(self, outfile, level, name_):
        pass
    def exportLiteralChildrenHtml(self, outfile, level, name_):
        showIndentHtml(outfile, level)
        outfile.write('x = <a  href:"#">%e</a><br>\n' % self.getX())
        showIndentHtml(outfile, level)
        outfile.write('y = <a  href:"#">%e</a><br>\n' % self.getY())
    def build(self, node_):
        attrs = node_.attributes
        self.buildAttributes(attrs)
        for child_ in node_.childNodes:
            nodeName_ = child_.nodeName.split(':')[-1]
            self.buildChildren(child_, nodeName_)
    def buildAttributes(self, attrs):
        pass
    def buildChildren(self, child_, nodeName_):
        if child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'x':
            if child_.firstChild:
                sval_ = child_.firstChild.nodeValue
                try:
                    fval_ = float(sval_)
                except ValueError:
                    raise ValueError('requires float (or double) -- %s' % child_.toxml())
                self.x = fval_
        elif child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'y':
            if child_.firstChild:
                sval_ = child_.firstChild.nodeValue
                try:
                    fval_ = float(sval_)
                except ValueError:
                    raise ValueError('requires float (or double) -- %s' % child_.toxml())
                self.y = fval_
# end class beam


class cell(object):
    subclass = None
    def __init__(self, a=0.0, b=0.0, c=0.0, alpha=0.0, beta=0.0, gamma=0.0):
        self.a = a
        self.b = b
        self.c = c
        self.alpha = alpha
        self.beta = beta
        self.gamma = gamma
    def factory(*args_, **kwargs_):
        if cell.subclass:
            return cell.subclass(*args_, **kwargs_)
        else:
            return cell(*args_, **kwargs_)
    factory = staticmethod(factory)
    def getA(self): return self.a
    def setA(self, a): self.a = a
    def getB(self): return self.b
    def setB(self, b): self.b = b
    def getC(self): return self.c
    def setC(self, c): self.c = c
    def getAlpha(self): return self.alpha
    def setAlpha(self, alpha): self.alpha = alpha
    def getBeta(self): return self.beta
    def setBeta(self, beta): self.beta = beta
    def getGamma(self): return self.gamma
    def setGamma(self, gamma): self.gamma = gamma
    def export(self, outfile, level = 0, name_='cell'):
        showIndent(outfile, level)
        outfile.write('<%s>\n' % name_)
        self.exportChildren(outfile, level + 1, name_)
        showIndent(outfile, level)
        outfile.write('</%s>\n' % name_)
    def exportAttributes(self, outfile, level, name_='cell'):
        pass
    def exportChildren(self, outfile, level, name_='cell'):
        showIndent(outfile, level)
        outfile.write('<a>%e</a>\n' % self.getA())
        showIndent(outfile, level)
        outfile.write('<b>%e</b>\n' % self.getB())
        showIndent(outfile, level)
        outfile.write('<c>%e</c>\n' % self.getC())
        showIndent(outfile, level)
        outfile.write('<alpha>%e</alpha>\n' % self.getAlpha())
        showIndent(outfile, level)
        outfile.write('<beta>%e</beta>\n' % self.getBeta())
        showIndent(outfile, level)
        outfile.write('<gamma>%e</gamma>\n' % self.getGamma())

    #Only to export the entire XML tree to a file stream on disk
    def outputFile( self, _outfileName ):
        outfile = open( _outfileName, "w" )
        outfile.write("<?xml version=\"1.0\" ?>\n")
        self.export( outfile, 0, name_='cell' )
        outfile.close()


    #Only to export the entire XML tree to a Html Page in a file stream on disk
    def outputPageHtml( self, _outfileName ):
        odtStrTitle = "    <span class=\"title\">cell:</span> <br> <br> <br>\n" 
        outfile = open( _outfileName, "w" )
        outfile.write( TEMPLATE_PAGE_P1 % ( odtStrTitle ) )
        self.exportLiteralHtml( outfile, 0, name_='cell' )
        outfile.write( TEMPLATE_PAGE_P2  )
        outfile.close()


    def outputFileHtml( self, _outfileName ):
        self.outputPageHtml( _outfileName )



    #Static method for parsing a string
    def parseString( _inString ):
        doc = minidom.parseString(_inString)
        rootNode = doc.documentElement
        rootObj = cell.factory()
        rootObj.build(rootNode)
        return rootObj
    parseString = staticmethod( parseString ) 


    #Method for marshalling an object
    def marshal( self ):
        oStreamString = StringIO.StringIO()
        oStreamString.write('<?xml version="1.0" ?>\n')
        self.export( oStreamString, 0, name_="cell" )
        oStringXML = oStreamString.getvalue()
        oStreamString.close()
        return oStringXML

    def exportLiteral(self, outfile, level = 0, name_='cell'):
        level += 1
        self.exportLiteralAttributes(outfile, level, name_)
        self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('a = %e,\n' % self.getA())
        showIndent(outfile, level)
        outfile.write('b = %e,\n' % self.getB())
        showIndent(outfile, level)
        outfile.write('c = %e,\n' % self.getC())
        showIndent(outfile, level)
        outfile.write('alpha = %e,\n' % self.getAlpha())
        showIndent(outfile, level)
        outfile.write('beta = %e,\n' % self.getBeta())
        showIndent(outfile, level)
        outfile.write('gamma = %e,\n' % self.getGamma())
    def exportLiteralHtml(self, outfile, level = 0, name_='cell'):
        level += 1
        self.exportLiteralAttributesHtml(outfile, level, name_)
        self.exportLiteralChildrenHtml(outfile, level, name_)
    def exportLiteralAttributesHtml(self, outfile, level, name_):
        pass
    def exportLiteralChildrenHtml(self, outfile, level, name_):
        showIndentHtml(outfile, level)
        outfile.write('a = <a  href:"#">%e</a><br>\n' % self.getA())
        showIndentHtml(outfile, level)
        outfile.write('b = <a  href:"#">%e</a><br>\n' % self.getB())
        showIndentHtml(outfile, level)
        outfile.write('c = <a  href:"#">%e</a><br>\n' % self.getC())
        showIndentHtml(outfile, level)
        outfile.write('alpha = <a  href:"#">%e</a><br>\n' % self.getAlpha())
        showIndentHtml(outfile, level)
        outfile.write('beta = <a  href:"#">%e</a><br>\n' % self.getBeta())
        showIndentHtml(outfile, level)
        outfile.write('gamma = <a  href:"#">%e</a><br>\n' % self.getGamma())
    def build(self, node_):
        attrs = node_.attributes
        self.buildAttributes(attrs)
        for child_ in node_.childNodes:
            nodeName_ = child_.nodeName.split(':')[-1]
            self.buildChildren(child_, nodeName_)
    def buildAttributes(self, attrs):
        pass
    def buildChildren(self, child_, nodeName_):
        if child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'a':
            if child_.firstChild:
                sval_ = child_.firstChild.nodeValue
                try:
                    fval_ = float(sval_)
                except ValueError:
                    raise ValueError('requires float (or double) -- %s' % child_.toxml())
                self.a = fval_
        elif child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'b':
            if child_.firstChild:
                sval_ = child_.firstChild.nodeValue
                try:
                    fval_ = float(sval_)
                except ValueError:
                    raise ValueError('requires float (or double) -- %s' % child_.toxml())
                self.b = fval_
        elif child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'c':
            if child_.firstChild:
                sval_ = child_.firstChild.nodeValue
                try:
                    fval_ = float(sval_)
                except ValueError:
                    raise ValueError('requires float (or double) -- %s' % child_.toxml())
                self.c = fval_
        elif child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'alpha':
            if child_.firstChild:
                sval_ = child_.firstChild.nodeValue
                try:
                    fval_ = float(sval_)
                except ValueError:
                    raise ValueError('requires float (or double) -- %s' % child_.toxml())
                self.alpha = fval_
        elif child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'beta':
            if child_.firstChild:
                sval_ = child_.firstChild.nodeValue
                try:
                    fval_ = float(sval_)
                except ValueError:
                    raise ValueError('requires float (or double) -- %s' % child_.toxml())
                self.beta = fval_
        elif child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'gamma':
            if child_.firstChild:
                sval_ = child_.firstChild.nodeValue
                try:
                    fval_ = float(sval_)
                except ValueError:
                    raise ValueError('requires float (or double) -- %s' % child_.toxml())
                self.gamma = fval_
# end class cell


class experiment(object):
    subclass = None
    def __init__(self, wavelength=0.0, distance=0.0, resolution=None):
        self.wavelength = wavelength
        self.distance = distance
        self.resolution = resolution
    def factory(*args_, **kwargs_):
        if experiment.subclass:
            return experiment.subclass(*args_, **kwargs_)
        else:
            return experiment(*args_, **kwargs_)
    factory = staticmethod(factory)
    def getWavelength(self): return self.wavelength
    def setWavelength(self, wavelength): self.wavelength = wavelength
    def getDistance(self): return self.distance
    def setDistance(self, distance): self.distance = distance
    def getResolution(self): return self.resolution
    def setResolution(self, resolution): self.resolution = resolution
    def export(self, outfile, level = 0, name_='experiment'):
        showIndent(outfile, level)
        outfile.write('<%s>\n' % name_)
        self.exportChildren(outfile, level + 1, name_)
        showIndent(outfile, level)
        outfile.write('</%s>\n' % name_)
    def exportAttributes(self, outfile, level, name_='experiment'):
        pass
    def exportChildren(self, outfile, level, name_='experiment'):
        showIndent(outfile, level)
        outfile.write('<wavelength>%e</wavelength>\n' % self.getWavelength())
        showIndent(outfile, level)
        outfile.write('<distance>%e</distance>\n' % self.getDistance())
        if self.resolution:
            self.resolution.export(outfile, level)

    #Only to export the entire XML tree to a file stream on disk
    def outputFile( self, _outfileName ):
        outfile = open( _outfileName, "w" )
        outfile.write("<?xml version=\"1.0\" ?>\n")
        self.export( outfile, 0, name_='experiment' )
        outfile.close()


    #Only to export the entire XML tree to a Html Page in a file stream on disk
    def outputPageHtml( self, _outfileName ):
        odtStrTitle = "    <span class=\"title\">experiment:</span> <br> <br> <br>\n" 
        outfile = open( _outfileName, "w" )
        outfile.write( TEMPLATE_PAGE_P1 % ( odtStrTitle ) )
        self.exportLiteralHtml( outfile, 0, name_='experiment' )
        outfile.write( TEMPLATE_PAGE_P2  )
        outfile.close()


    def outputFileHtml( self, _outfileName ):
        self.outputPageHtml( _outfileName )



    #Static method for parsing a string
    def parseString( _inString ):
        doc = minidom.parseString(_inString)
        rootNode = doc.documentElement
        rootObj = experiment.factory()
        rootObj.build(rootNode)
        return rootObj
    parseString = staticmethod( parseString ) 


    #Method for marshalling an object
    def marshal( self ):
        oStreamString = StringIO.StringIO()
        oStreamString.write('<?xml version="1.0" ?>\n')
        self.export( oStreamString, 0, name_="experiment" )
        oStringXML = oStreamString.getvalue()
        oStreamString.close()
        return oStringXML

    def exportLiteral(self, outfile, level = 0, name_='experiment'):
        level += 1
        self.exportLiteralAttributes(outfile, level, name_)
        self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('wavelength = %e,\n' % self.getWavelength())
        showIndent(outfile, level)
        outfile.write('distance = %e,\n' % self.getDistance())
        if self.resolution:
            showIndent(outfile, level)
            outfile.write('resolution = resolution(\n')
            self.resolution.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
    def exportLiteralHtml(self, outfile, level = 0, name_='experiment'):
        level += 1
        self.exportLiteralAttributesHtml(outfile, level, name_)
        self.exportLiteralChildrenHtml(outfile, level, name_)
    def exportLiteralAttributesHtml(self, outfile, level, name_):
        pass
    def exportLiteralChildrenHtml(self, outfile, level, name_):
        showIndentHtml(outfile, level)
        outfile.write('wavelength = <a  href:"#">%e</a><br>\n' % self.getWavelength())
        showIndentHtml(outfile, level)
        outfile.write('distance = <a  href:"#">%e</a><br>\n' % self.getDistance())
        if self.resolution:
            showIndentHtml(outfile, level)
            outfile.write('resolution<br>\n')
            self.resolution.exportLiteralHtml(outfile, level)
            showIndentHtml(outfile, level)
            outfile.write('<br>\n')
    def build(self, node_):
        attrs = node_.attributes
        self.buildAttributes(attrs)
        for child_ in node_.childNodes:
            nodeName_ = child_.nodeName.split(':')[-1]
            self.buildChildren(child_, nodeName_)
    def buildAttributes(self, attrs):
        pass
    def buildChildren(self, child_, nodeName_):
        if child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'wavelength':
            if child_.firstChild:
                sval_ = child_.firstChild.nodeValue
                try:
                    fval_ = float(sval_)
                except ValueError:
                    raise ValueError('requires float (or double) -- %s' % child_.toxml())
                self.wavelength = fval_
        elif child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'distance':
            if child_.firstChild:
                sval_ = child_.firstChild.nodeValue
                try:
                    fval_ = float(sval_)
                except ValueError:
                    raise ValueError('requires float (or double) -- %s' % child_.toxml())
                self.distance = fval_
        elif child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'resolution':
            obj_ = resolution.factory()
            obj_.build(child_)
            self.setResolution(obj_)
# end class experiment


class matrix(object):
    subclass = None
    def __init__(self, e11=0.0, e12=0.0, e13=0.0, e21=0.0, e22=0.0, e23=0.0, e31=0.0, e32=0.0, e33=0.0):
        self.e11 = e11
        self.e12 = e12
        self.e13 = e13
        self.e21 = e21
        self.e22 = e22
        self.e23 = e23
        self.e31 = e31
        self.e32 = e32
        self.e33 = e33
    def factory(*args_, **kwargs_):
        if matrix.subclass:
            return matrix.subclass(*args_, **kwargs_)
        else:
            return matrix(*args_, **kwargs_)
    factory = staticmethod(factory)
    def getE11(self): return self.e11
    def setE11(self, e11): self.e11 = e11
    def getE12(self): return self.e12
    def setE12(self, e12): self.e12 = e12
    def getE13(self): return self.e13
    def setE13(self, e13): self.e13 = e13
    def getE21(self): return self.e21
    def setE21(self, e21): self.e21 = e21
    def getE22(self): return self.e22
    def setE22(self, e22): self.e22 = e22
    def getE23(self): return self.e23
    def setE23(self, e23): self.e23 = e23
    def getE31(self): return self.e31
    def setE31(self, e31): self.e31 = e31
    def getE32(self): return self.e32
    def setE32(self, e32): self.e32 = e32
    def getE33(self): return self.e33
    def setE33(self, e33): self.e33 = e33
    def export(self, outfile, level = 0, name_='matrix'):
        showIndent(outfile, level)
        outfile.write('<%s>\n' % name_)
        self.exportChildren(outfile, level + 1, name_)
        showIndent(outfile, level)
        outfile.write('</%s>\n' % name_)
    def exportAttributes(self, outfile, level, name_='matrix'):
        pass
    def exportChildren(self, outfile, level, name_='matrix'):
        showIndent(outfile, level)
        outfile.write('<e11>%e</e11>\n' % self.getE11())
        showIndent(outfile, level)
        outfile.write('<e12>%e</e12>\n' % self.getE12())
        showIndent(outfile, level)
        outfile.write('<e13>%e</e13>\n' % self.getE13())
        showIndent(outfile, level)
        outfile.write('<e21>%e</e21>\n' % self.getE21())
        showIndent(outfile, level)
        outfile.write('<e22>%e</e22>\n' % self.getE22())
        showIndent(outfile, level)
        outfile.write('<e23>%e</e23>\n' % self.getE23())
        showIndent(outfile, level)
        outfile.write('<e31>%e</e31>\n' % self.getE31())
        showIndent(outfile, level)
        outfile.write('<e32>%e</e32>\n' % self.getE32())
        showIndent(outfile, level)
        outfile.write('<e33>%e</e33>\n' % self.getE33())

    #Only to export the entire XML tree to a file stream on disk
    def outputFile( self, _outfileName ):
        outfile = open( _outfileName, "w" )
        outfile.write("<?xml version=\"1.0\" ?>\n")
        self.export( outfile, 0, name_='matrix' )
        outfile.close()


    #Only to export the entire XML tree to a Html Page in a file stream on disk
    def outputPageHtml( self, _outfileName ):
        odtStrTitle = "    <span class=\"title\">matrix:</span> <br> <br> <br>\n" 
        outfile = open( _outfileName, "w" )
        outfile.write( TEMPLATE_PAGE_P1 % ( odtStrTitle ) )
        self.exportLiteralHtml( outfile, 0, name_='matrix' )
        outfile.write( TEMPLATE_PAGE_P2  )
        outfile.close()


    def outputFileHtml( self, _outfileName ):
        self.outputPageHtml( _outfileName )



    #Static method for parsing a string
    def parseString( _inString ):
        doc = minidom.parseString(_inString)
        rootNode = doc.documentElement
        rootObj = matrix.factory()
        rootObj.build(rootNode)
        return rootObj
    parseString = staticmethod( parseString ) 


    #Method for marshalling an object
    def marshal( self ):
        oStreamString = StringIO.StringIO()
        oStreamString.write('<?xml version="1.0" ?>\n')
        self.export( oStreamString, 0, name_="matrix" )
        oStringXML = oStreamString.getvalue()
        oStreamString.close()
        return oStringXML

    def exportLiteral(self, outfile, level = 0, name_='matrix'):
        level += 1
        self.exportLiteralAttributes(outfile, level, name_)
        self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('e11 = %e,\n' % self.getE11())
        showIndent(outfile, level)
        outfile.write('e12 = %e,\n' % self.getE12())
        showIndent(outfile, level)
        outfile.write('e13 = %e,\n' % self.getE13())
        showIndent(outfile, level)
        outfile.write('e21 = %e,\n' % self.getE21())
        showIndent(outfile, level)
        outfile.write('e22 = %e,\n' % self.getE22())
        showIndent(outfile, level)
        outfile.write('e23 = %e,\n' % self.getE23())
        showIndent(outfile, level)
        outfile.write('e31 = %e,\n' % self.getE31())
        showIndent(outfile, level)
        outfile.write('e32 = %e,\n' % self.getE32())
        showIndent(outfile, level)
        outfile.write('e33 = %e,\n' % self.getE33())
    def exportLiteralHtml(self, outfile, level = 0, name_='matrix'):
        level += 1
        self.exportLiteralAttributesHtml(outfile, level, name_)
        self.exportLiteralChildrenHtml(outfile, level, name_)
    def exportLiteralAttributesHtml(self, outfile, level, name_):
        pass
    def exportLiteralChildrenHtml(self, outfile, level, name_):
        showIndentHtml(outfile, level)
        outfile.write('e11 = <a  href:"#">%e</a><br>\n' % self.getE11())
        showIndentHtml(outfile, level)
        outfile.write('e12 = <a  href:"#">%e</a><br>\n' % self.getE12())
        showIndentHtml(outfile, level)
        outfile.write('e13 = <a  href:"#">%e</a><br>\n' % self.getE13())
        showIndentHtml(outfile, level)
        outfile.write('e21 = <a  href:"#">%e</a><br>\n' % self.getE21())
        showIndentHtml(outfile, level)
        outfile.write('e22 = <a  href:"#">%e</a><br>\n' % self.getE22())
        showIndentHtml(outfile, level)
        outfile.write('e23 = <a  href:"#">%e</a><br>\n' % self.getE23())
        showIndentHtml(outfile, level)
        outfile.write('e31 = <a  href:"#">%e</a><br>\n' % self.getE31())
        showIndentHtml(outfile, level)
        outfile.write('e32 = <a  href:"#">%e</a><br>\n' % self.getE32())
        showIndentHtml(outfile, level)
        outfile.write('e33 = <a  href:"#">%e</a><br>\n' % self.getE33())
    def build(self, node_):
        attrs = node_.attributes
        self.buildAttributes(attrs)
        for child_ in node_.childNodes:
            nodeName_ = child_.nodeName.split(':')[-1]
            self.buildChildren(child_, nodeName_)
    def buildAttributes(self, attrs):
        pass
    def buildChildren(self, child_, nodeName_):
        if child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'e11':
            if child_.firstChild:
                sval_ = child_.firstChild.nodeValue
                try:
                    fval_ = float(sval_)
                except ValueError:
                    raise ValueError('requires float (or double) -- %s' % child_.toxml())
                self.e11 = fval_
        elif child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'e12':
            if child_.firstChild:
                sval_ = child_.firstChild.nodeValue
                try:
                    fval_ = float(sval_)
                except ValueError:
                    raise ValueError('requires float (or double) -- %s' % child_.toxml())
                self.e12 = fval_
        elif child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'e13':
            if child_.firstChild:
                sval_ = child_.firstChild.nodeValue
                try:
                    fval_ = float(sval_)
                except ValueError:
                    raise ValueError('requires float (or double) -- %s' % child_.toxml())
                self.e13 = fval_
        elif child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'e21':
            if child_.firstChild:
                sval_ = child_.firstChild.nodeValue
                try:
                    fval_ = float(sval_)
                except ValueError:
                    raise ValueError('requires float (or double) -- %s' % child_.toxml())
                self.e21 = fval_
        elif child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'e22':
            if child_.firstChild:
                sval_ = child_.firstChild.nodeValue
                try:
                    fval_ = float(sval_)
                except ValueError:
                    raise ValueError('requires float (or double) -- %s' % child_.toxml())
                self.e22 = fval_
        elif child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'e23':
            if child_.firstChild:
                sval_ = child_.firstChild.nodeValue
                try:
                    fval_ = float(sval_)
                except ValueError:
                    raise ValueError('requires float (or double) -- %s' % child_.toxml())
                self.e23 = fval_
        elif child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'e31':
            if child_.firstChild:
                sval_ = child_.firstChild.nodeValue
                try:
                    fval_ = float(sval_)
                except ValueError:
                    raise ValueError('requires float (or double) -- %s' % child_.toxml())
                self.e31 = fval_
        elif child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'e32':
            if child_.firstChild:
                sval_ = child_.firstChild.nodeValue
                try:
                    fval_ = float(sval_)
                except ValueError:
                    raise ValueError('requires float (or double) -- %s' % child_.toxml())
                self.e32 = fval_
        elif child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'e33':
            if child_.firstChild:
                sval_ = child_.firstChild.nodeValue
                try:
                    fval_ = float(sval_)
                except ValueError:
                    raise ValueError('requires float (or double) -- %s' % child_.toxml())
                self.e33 = fval_
# end class matrix


class dna_message(object):
    subclass = None
    def __init__(self, ttype='', content_type='', level='', message=''):
        self.ttype = ttype
        self.content_type = content_type
        self.level = level
        self.message = message
    def factory(*args_, **kwargs_):
        if dna_message.subclass:
            return dna_message.subclass(*args_, **kwargs_)
        else:
            return dna_message(*args_, **kwargs_)
    factory = staticmethod(factory)
    def getType(self): return self.ttype
    def setType(self, ttype): self.ttype = ttype
    def getContent_type(self): return self.content_type
    def setContent_type(self, content_type): self.content_type = content_type
    def getLevel(self): return self.level
    def setLevel(self, level): self.level = level
    def getMessage(self): return self.message
    def setMessage(self, message): self.message = message
    def export(self, outfile, level = 0, name_='dna_message'):
        showIndent(outfile, level)
        outfile.write('<%s>\n' % name_)
        self.exportChildren(outfile, level + 1, name_)
        showIndent(outfile, level)
        outfile.write('</%s>\n' % name_)
    def exportAttributes(self, outfile, level, name_='dna_message'):
        pass
    def exportChildren(self, outfile, level, name_='dna_message'):
        showIndent(outfile, level)
        outfile.write('<type>%s</type>\n' % quote_xml(self.getType()))
        showIndent(outfile, level)
        outfile.write('<content_type>%s</content_type>\n' % quote_xml(self.getContent_type()))
        showIndent(outfile, level)
        outfile.write('<level>%s</level>\n' % quote_xml(self.getLevel()))
        showIndent(outfile, level)
        outfile.write('<message>%s</message>\n' % quote_xml(self.getMessage()))

    #Only to export the entire XML tree to a file stream on disk
    def outputFile( self, _outfileName ):
        outfile = open( _outfileName, "w" )
        outfile.write("<?xml version=\"1.0\" ?>\n")
        self.export( outfile, 0, name_='dna_message' )
        outfile.close()


    #Only to export the entire XML tree to a Html Page in a file stream on disk
    def outputPageHtml( self, _outfileName ):
        odtStrTitle = "    <span class=\"title\">dna_message:</span> <br> <br> <br>\n" 
        outfile = open( _outfileName, "w" )
        outfile.write( TEMPLATE_PAGE_P1 % ( odtStrTitle ) )
        self.exportLiteralHtml( outfile, 0, name_='dna_message' )
        outfile.write( TEMPLATE_PAGE_P2  )
        outfile.close()


    def outputFileHtml( self, _outfileName ):
        self.outputPageHtml( _outfileName )



    #Static method for parsing a string
    def parseString( _inString ):
        doc = minidom.parseString(_inString)
        rootNode = doc.documentElement
        rootObj = dna_message.factory()
        rootObj.build(rootNode)
        return rootObj
    parseString = staticmethod( parseString ) 


    #Method for marshalling an object
    def marshal( self ):
        oStreamString = StringIO.StringIO()
        oStreamString.write('<?xml version="1.0" ?>\n')
        self.export( oStreamString, 0, name_="dna_message" )
        oStringXML = oStreamString.getvalue()
        oStreamString.close()
        return oStringXML

    def exportLiteral(self, outfile, level = 0, name_='dna_message'):
        level += 1
        self.exportLiteralAttributes(outfile, level, name_)
        self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('ttype = %s,\n' % quote_python(self.getType()))
        showIndent(outfile, level)
        outfile.write('content_type = %s,\n' % quote_python(self.getContent_type()))
        showIndent(outfile, level)
        outfile.write('level = %s,\n' % quote_python(self.getLevel()))
        showIndent(outfile, level)
        outfile.write('message = %s,\n' % quote_python(self.getMessage()))
    def exportLiteralHtml(self, outfile, level = 0, name_='dna_message'):
        level += 1
        self.exportLiteralAttributesHtml(outfile, level, name_)
        self.exportLiteralChildrenHtml(outfile, level, name_)
    def exportLiteralAttributesHtml(self, outfile, level, name_):
        pass
    def exportLiteralChildrenHtml(self, outfile, level, name_):
        showIndentHtml(outfile, level)
        outfile.write('ttype = <a  href:"#">%s</a><br>\n' % quote_python(self.getType()))
        showIndentHtml(outfile, level)
        outfile.write('content_type = <a  href:"#">%s</a><br>\n' % quote_python(self.getContent_type()))
        showIndentHtml(outfile, level)
        outfile.write('level = <a  href:"#">%s</a><br>\n' % quote_python(self.getLevel()))
        showIndentHtml(outfile, level)
        outfile.write('message = <a  href:"#">%s</a><br>\n' % quote_python(self.getMessage()))
    def build(self, node_):
        attrs = node_.attributes
        self.buildAttributes(attrs)
        for child_ in node_.childNodes:
            nodeName_ = child_.nodeName.split(':')[-1]
            self.buildChildren(child_, nodeName_)
    def buildAttributes(self, attrs):
        pass
    def buildChildren(self, child_, nodeName_):
        if child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'type':
            type_ = ''
            for text__content_ in child_.childNodes:
                type_ += text__content_.nodeValue
            self.ttype = type_
        elif child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'content_type':
            content_type_ = ''
            for text__content_ in child_.childNodes:
                content_type_ += text__content_.nodeValue
            self.content_type = content_type_
        elif child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'level':
            level_ = ''
            for text__content_ in child_.childNodes:
                level_ += text__content_.nodeValue
            self.level = level_
        elif child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'message':
            message_ = ''
            for text__content_ in child_.childNodes:
                message_ += text__content_.nodeValue
            self.message = message_
# end class dna_message


class input_reflections(object):
    subclass = None
    def __init__(self, hklin=None):
        if hklin is None:
            self.hklin = []
        else:
            self.hklin = hklin
    def factory(*args_, **kwargs_):
        if input_reflections.subclass:
            return input_reflections.subclass(*args_, **kwargs_)
        else:
            return input_reflections(*args_, **kwargs_)
    factory = staticmethod(factory)
    def getHklin(self): return self.hklin
    def setHklin(self, hklin): self.hklin = hklin
    def addHklin(self, value): self.hklin.append(value)
    def insertHklin(self, index, value): self.hklin[index] = value
    def export(self, outfile, level = 0, name_='input_reflections'):
        showIndent(outfile, level)
        outfile.write('<%s>\n' % name_)
        self.exportChildren(outfile, level + 1, name_)
        showIndent(outfile, level)
        outfile.write('</%s>\n' % name_)
    def exportAttributes(self, outfile, level, name_='input_reflections'):
        pass
    def exportChildren(self, outfile, level, name_='input_reflections'):
        for hklin_ in self.getHklin():
            showIndent(outfile, level)
            outfile.write('<hklin>%s</hklin>\n' % quote_xml(hklin_))

    #Only to export the entire XML tree to a file stream on disk
    def outputFile( self, _outfileName ):
        outfile = open( _outfileName, "w" )
        outfile.write("<?xml version=\"1.0\" ?>\n")
        self.export( outfile, 0, name_='input_reflections' )
        outfile.close()


    #Only to export the entire XML tree to a Html Page in a file stream on disk
    def outputPageHtml( self, _outfileName ):
        odtStrTitle = "    <span class=\"title\">input_reflections:</span> <br> <br> <br>\n" 
        outfile = open( _outfileName, "w" )
        outfile.write( TEMPLATE_PAGE_P1 % ( odtStrTitle ) )
        self.exportLiteralHtml( outfile, 0, name_='input_reflections' )
        outfile.write( TEMPLATE_PAGE_P2  )
        outfile.close()


    def outputFileHtml( self, _outfileName ):
        self.outputPageHtml( _outfileName )



    #Static method for parsing a string
    def parseString( _inString ):
        doc = minidom.parseString(_inString)
        rootNode = doc.documentElement
        rootObj = input_reflections.factory()
        rootObj.build(rootNode)
        return rootObj
    parseString = staticmethod( parseString ) 


    #Method for marshalling an object
    def marshal( self ):
        oStreamString = StringIO.StringIO()
        oStreamString.write('<?xml version="1.0" ?>\n')
        self.export( oStreamString, 0, name_="input_reflections" )
        oStringXML = oStreamString.getvalue()
        oStreamString.close()
        return oStringXML

    def exportLiteral(self, outfile, level = 0, name_='input_reflections'):
        level += 1
        self.exportLiteralAttributes(outfile, level, name_)
        self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('hklin=[\n')
        level += 1
        for hklin in self.hklin:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(hklin))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def exportLiteralHtml(self, outfile, level = 0, name_='input_reflections'):
        level += 1
        self.exportLiteralAttributesHtml(outfile, level, name_)
        self.exportLiteralChildrenHtml(outfile, level, name_)
    def exportLiteralAttributesHtml(self, outfile, level, name_):
        pass
    def exportLiteralChildrenHtml(self, outfile, level, name_):
        showIndentHtml(outfile, level)
        outfile.write('hklin<br>\n')
        level += 1
        for hklin in self.hklin:
            showIndentHtml(outfile, level)
            outfile.write('<a  href:"#">%s</a><br>\n' % quote_python(hklin))
        level -= 1
        showIndentHtml(outfile, level)
        outfile.write('<br>\n')
    def build(self, node_):
        attrs = node_.attributes
        self.buildAttributes(attrs)
        for child_ in node_.childNodes:
            nodeName_ = child_.nodeName.split(':')[-1]
            self.buildChildren(child_, nodeName_)
    def buildAttributes(self, attrs):
        pass
    def buildChildren(self, child_, nodeName_):
        if child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'hklin':
            hklin_ = ''
            for text__content_ in child_.childNodes:
                hklin_ += text__content_.nodeValue
            self.hklin.append(hklin_)
# end class input_reflections


class output_reflections(object):
    subclass = None
    def __init__(self, hklout=''):
        self.hklout = hklout
    def factory(*args_, **kwargs_):
        if output_reflections.subclass:
            return output_reflections.subclass(*args_, **kwargs_)
        else:
            return output_reflections(*args_, **kwargs_)
    factory = staticmethod(factory)
    def getHklout(self): return self.hklout
    def setHklout(self, hklout): self.hklout = hklout
    def export(self, outfile, level = 0, name_='output_reflections'):
        showIndent(outfile, level)
        outfile.write('<%s>\n' % name_)
        self.exportChildren(outfile, level + 1, name_)
        showIndent(outfile, level)
        outfile.write('</%s>\n' % name_)
    def exportAttributes(self, outfile, level, name_='output_reflections'):
        pass
    def exportChildren(self, outfile, level, name_='output_reflections'):
        showIndent(outfile, level)
        outfile.write('<hklout>%s</hklout>\n' % quote_xml(self.getHklout()))

    #Only to export the entire XML tree to a file stream on disk
    def outputFile( self, _outfileName ):
        outfile = open( _outfileName, "w" )
        outfile.write("<?xml version=\"1.0\" ?>\n")
        self.export( outfile, 0, name_='output_reflections' )
        outfile.close()


    #Only to export the entire XML tree to a Html Page in a file stream on disk
    def outputPageHtml( self, _outfileName ):
        odtStrTitle = "    <span class=\"title\">output_reflections:</span> <br> <br> <br>\n" 
        outfile = open( _outfileName, "w" )
        outfile.write( TEMPLATE_PAGE_P1 % ( odtStrTitle ) )
        self.exportLiteralHtml( outfile, 0, name_='output_reflections' )
        outfile.write( TEMPLATE_PAGE_P2  )
        outfile.close()


    def outputFileHtml( self, _outfileName ):
        self.outputPageHtml( _outfileName )



    #Static method for parsing a string
    def parseString( _inString ):
        doc = minidom.parseString(_inString)
        rootNode = doc.documentElement
        rootObj = output_reflections.factory()
        rootObj.build(rootNode)
        return rootObj
    parseString = staticmethod( parseString ) 


    #Method for marshalling an object
    def marshal( self ):
        oStreamString = StringIO.StringIO()
        oStreamString.write('<?xml version="1.0" ?>\n')
        self.export( oStreamString, 0, name_="output_reflections" )
        oStringXML = oStreamString.getvalue()
        oStreamString.close()
        return oStringXML

    def exportLiteral(self, outfile, level = 0, name_='output_reflections'):
        level += 1
        self.exportLiteralAttributes(outfile, level, name_)
        self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('hklout = %s,\n' % quote_python(self.getHklout()))
    def exportLiteralHtml(self, outfile, level = 0, name_='output_reflections'):
        level += 1
        self.exportLiteralAttributesHtml(outfile, level, name_)
        self.exportLiteralChildrenHtml(outfile, level, name_)
    def exportLiteralAttributesHtml(self, outfile, level, name_):
        pass
    def exportLiteralChildrenHtml(self, outfile, level, name_):
        showIndentHtml(outfile, level)
        outfile.write('hklout = <a  href:"#">%s</a><br>\n' % quote_python(self.getHklout()))
    def build(self, node_):
        attrs = node_.attributes
        self.buildAttributes(attrs)
        for child_ in node_.childNodes:
            nodeName_ = child_.nodeName.split(':')[-1]
            self.buildChildren(child_, nodeName_)
    def buildAttributes(self, attrs):
        pass
    def buildChildren(self, child_, nodeName_):
        if child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'hklout':
            hklout_ = ''
            for text__content_ in child_.childNodes:
                hklout_ += text__content_.nodeValue
            self.hklout = hklout_
# end class output_reflections


class resolution(object):
    subclass = None
    def __init__(self, lower=0.0, upper=0.0):
        self.lower = lower
        self.upper = upper
    def factory(*args_, **kwargs_):
        if resolution.subclass:
            return resolution.subclass(*args_, **kwargs_)
        else:
            return resolution(*args_, **kwargs_)
    factory = staticmethod(factory)
    def getLower(self): return self.lower
    def setLower(self, lower): self.lower = lower
    def getUpper(self): return self.upper
    def setUpper(self, upper): self.upper = upper
    def export(self, outfile, level = 0, name_='resolution'):
        showIndent(outfile, level)
        outfile.write('<%s>\n' % name_)
        self.exportChildren(outfile, level + 1, name_)
        showIndent(outfile, level)
        outfile.write('</%s>\n' % name_)
    def exportAttributes(self, outfile, level, name_='resolution'):
        pass
    def exportChildren(self, outfile, level, name_='resolution'):
        showIndent(outfile, level)
        outfile.write('<lower>%e</lower>\n' % self.getLower())
        showIndent(outfile, level)
        outfile.write('<upper>%e</upper>\n' % self.getUpper())

    #Only to export the entire XML tree to a file stream on disk
    def outputFile( self, _outfileName ):
        outfile = open( _outfileName, "w" )
        outfile.write("<?xml version=\"1.0\" ?>\n")
        self.export( outfile, 0, name_='resolution' )
        outfile.close()


    #Only to export the entire XML tree to a Html Page in a file stream on disk
    def outputPageHtml( self, _outfileName ):
        odtStrTitle = "    <span class=\"title\">resolution:</span> <br> <br> <br>\n" 
        outfile = open( _outfileName, "w" )
        outfile.write( TEMPLATE_PAGE_P1 % ( odtStrTitle ) )
        self.exportLiteralHtml( outfile, 0, name_='resolution' )
        outfile.write( TEMPLATE_PAGE_P2  )
        outfile.close()


    def outputFileHtml( self, _outfileName ):
        self.outputPageHtml( _outfileName )



    #Static method for parsing a string
    def parseString( _inString ):
        doc = minidom.parseString(_inString)
        rootNode = doc.documentElement
        rootObj = resolution.factory()
        rootObj.build(rootNode)
        return rootObj
    parseString = staticmethod( parseString ) 


    #Method for marshalling an object
    def marshal( self ):
        oStreamString = StringIO.StringIO()
        oStreamString.write('<?xml version="1.0" ?>\n')
        self.export( oStreamString, 0, name_="resolution" )
        oStringXML = oStreamString.getvalue()
        oStreamString.close()
        return oStringXML

    def exportLiteral(self, outfile, level = 0, name_='resolution'):
        level += 1
        self.exportLiteralAttributes(outfile, level, name_)
        self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('lower = %e,\n' % self.getLower())
        showIndent(outfile, level)
        outfile.write('upper = %e,\n' % self.getUpper())
    def exportLiteralHtml(self, outfile, level = 0, name_='resolution'):
        level += 1
        self.exportLiteralAttributesHtml(outfile, level, name_)
        self.exportLiteralChildrenHtml(outfile, level, name_)
    def exportLiteralAttributesHtml(self, outfile, level, name_):
        pass
    def exportLiteralChildrenHtml(self, outfile, level, name_):
        showIndentHtml(outfile, level)
        outfile.write('lower = <a  href:"#">%e</a><br>\n' % self.getLower())
        showIndentHtml(outfile, level)
        outfile.write('upper = <a  href:"#">%e</a><br>\n' % self.getUpper())
    def build(self, node_):
        attrs = node_.attributes
        self.buildAttributes(attrs)
        for child_ in node_.childNodes:
            nodeName_ = child_.nodeName.split(':')[-1]
            self.buildChildren(child_, nodeName_)
    def buildAttributes(self, attrs):
        pass
    def buildChildren(self, child_, nodeName_):
        if child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'lower':
            if child_.firstChild:
                sval_ = child_.firstChild.nodeValue
                try:
                    fval_ = float(sval_)
                except ValueError:
                    raise ValueError('requires float (or double) -- %s' % child_.toxml())
                self.lower = fval_
        elif child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'upper':
            if child_.firstChild:
                sval_ = child_.firstChild.nodeValue
                try:
                    fval_ = float(sval_)
                except ValueError:
                    raise ValueError('requires float (or double) -- %s' % child_.toxml())
                self.upper = fval_
# end class resolution


class abort_request(object):
    subclass = None
    def __init__(self, level=''):
        self.level = level
    def factory(*args_, **kwargs_):
        if abort_request.subclass:
            return abort_request.subclass(*args_, **kwargs_)
        else:
            return abort_request(*args_, **kwargs_)
    factory = staticmethod(factory)
    def getLevel(self): return self.level
    def setLevel(self, level): self.level = level
    def export(self, outfile, level = 0, name_='abort_request'):
        showIndent(outfile, level)
        outfile.write('<%s>\n' % name_)
        self.exportChildren(outfile, level + 1, name_)
        showIndent(outfile, level)
        outfile.write('</%s>\n' % name_)
    def exportAttributes(self, outfile, level, name_='abort_request'):
        pass
    def exportChildren(self, outfile, level, name_='abort_request'):
        showIndent(outfile, level)
        outfile.write('<level>%s</level>\n' % quote_xml(self.getLevel()))

    #Only to export the entire XML tree to a file stream on disk
    def outputFile( self, _outfileName ):
        outfile = open( _outfileName, "w" )
        outfile.write("<?xml version=\"1.0\" ?>\n")
        self.export( outfile, 0, name_='abort_request' )
        outfile.close()


    #Only to export the entire XML tree to a Html Page in a file stream on disk
    def outputPageHtml( self, _outfileName ):
        odtStrTitle = "    <span class=\"title\">abort_request:</span> <br> <br> <br>\n" 
        outfile = open( _outfileName, "w" )
        outfile.write( TEMPLATE_PAGE_P1 % ( odtStrTitle ) )
        self.exportLiteralHtml( outfile, 0, name_='abort_request' )
        outfile.write( TEMPLATE_PAGE_P2  )
        outfile.close()


    def outputFileHtml( self, _outfileName ):
        self.outputPageHtml( _outfileName )



    #Static method for parsing a string
    def parseString( _inString ):
        doc = minidom.parseString(_inString)
        rootNode = doc.documentElement
        rootObj = abort_request.factory()
        rootObj.build(rootNode)
        return rootObj
    parseString = staticmethod( parseString ) 


    #Method for marshalling an object
    def marshal( self ):
        oStreamString = StringIO.StringIO()
        oStreamString.write('<?xml version="1.0" ?>\n')
        self.export( oStreamString, 0, name_="abort_request" )
        oStringXML = oStreamString.getvalue()
        oStreamString.close()
        return oStringXML

    def exportLiteral(self, outfile, level = 0, name_='abort_request'):
        level += 1
        self.exportLiteralAttributes(outfile, level, name_)
        self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('level = %s,\n' % quote_python(self.getLevel()))
    def exportLiteralHtml(self, outfile, level = 0, name_='abort_request'):
        level += 1
        self.exportLiteralAttributesHtml(outfile, level, name_)
        self.exportLiteralChildrenHtml(outfile, level, name_)
    def exportLiteralAttributesHtml(self, outfile, level, name_):
        pass
    def exportLiteralChildrenHtml(self, outfile, level, name_):
        showIndentHtml(outfile, level)
        outfile.write('level = <a  href:"#">%s</a><br>\n' % quote_python(self.getLevel()))
    def build(self, node_):
        attrs = node_.attributes
        self.buildAttributes(attrs)
        for child_ in node_.childNodes:
            nodeName_ = child_.nodeName.split(':')[-1]
            self.buildChildren(child_, nodeName_)
    def buildAttributes(self, attrs):
        pass
    def buildChildren(self, child_, nodeName_):
        if child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'level':
            level_ = ''
            for text__content_ in child_.childNodes:
                level_ += text__content_.nodeValue
            self.level = level_
# end class abort_request


class abort_response(object):
    subclass = None
    def __init__(self, status=None):
        self.status = status
    def factory(*args_, **kwargs_):
        if abort_response.subclass:
            return abort_response.subclass(*args_, **kwargs_)
        else:
            return abort_response(*args_, **kwargs_)
    factory = staticmethod(factory)
    def getStatus(self): return self.status
    def setStatus(self, status): self.status = status
    def export(self, outfile, level = 0, name_='abort_response'):
        showIndent(outfile, level)
        outfile.write('<%s>\n' % name_)
        self.exportChildren(outfile, level + 1, name_)
        showIndent(outfile, level)
        outfile.write('</%s>\n' % name_)
    def exportAttributes(self, outfile, level, name_='abort_response'):
        pass
    def exportChildren(self, outfile, level, name_='abort_response'):
        if self.status:
            self.status.export(outfile, level)

    #Only to export the entire XML tree to a file stream on disk
    def outputFile( self, _outfileName ):
        outfile = open( _outfileName, "w" )
        outfile.write("<?xml version=\"1.0\" ?>\n")
        self.export( outfile, 0, name_='abort_response' )
        outfile.close()


    #Only to export the entire XML tree to a Html Page in a file stream on disk
    def outputPageHtml( self, _outfileName ):
        odtStrTitle = "    <span class=\"title\">abort_response:</span> <br> <br> <br>\n" 
        outfile = open( _outfileName, "w" )
        outfile.write( TEMPLATE_PAGE_P1 % ( odtStrTitle ) )
        self.exportLiteralHtml( outfile, 0, name_='abort_response' )
        outfile.write( TEMPLATE_PAGE_P2  )
        outfile.close()


    def outputFileHtml( self, _outfileName ):
        self.outputPageHtml( _outfileName )



    #Static method for parsing a string
    def parseString( _inString ):
        doc = minidom.parseString(_inString)
        rootNode = doc.documentElement
        rootObj = abort_response.factory()
        rootObj.build(rootNode)
        return rootObj
    parseString = staticmethod( parseString ) 


    #Method for marshalling an object
    def marshal( self ):
        oStreamString = StringIO.StringIO()
        oStreamString.write('<?xml version="1.0" ?>\n')
        self.export( oStreamString, 0, name_="abort_response" )
        oStringXML = oStreamString.getvalue()
        oStreamString.close()
        return oStringXML

    def exportLiteral(self, outfile, level = 0, name_='abort_response'):
        level += 1
        self.exportLiteralAttributes(outfile, level, name_)
        self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.status:
            showIndent(outfile, level)
            outfile.write('status = status(\n')
            self.status.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
    def exportLiteralHtml(self, outfile, level = 0, name_='abort_response'):
        level += 1
        self.exportLiteralAttributesHtml(outfile, level, name_)
        self.exportLiteralChildrenHtml(outfile, level, name_)
    def exportLiteralAttributesHtml(self, outfile, level, name_):
        pass
    def exportLiteralChildrenHtml(self, outfile, level, name_):
        if self.status:
            showIndentHtml(outfile, level)
            outfile.write('status<br>\n')
            self.status.exportLiteralHtml(outfile, level)
            showIndentHtml(outfile, level)
            outfile.write('<br>\n')
    def build(self, node_):
        attrs = node_.attributes
        self.buildAttributes(attrs)
        for child_ in node_.childNodes:
            nodeName_ = child_.nodeName.split(':')[-1]
            self.buildChildren(child_, nodeName_)
    def buildAttributes(self, attrs):
        pass
    def buildChildren(self, child_, nodeName_):
        if child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'status':
            obj_ = status.factory()
            obj_.build(child_)
            self.setStatus(obj_)
# end class abort_response


class sample_reference(object):
    subclass = None
    def __init__(self, code='', container_reference='', container_code='', sample_location='', blSampleId=''):
        self.code = code
        self.container_reference = container_reference
        self.container_code = container_code
        self.sample_location = sample_location
        self.blSampleId = blSampleId
    def factory(*args_, **kwargs_):
        if sample_reference.subclass:
            return sample_reference.subclass(*args_, **kwargs_)
        else:
            return sample_reference(*args_, **kwargs_)
    factory = staticmethod(factory)
    def getCode(self): return self.code
    def setCode(self, code): self.code = code
    def getContainer_reference(self): return self.container_reference
    def setContainer_reference(self, container_reference): self.container_reference = container_reference
    def getContainer_code(self): return self.container_code
    def setContainer_code(self, container_code): self.container_code = container_code
    def getSample_location(self): return self.sample_location
    def setSample_location(self, sample_location): self.sample_location = sample_location
    def getBlSampleId(self): return self.blSampleId
    def setBlSampleId(self, blSampleId): self.blSampleId = blSampleId
    def export(self, outfile, level = 0, name_='sample_reference'):
        showIndent(outfile, level)
        outfile.write('<%s>\n' % name_)
        self.exportChildren(outfile, level + 1, name_)
        showIndent(outfile, level)
        outfile.write('</%s>\n' % name_)
    def exportAttributes(self, outfile, level, name_='sample_reference'):
        pass
    def exportChildren(self, outfile, level, name_='sample_reference'):
        showIndent(outfile, level)
        outfile.write('<code>%s</code>\n' % quote_xml(self.getCode()))
        showIndent(outfile, level)
        outfile.write('<container_reference>%s</container_reference>\n' % quote_xml(self.getContainer_reference()))
        showIndent(outfile, level)
        outfile.write('<container_code>%s</container_code>\n' % quote_xml(self.getContainer_code()))
        showIndent(outfile, level)
        outfile.write('<sample_location>%s</sample_location>\n' % quote_xml(self.getSample_location()))
        showIndent(outfile, level)
        outfile.write('<blSampleId>%s</blSampleId>\n' % quote_xml(self.getBlSampleId()))

    #Only to export the entire XML tree to a file stream on disk
    def outputFile( self, _outfileName ):
        outfile = open( _outfileName, "w" )
        outfile.write("<?xml version=\"1.0\" ?>\n")
        self.export( outfile, 0, name_='sample_reference' )
        outfile.close()


    #Only to export the entire XML tree to a Html Page in a file stream on disk
    def outputPageHtml( self, _outfileName ):
        odtStrTitle = "    <span class=\"title\">sample_reference:</span> <br> <br> <br>\n" 
        outfile = open( _outfileName, "w" )
        outfile.write( TEMPLATE_PAGE_P1 % ( odtStrTitle ) )
        self.exportLiteralHtml( outfile, 0, name_='sample_reference' )
        outfile.write( TEMPLATE_PAGE_P2  )
        outfile.close()


    def outputFileHtml( self, _outfileName ):
        self.outputPageHtml( _outfileName )



    #Static method for parsing a string
    def parseString( _inString ):
        doc = minidom.parseString(_inString)
        rootNode = doc.documentElement
        rootObj = sample_reference.factory()
        rootObj.build(rootNode)
        return rootObj
    parseString = staticmethod( parseString ) 


    #Method for marshalling an object
    def marshal( self ):
        oStreamString = StringIO.StringIO()
        oStreamString.write('<?xml version="1.0" ?>\n')
        self.export( oStreamString, 0, name_="sample_reference" )
        oStringXML = oStreamString.getvalue()
        oStreamString.close()
        return oStringXML

    def exportLiteral(self, outfile, level = 0, name_='sample_reference'):
        level += 1
        self.exportLiteralAttributes(outfile, level, name_)
        self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('code = %s,\n' % quote_python(self.getCode()))
        showIndent(outfile, level)
        outfile.write('container_reference = %s,\n' % quote_python(self.getContainer_reference()))
        showIndent(outfile, level)
        outfile.write('container_code = %s,\n' % quote_python(self.getContainer_code()))
        showIndent(outfile, level)
        outfile.write('sample_location = %s,\n' % quote_python(self.getSample_location()))
        showIndent(outfile, level)
        outfile.write('blSampleId = %s,\n' % quote_python(self.getBlSampleId()))
    def exportLiteralHtml(self, outfile, level = 0, name_='sample_reference'):
        level += 1
        self.exportLiteralAttributesHtml(outfile, level, name_)
        self.exportLiteralChildrenHtml(outfile, level, name_)
    def exportLiteralAttributesHtml(self, outfile, level, name_):
        pass
    def exportLiteralChildrenHtml(self, outfile, level, name_):
        showIndentHtml(outfile, level)
        outfile.write('code = <a  href:"#">%s</a><br>\n' % quote_python(self.getCode()))
        showIndentHtml(outfile, level)
        outfile.write('container_reference = <a  href:"#">%s</a><br>\n' % quote_python(self.getContainer_reference()))
        showIndentHtml(outfile, level)
        outfile.write('container_code = <a  href:"#">%s</a><br>\n' % quote_python(self.getContainer_code()))
        showIndentHtml(outfile, level)
        outfile.write('sample_location = <a  href:"#">%s</a><br>\n' % quote_python(self.getSample_location()))
        showIndentHtml(outfile, level)
        outfile.write('blSampleId = <a  href:"#">%s</a><br>\n' % quote_python(self.getBlSampleId()))
    def build(self, node_):
        attrs = node_.attributes
        self.buildAttributes(attrs)
        for child_ in node_.childNodes:
            nodeName_ = child_.nodeName.split(':')[-1]
            self.buildChildren(child_, nodeName_)
    def buildAttributes(self, attrs):
        pass
    def buildChildren(self, child_, nodeName_):
        if child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'code':
            code_ = ''
            for text__content_ in child_.childNodes:
                code_ += text__content_.nodeValue
            self.code = code_
        elif child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'container_reference':
            container_reference_ = ''
            for text__content_ in child_.childNodes:
                container_reference_ += text__content_.nodeValue
            self.container_reference = container_reference_
        elif child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'container_code':
            container_code_ = ''
            for text__content_ in child_.childNodes:
                container_code_ += text__content_.nodeValue
            self.container_code = container_code_
        elif child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'sample_location':
            sample_location_ = ''
            for text__content_ in child_.childNodes:
                sample_location_ += text__content_.nodeValue
            self.sample_location = sample_location_
        elif child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'blSampleId':
            blSampleId_ = ''
            for text__content_ in child_.childNodes:
                blSampleId_ += text__content_.nodeValue
            self.blSampleId = blSampleId_
# end class sample_reference


class beamline_parameters(object):
    subclass = None
    def __init__(self, maximum_exposure=0.0, minimum_exposure_time=0.0, minimum_phi_speed=0.0, maximum_phi_speed=0.0, minimum_phi_oscillation=0.0):
        self.maximum_exposure = maximum_exposure
        self.minimum_exposure_time = minimum_exposure_time
        self.minimum_phi_speed = minimum_phi_speed
        self.maximum_phi_speed = maximum_phi_speed
        self.minimum_phi_oscillation = minimum_phi_oscillation
    def factory(*args_, **kwargs_):
        if beamline_parameters.subclass:
            return beamline_parameters.subclass(*args_, **kwargs_)
        else:
            return beamline_parameters(*args_, **kwargs_)
    factory = staticmethod(factory)
    def getMaximum_exposure(self): return self.maximum_exposure
    def setMaximum_exposure(self, maximum_exposure): self.maximum_exposure = maximum_exposure
    def getMinimum_exposure_time(self): return self.minimum_exposure_time
    def setMinimum_exposure_time(self, minimum_exposure_time): self.minimum_exposure_time = minimum_exposure_time
    def getMinimum_phi_speed(self): return self.minimum_phi_speed
    def setMinimum_phi_speed(self, minimum_phi_speed): self.minimum_phi_speed = minimum_phi_speed
    def getMaximum_phi_speed(self): return self.maximum_phi_speed
    def setMaximum_phi_speed(self, maximum_phi_speed): self.maximum_phi_speed = maximum_phi_speed
    def getMinimum_phi_oscillation(self): return self.minimum_phi_oscillation
    def setMinimum_phi_oscillation(self, minimum_phi_oscillation): self.minimum_phi_oscillation = minimum_phi_oscillation
    def export(self, outfile, level = 0, name_='beamline_parameters'):
        showIndent(outfile, level)
        outfile.write('<%s>\n' % name_)
        self.exportChildren(outfile, level + 1, name_)
        showIndent(outfile, level)
        outfile.write('</%s>\n' % name_)
    def exportAttributes(self, outfile, level, name_='beamline_parameters'):
        pass
    def exportChildren(self, outfile, level, name_='beamline_parameters'):
        showIndent(outfile, level)
        outfile.write('<maximum_exposure>%e</maximum_exposure>\n' % self.getMaximum_exposure())
        showIndent(outfile, level)
        outfile.write('<minimum_exposure_time>%e</minimum_exposure_time>\n' % self.getMinimum_exposure_time())
        showIndent(outfile, level)
        outfile.write('<minimum_phi_speed>%e</minimum_phi_speed>\n' % self.getMinimum_phi_speed())
        showIndent(outfile, level)
        outfile.write('<maximum_phi_speed>%e</maximum_phi_speed>\n' % self.getMaximum_phi_speed())
        showIndent(outfile, level)
        outfile.write('<minimum_phi_oscillation>%e</minimum_phi_oscillation>\n' % self.getMinimum_phi_oscillation())

    #Only to export the entire XML tree to a file stream on disk
    def outputFile( self, _outfileName ):
        outfile = open( _outfileName, "w" )
        outfile.write("<?xml version=\"1.0\" ?>\n")
        self.export( outfile, 0, name_='beamline_parameters' )
        outfile.close()


    #Only to export the entire XML tree to a Html Page in a file stream on disk
    def outputPageHtml( self, _outfileName ):
        odtStrTitle = "    <span class=\"title\">beamline_parameters:</span> <br> <br> <br>\n" 
        outfile = open( _outfileName, "w" )
        outfile.write( TEMPLATE_PAGE_P1 % ( odtStrTitle ) )
        self.exportLiteralHtml( outfile, 0, name_='beamline_parameters' )
        outfile.write( TEMPLATE_PAGE_P2  )
        outfile.close()


    def outputFileHtml( self, _outfileName ):
        self.outputPageHtml( _outfileName )



    #Static method for parsing a string
    def parseString( _inString ):
        doc = minidom.parseString(_inString)
        rootNode = doc.documentElement
        rootObj = beamline_parameters.factory()
        rootObj.build(rootNode)
        return rootObj
    parseString = staticmethod( parseString ) 


    #Method for marshalling an object
    def marshal( self ):
        oStreamString = StringIO.StringIO()
        oStreamString.write('<?xml version="1.0" ?>\n')
        self.export( oStreamString, 0, name_="beamline_parameters" )
        oStringXML = oStreamString.getvalue()
        oStreamString.close()
        return oStringXML

    def exportLiteral(self, outfile, level = 0, name_='beamline_parameters'):
        level += 1
        self.exportLiteralAttributes(outfile, level, name_)
        self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('maximum_exposure = %e,\n' % self.getMaximum_exposure())
        showIndent(outfile, level)
        outfile.write('minimum_exposure_time = %e,\n' % self.getMinimum_exposure_time())
        showIndent(outfile, level)
        outfile.write('minimum_phi_speed = %e,\n' % self.getMinimum_phi_speed())
        showIndent(outfile, level)
        outfile.write('maximum_phi_speed = %e,\n' % self.getMaximum_phi_speed())
        showIndent(outfile, level)
        outfile.write('minimum_phi_oscillation = %e,\n' % self.getMinimum_phi_oscillation())
    def exportLiteralHtml(self, outfile, level = 0, name_='beamline_parameters'):
        level += 1
        self.exportLiteralAttributesHtml(outfile, level, name_)
        self.exportLiteralChildrenHtml(outfile, level, name_)
    def exportLiteralAttributesHtml(self, outfile, level, name_):
        pass
    def exportLiteralChildrenHtml(self, outfile, level, name_):
        showIndentHtml(outfile, level)
        outfile.write('maximum_exposure = <a  href:"#">%e</a><br>\n' % self.getMaximum_exposure())
        showIndentHtml(outfile, level)
        outfile.write('minimum_exposure_time = <a  href:"#">%e</a><br>\n' % self.getMinimum_exposure_time())
        showIndentHtml(outfile, level)
        outfile.write('minimum_phi_speed = <a  href:"#">%e</a><br>\n' % self.getMinimum_phi_speed())
        showIndentHtml(outfile, level)
        outfile.write('maximum_phi_speed = <a  href:"#">%e</a><br>\n' % self.getMaximum_phi_speed())
        showIndentHtml(outfile, level)
        outfile.write('minimum_phi_oscillation = <a  href:"#">%e</a><br>\n' % self.getMinimum_phi_oscillation())
    def build(self, node_):
        attrs = node_.attributes
        self.buildAttributes(attrs)
        for child_ in node_.childNodes:
            nodeName_ = child_.nodeName.split(':')[-1]
            self.buildChildren(child_, nodeName_)
    def buildAttributes(self, attrs):
        pass
    def buildChildren(self, child_, nodeName_):
        if child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'maximum_exposure':
            if child_.firstChild:
                sval_ = child_.firstChild.nodeValue
                try:
                    fval_ = float(sval_)
                except ValueError:
                    raise ValueError('requires float (or double) -- %s' % child_.toxml())
                self.maximum_exposure = fval_
        elif child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'minimum_exposure_time':
            if child_.firstChild:
                sval_ = child_.firstChild.nodeValue
                try:
                    fval_ = float(sval_)
                except ValueError:
                    raise ValueError('requires float (or double) -- %s' % child_.toxml())
                self.minimum_exposure_time = fval_
        elif child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'minimum_phi_speed':
            if child_.firstChild:
                sval_ = child_.firstChild.nodeValue
                try:
                    fval_ = float(sval_)
                except ValueError:
                    raise ValueError('requires float (or double) -- %s' % child_.toxml())
                self.minimum_phi_speed = fval_
        elif child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'maximum_phi_speed':
            if child_.firstChild:
                sval_ = child_.firstChild.nodeValue
                try:
                    fval_ = float(sval_)
                except ValueError:
                    raise ValueError('requires float (or double) -- %s' % child_.toxml())
                self.maximum_phi_speed = fval_
        elif child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'minimum_phi_oscillation':
            if child_.firstChild:
                sval_ = child_.firstChild.nodeValue
                try:
                    fval_ = float(sval_)
                except ValueError:
                    raise ValueError('requires float (or double) -- %s' % child_.toxml())
                self.minimum_phi_oscillation = fval_
# end class beamline_parameters




def parse(inFileName):
    doc = minidom.parse(inFileName)
    rootNode = doc.documentElement
    rootObj = scale_reflections_request.factory()
    rootObj.build(rootNode)
    # Enable Python to collect the space used by the DOM.
    doc.unlink()
#    doc = None
    return rootObj


def parseString(inString):
    doc = minidom.parseString(inString)
    rootNode = doc.documentElement
    rootObj = scale_reflections_request.factory()
    rootObj.build(rootNode)
    # Enable Python to collect the space used by the DOM.
    doc.unlink()
#    doc = None
#    sys.stdout.write('<?xml version="1.0" ?>\n')
#    rootObj.export(sys.stdout, 0, name_="scale_reflections_request")
    return rootObj


# AAlib Modifications for marshalling and unmarshalling
# Creating program data constructs from XML
def unMarshalling( _inFileName ):
    return parse(  _inFileName )


# Serializing program data constructs to XML
def marshalling( _oObject, _inFileName ):
    oFile = open( _inFileName, "w" )
    oFile.write('<?xml version="1.0" ?>\n')
    _oObject.export( oFile, 0, name_="scale_reflections_request" )
    oFile.close()

