#!/usr/bin/env python



#################################################################
#
#   Project:   Python-Jython Asynchronous Action Library Project
#              http://pyaalib.sourceforge.net/
#              http://jyaalib.sourceforge.net/
#
#   Author(s): Romeu A. Pieritz - romeu.pieritz@gmail.com
#
#   Code Generated in Date:      Mon Jun  1 23:18:42 2009
#
#   License:
#   ----------------------------------------------
#   Python-Jython Asynchronous Action Library Project
#   Copyright (c) 2005-2008, PyAALib-JyAALib developers
#   All rights reserved.
#
#   Redistribution and use in source and binary forms,
#   with or without modification, are permitted
#   provided that the following conditions are met:
#
#   Redistributions of source code must retain the
#   above copyright notice,this list of conditions
#   and the following disclaimer.
#
#   Redistributions in binary form must reproduce
#   the above copyright notice,this list of conditions
#   and the following disclaimer in the documentation
#   and/or other materials provided with the distribution.
#
#   Neither the names of PyAALib-JyAALib's copyright owner
#   nor the names of its contributors may be used to endorse
#   or promote products derived from this software without
#   specific prior written permission.
#
#   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS
#   AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED
#   WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
#   IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
#   FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO
#   EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS
#   BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
#   SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
#   (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
#   SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA,
#   OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
#   CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER
#   IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
#   NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT
#   OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
#   THE POSSIBILITY OF SUCH DAMAGE.
#
################################################################
#
#
# Generated by ALExternalPackGenerateDS.py.
#
# This file is generated by a modified version of the original file:
# generateDS.py, proposed by Dave Kuhlman:
#
## LICENSE
#
## Copyright (c) 2003 Dave Kuhlman
#
## Permission is hereby granted, free of charge, to any person obtaining
## a copy of this software and associated documentation files (the
## "Software"), to deal in the Software without restriction, including
## without limitation the rights to use, copy, modify, merge, publish,
## distribute, sublicense, and/or sell copies of the Software, and to
## permit persons to whom the Software is furnished to do so, subject to
## the following conditions:
#
## The above copyright notice and this permission notice shall be
## included in all copies or substantial portions of the Software.
#
## THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
## EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
## MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
## IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
## CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
## TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
## SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
#
##############################################################################

import sys
import getopt
from xml.dom import minidom
from xml.dom import Node


#
# Support/utility functions.
#

def showIndent(outfile, level):
    for idx in range(level):
        outfile.write('    ')


def showIndentHtml(outfile, level):
    for idx in range(level):
        outfile.write(' &nbsp; &nbsp; &nbsp; &nbsp;')


def quote_xml(inStr):
    s1 = inStr
    s1 = s1.replace('&', '&amp;')
    s1 = s1.replace('<', '&lt;')
    s1 = s1.replace('"', '&quot;')
    return s1

def quote_python(inStr):
    s1 = inStr
    if s1.find("'") == -1:
        if s1.find('\n') == -1:
            return "'%s'" % s1
        else:
            return "'''%s'''" % s1
    else:
        if s1.find('"') != -1:
            s1 = s1.replace('"', '\\"')
        if s1.find('\n') == -1:
            return '"%s"' % s1
        else:
            return '"""%s"""' % s1


class MixedContainer(object):
    # Constants for category:
    CategoryNone = 0
    CategoryText = 1
    CategorySimple = 2
    CategoryComplex = 3
    # Constants for content_type:
    TypeNone = 0
    TypeText = 1
    TypeString = 2
    TypeInteger = 3
    TypeFloat = 4
    TypeDecimal = 5
    TypeDouble = 6
    TypeBoolean = 7
    def __init__(self, category, content_type, name, value):
        self.category = category
        self.content_type = content_type
        self.name = name
        self.value = value
    def getCategory(self):
        return self.category
    def getContenttype(self, content_type):
        return self.content_type
    def getValue(self):
        return self.value
    def getName(self):
        return self.name
    def export(self, outfile, level, name):
        if self.category == MixedContainer.CategoryText:
            outfile.write(self.value)
        elif self.category == MixedContainer.CategorySimple:
            self.exportSimple(outfile, level, name)
        else:    # category == MixedContainer.CategoryComplex
            self.value.export(outfile, level, name)
    def exportSimple(self, outfile, level, name):
        if self.content_type == MixedContainer.TypeString:
            outfile.write('<%s>%s</%s>' % (self.name, self.value, self.name))
        elif self.content_type == MixedContainer.TypeInteger or \
                self.content_type == MixedContainer.TypeBoolean:
            outfile.write('<%s>%d</%s>' % (self.name, self.value, self.name))
        elif self.content_type == MixedContainer.TypeFloat or \
                self.content_type == MixedContainer.TypeDecimal:
            outfile.write('<%s>%f</%s>' % (self.name, self.value, self.name))
        elif self.content_type == MixedContainer.TypeDouble:
            outfile.write('<%s>%g</%s>' % (self.name, self.value, self.name))
    def exportLiteral(self, outfile, level, name):
        if self.category == MixedContainer.CategoryText:
            showIndent(outfile, level)
            outfile.write('MixedContainer(%d, %d, "%s", "%s"),\n' % \
                (self.category, self.content_type, self.name, self.value))
        elif self.category == MixedContainer.CategorySimple:
            showIndent(outfile, level)
            outfile.write('MixedContainer(%d, %d, "%s", "%s"),\n' % \
                (self.category, self.content_type, self.name, self.value))
        else:    # category == MixedContainer.CategoryComplex
            showIndent(outfile, level)
            outfile.write('MixedContainer(%d, %d, "%s",\n' % \
                (self.category, self.content_type, self.name,))
            self.value.exportLiteral(outfile, level + 1)
            showIndent(outfile, level)
            outfile.write(')\n')



TEMPLATE_PAGE_P1 = """
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN" "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en">
<head>
    <title>AALib Plugin Data Description</title>
    <meta http-equiv="content-type" content="text/html; charset=utf-8">
    <meta name="description" content="AALib Plugin generation from XSD files">
    <meta name="keywords" content="AALib, xsd, plugin">
    <meta name="author" content="Romeu Pieritz(romeu_pieritz@yahoo.fr)">
    <link href="style.css" rel="stylesheet" type="text/css">
    <base target="main">
</head>
<body>
    <div id="main">
        <div id="block">
          %s
    </div>
"""

TEMPLATE_PAGE_P2 = """
    </div>
</body>
</html>
"""



#
# Class definition
#

class kappa_alignment(object):
    subclass = None
    def __init__(self, v1='', v2='', close='', comment=''):
        self.v1 = v1
        self.v2 = v2
        self.close = close
        self.comment = comment
    def factory(*args_, **kwargs_):
        if kappa_alignment.subclass:
            return kappa_alignment.subclass(*args_, **kwargs_)
        else:
            return kappa_alignment(*args_, **kwargs_)
    factory = staticmethod(factory)
    def getV1(self): return self.v1
    def setV1(self, v1): self.v1 = v1
    def getV2(self): return self.v2
    def setV2(self, v2): self.v2 = v2
    def getClose(self): return self.close
    def setClose(self, close): self.close = close
    def getComment(self): return self.comment
    def setComment(self, comment): self.comment = comment
    def export(self, outfile, level = 0, name_='kappa_alignment'):
        showIndent(outfile, level)
        outfile.write('<%s>\n' % name_)
        self.exportChildren(outfile, level + 1, name_)
        showIndent(outfile, level)
        outfile.write('</%s>\n' % name_)
    def exportAttributes(self, outfile, level, name_='kappa_alignment'):
        pass
    def exportChildren(self, outfile, level, name_='kappa_alignment'):
        showIndent(outfile, level)
        outfile.write('<v1>%s</v1>\n' % quote_xml(self.getV1()))
        showIndent(outfile, level)
        outfile.write('<v2>%s</v2>\n' % quote_xml(self.getV2()))
        showIndent(outfile, level)
        outfile.write('<close>%s</close>\n' % quote_xml(self.getClose()))
        showIndent(outfile, level)
        outfile.write('<comment>%s</comment>\n' % quote_xml(self.getComment()))

    #Only to export the entire XML tree to a file stream on disk
    def outputFile( self, _outfileName ):
        outfile = open( _outfileName, "w" )
        outfile.write("<?xml version=\"1.0\" ?>\n")
        self.export( outfile, 0, name_='kappa_alignment' )
        outfile.close()


    #Only to export the entire XML tree to a Html Page in a file stream on disk
    def outputPageHtml( self, _outfileName ):
        odtStrTitle = "    <span class=\"title\">kappa_alignment:</span> <br> <br> <br>\n" 
        outfile = open( _outfileName, "w" )
        outfile.write( TEMPLATE_PAGE_P1 % ( odtStrTitle ) )
        self.exportLiteralHtml( outfile, 0, name_='kappa_alignment' )
        outfile.write( TEMPLATE_PAGE_P2  )
        outfile.close()


    def outputFileHtml( self, _outfileName ):
        self.outputPageHtml( _outfileName )



    #Static method for parsing a string
    def parseString( _inString ):
        doc = minidom.parseString(_inString)
        rootNode = doc.documentElement
        rootObj = kappa_alignment.factory()
        rootObj.build(rootNode)
        return rootObj
    parseString = staticmethod( parseString ) 


    #Method for marshalling an object
    def marshal( self ):
        oStreamString = StringIO.StringIO()
        oStreamString.write('<?xml version="1.0" ?>\n')
        self.export( oStreamString, 0, name_="kappa_alignment" )
        oStringXML = oStreamString.getvalue()
        oStreamString.close()
        return oStringXML

    def exportLiteral(self, outfile, level = 0, name_='kappa_alignment'):
        level += 1
        self.exportLiteralAttributes(outfile, level, name_)
        self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('v1 = %s,\n' % quote_python(self.getV1()))
        showIndent(outfile, level)
        outfile.write('v2 = %s,\n' % quote_python(self.getV2()))
        showIndent(outfile, level)
        outfile.write('close = %s,\n' % quote_python(self.getClose()))
        showIndent(outfile, level)
        outfile.write('comment = %s,\n' % quote_python(self.getComment()))
    def exportLiteralHtml(self, outfile, level = 0, name_='kappa_alignment'):
        level += 1
        self.exportLiteralAttributesHtml(outfile, level, name_)
        self.exportLiteralChildrenHtml(outfile, level, name_)
    def exportLiteralAttributesHtml(self, outfile, level, name_):
        pass
    def exportLiteralChildrenHtml(self, outfile, level, name_):
        showIndentHtml(outfile, level)
        outfile.write('v1 = <a  href:"#">%s</a><br>\n' % quote_python(self.getV1()))
        showIndentHtml(outfile, level)
        outfile.write('v2 = <a  href:"#">%s</a><br>\n' % quote_python(self.getV2()))
        showIndentHtml(outfile, level)
        outfile.write('close = <a  href:"#">%s</a><br>\n' % quote_python(self.getClose()))
        showIndentHtml(outfile, level)
        outfile.write('comment = <a  href:"#">%s</a><br>\n' % quote_python(self.getComment()))
    def build(self, node_):
        attrs = node_.attributes
        self.buildAttributes(attrs)
        for child_ in node_.childNodes:
            nodeName_ = child_.nodeName.split(':')[-1]
            self.buildChildren(child_, nodeName_)
    def buildAttributes(self, attrs):
        pass
    def buildChildren(self, child_, nodeName_):
        if child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'v1':
            v1_ = ''
            for text__content_ in child_.childNodes:
                v1_ += text__content_.nodeValue
            self.v1 = v1_
        elif child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'v2':
            v2_ = ''
            for text__content_ in child_.childNodes:
                v2_ += text__content_.nodeValue
            self.v2 = v2_
        elif child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'close':
            close_ = ''
            for text__content_ in child_.childNodes:
                close_ += text__content_.nodeValue
            self.close = close_
        elif child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'comment':
            comment_ = ''
            for text__content_ in child_.childNodes:
                comment_ += text__content_.nodeValue
            self.comment = comment_
# end class kappa_alignment


class kappa_alignment_request(object):
    subclass = None
    def __init__(self, desired_orientation=None, comment=''):
        if desired_orientation is None:
            self.desired_orientation = []
        else:
            self.desired_orientation = desired_orientation
        self.comment = comment
    def factory(*args_, **kwargs_):
        if kappa_alignment_request.subclass:
            return kappa_alignment_request.subclass(*args_, **kwargs_)
        else:
            return kappa_alignment_request(*args_, **kwargs_)
    factory = staticmethod(factory)
    def getDesired_orientation(self): return self.desired_orientation
    def setDesired_orientation(self, desired_orientation): self.desired_orientation = desired_orientation
    def addDesired_orientation(self, value): self.desired_orientation.append(value)
    def insertDesired_orientation(self, index, value): self.desired_orientation[index] = value
    def getComment(self): return self.comment
    def setComment(self, comment): self.comment = comment
    def export(self, outfile, level = 0, name_='kappa_alignment_request'):
        showIndent(outfile, level)
        outfile.write('<%s>\n' % name_)
        self.exportChildren(outfile, level + 1, name_)
        showIndent(outfile, level)
        outfile.write('</%s>\n' % name_)
    def exportAttributes(self, outfile, level, name_='kappa_alignment_request'):
        pass
    def exportChildren(self, outfile, level, name_='kappa_alignment_request'):
        for desired_orientation_ in self.getDesired_orientation():
            desired_orientation_.export(outfile, level, name_='desired_orientation')
        showIndent(outfile, level)
        outfile.write('<comment>%s</comment>\n' % quote_xml(self.getComment()))

    #Only to export the entire XML tree to a file stream on disk
    def outputFile( self, _outfileName ):
        outfile = open( _outfileName, "w" )
        outfile.write("<?xml version=\"1.0\" ?>\n")
        self.export( outfile, 0, name_='kappa_alignment_request' )
        outfile.close()


    #Only to export the entire XML tree to a Html Page in a file stream on disk
    def outputPageHtml( self, _outfileName ):
        odtStrTitle = "    <span class=\"title\">kappa_alignment_request:</span> <br> <br> <br>\n" 
        outfile = open( _outfileName, "w" )
        outfile.write( TEMPLATE_PAGE_P1 % ( odtStrTitle ) )
        self.exportLiteralHtml( outfile, 0, name_='kappa_alignment_request' )
        outfile.write( TEMPLATE_PAGE_P2  )
        outfile.close()


    def outputFileHtml( self, _outfileName ):
        self.outputPageHtml( _outfileName )



    #Static method for parsing a string
    def parseString( _inString ):
        doc = minidom.parseString(_inString)
        rootNode = doc.documentElement
        rootObj = kappa_alignment_request.factory()
        rootObj.build(rootNode)
        return rootObj
    parseString = staticmethod( parseString ) 


    #Method for marshalling an object
    def marshal( self ):
        oStreamString = StringIO.StringIO()
        oStreamString.write('<?xml version="1.0" ?>\n')
        self.export( oStreamString, 0, name_="kappa_alignment_request" )
        oStringXML = oStreamString.getvalue()
        oStreamString.close()
        return oStringXML

    def exportLiteral(self, outfile, level = 0, name_='kappa_alignment_request'):
        level += 1
        self.exportLiteralAttributes(outfile, level, name_)
        self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('desired_orientation=[\n')
        level += 1
        for desired_orientation in self.desired_orientation:
            showIndent(outfile, level)
            outfile.write('kappa_alignment(\n')
            desired_orientation.exportLiteral(outfile, level, name_='desired_orientation')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('comment = %s,\n' % quote_python(self.getComment()))
    def exportLiteralHtml(self, outfile, level = 0, name_='kappa_alignment_request'):
        level += 1
        self.exportLiteralAttributesHtml(outfile, level, name_)
        self.exportLiteralChildrenHtml(outfile, level, name_)
    def exportLiteralAttributesHtml(self, outfile, level, name_):
        pass
    def exportLiteralChildrenHtml(self, outfile, level, name_):
        showIndentHtml(outfile, level)
        outfile.write('desired_orientation<br>\n')
        level += 1
        for desired_orientation in self.desired_orientation:
            desired_orientation.exportLiteralHtml(outfile, level, name_='desired_orientation')
            showIndentHtml(outfile, level)
            outfile.write('<br>\n')
        level -= 1
        showIndentHtml(outfile, level)
        outfile.write('<br>\n')
        showIndentHtml(outfile, level)
        outfile.write('comment = <a  href:"#">%s</a><br>\n' % quote_python(self.getComment()))
    def build(self, node_):
        attrs = node_.attributes
        self.buildAttributes(attrs)
        for child_ in node_.childNodes:
            nodeName_ = child_.nodeName.split(':')[-1]
            self.buildChildren(child_, nodeName_)
    def buildAttributes(self, attrs):
        pass
    def buildChildren(self, child_, nodeName_):
        if child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'desired_orientation':
            obj_ = kappa_alignment.factory()
            obj_.build(child_)
            self.desired_orientation.append(obj_)
        elif child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'comment':
            comment_ = ''
            for text__content_ in child_.childNodes:
                comment_ += text__content_.nodeValue
            self.comment = comment_
# end class kappa_alignment_request


class kappa_possible_alignment(object):
    subclass = None
    def __init__(self, v1='', v2='', omega=0.0, kappa=0.0, phi=0.0, trans='', rank=0.0):
        self.v1 = v1
        self.v2 = v2
        self.omega = omega
        self.kappa = kappa
        self.phi = phi
        self.trans = trans
        self.rank = rank
    def factory(*args_, **kwargs_):
        if kappa_possible_alignment.subclass:
            return kappa_possible_alignment.subclass(*args_, **kwargs_)
        else:
            return kappa_possible_alignment(*args_, **kwargs_)
    factory = staticmethod(factory)
    def getV1(self): return self.v1
    def setV1(self, v1): self.v1 = v1
    def getV2(self): return self.v2
    def setV2(self, v2): self.v2 = v2
    def getOmega(self): return self.omega
    def setOmega(self, omega): self.omega = omega
    def getKappa(self): return self.kappa
    def setKappa(self, kappa): self.kappa = kappa
    def getPhi(self): return self.phi
    def setPhi(self, phi): self.phi = phi
    def getTrans(self): return self.trans
    def setTrans(self, trans): self.trans = trans
    def getRank(self): return self.rank
    def setRank(self, rank): self.rank = rank
    def export(self, outfile, level = 0, name_='kappa_possible_alignment'):
        showIndent(outfile, level)
        outfile.write('<%s>\n' % name_)
        self.exportChildren(outfile, level + 1, name_)
        showIndent(outfile, level)
        outfile.write('</%s>\n' % name_)
    def exportAttributes(self, outfile, level, name_='kappa_possible_alignment'):
        pass
    def exportChildren(self, outfile, level, name_='kappa_possible_alignment'):
        showIndent(outfile, level)
        outfile.write('<v1>%s</v1>\n' % quote_xml(self.getV1()))
        showIndent(outfile, level)
        outfile.write('<v2>%s</v2>\n' % quote_xml(self.getV2()))
        showIndent(outfile, level)
        outfile.write('<omega>%e</omega>\n' % self.getOmega())
        showIndent(outfile, level)
        outfile.write('<kappa>%e</kappa>\n' % self.getKappa())
        showIndent(outfile, level)
        outfile.write('<phi>%e</phi>\n' % self.getPhi())
        showIndent(outfile, level)
        outfile.write('<trans>%s</trans>\n' % quote_xml(self.getTrans()))
        showIndent(outfile, level)
        outfile.write('<rank>%e</rank>\n' % self.getRank())

    #Only to export the entire XML tree to a file stream on disk
    def outputFile( self, _outfileName ):
        outfile = open( _outfileName, "w" )
        outfile.write("<?xml version=\"1.0\" ?>\n")
        self.export( outfile, 0, name_='kappa_possible_alignment' )
        outfile.close()


    #Only to export the entire XML tree to a Html Page in a file stream on disk
    def outputPageHtml( self, _outfileName ):
        odtStrTitle = "    <span class=\"title\">kappa_possible_alignment:</span> <br> <br> <br>\n" 
        outfile = open( _outfileName, "w" )
        outfile.write( TEMPLATE_PAGE_P1 % ( odtStrTitle ) )
        self.exportLiteralHtml( outfile, 0, name_='kappa_possible_alignment' )
        outfile.write( TEMPLATE_PAGE_P2  )
        outfile.close()


    def outputFileHtml( self, _outfileName ):
        self.outputPageHtml( _outfileName )



    #Static method for parsing a string
    def parseString( _inString ):
        doc = minidom.parseString(_inString)
        rootNode = doc.documentElement
        rootObj = kappa_possible_alignment.factory()
        rootObj.build(rootNode)
        return rootObj
    parseString = staticmethod( parseString ) 


    #Method for marshalling an object
    def marshal( self ):
        oStreamString = StringIO.StringIO()
        oStreamString.write('<?xml version="1.0" ?>\n')
        self.export( oStreamString, 0, name_="kappa_possible_alignment" )
        oStringXML = oStreamString.getvalue()
        oStreamString.close()
        return oStringXML

    def exportLiteral(self, outfile, level = 0, name_='kappa_possible_alignment'):
        level += 1
        self.exportLiteralAttributes(outfile, level, name_)
        self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('v1 = %s,\n' % quote_python(self.getV1()))
        showIndent(outfile, level)
        outfile.write('v2 = %s,\n' % quote_python(self.getV2()))
        showIndent(outfile, level)
        outfile.write('omega = %e,\n' % self.getOmega())
        showIndent(outfile, level)
        outfile.write('kappa = %e,\n' % self.getKappa())
        showIndent(outfile, level)
        outfile.write('phi = %e,\n' % self.getPhi())
        showIndent(outfile, level)
        outfile.write('trans = %s,\n' % quote_python(self.getTrans()))
        showIndent(outfile, level)
        outfile.write('rank = %e,\n' % self.getRank())
    def exportLiteralHtml(self, outfile, level = 0, name_='kappa_possible_alignment'):
        level += 1
        self.exportLiteralAttributesHtml(outfile, level, name_)
        self.exportLiteralChildrenHtml(outfile, level, name_)
    def exportLiteralAttributesHtml(self, outfile, level, name_):
        pass
    def exportLiteralChildrenHtml(self, outfile, level, name_):
        showIndentHtml(outfile, level)
        outfile.write('v1 = <a  href:"#">%s</a><br>\n' % quote_python(self.getV1()))
        showIndentHtml(outfile, level)
        outfile.write('v2 = <a  href:"#">%s</a><br>\n' % quote_python(self.getV2()))
        showIndentHtml(outfile, level)
        outfile.write('omega = <a  href:"#">%e</a><br>\n' % self.getOmega())
        showIndentHtml(outfile, level)
        outfile.write('kappa = <a  href:"#">%e</a><br>\n' % self.getKappa())
        showIndentHtml(outfile, level)
        outfile.write('phi = <a  href:"#">%e</a><br>\n' % self.getPhi())
        showIndentHtml(outfile, level)
        outfile.write('trans = <a  href:"#">%s</a><br>\n' % quote_python(self.getTrans()))
        showIndentHtml(outfile, level)
        outfile.write('rank = <a  href:"#">%e</a><br>\n' % self.getRank())
    def build(self, node_):
        attrs = node_.attributes
        self.buildAttributes(attrs)
        for child_ in node_.childNodes:
            nodeName_ = child_.nodeName.split(':')[-1]
            self.buildChildren(child_, nodeName_)
    def buildAttributes(self, attrs):
        pass
    def buildChildren(self, child_, nodeName_):
        if child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'v1':
            v1_ = ''
            for text__content_ in child_.childNodes:
                v1_ += text__content_.nodeValue
            self.v1 = v1_
        elif child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'v2':
            v2_ = ''
            for text__content_ in child_.childNodes:
                v2_ += text__content_.nodeValue
            self.v2 = v2_
        elif child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'omega':
            if child_.firstChild:
                sval_ = child_.firstChild.nodeValue
                try:
                    fval_ = float(sval_)
                except ValueError:
                    raise ValueError('requires float (or double) -- %s' % child_.toxml())
                self.omega = fval_
        elif child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'kappa':
            if child_.firstChild:
                sval_ = child_.firstChild.nodeValue
                try:
                    fval_ = float(sval_)
                except ValueError:
                    raise ValueError('requires float (or double) -- %s' % child_.toxml())
                self.kappa = fval_
        elif child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'phi':
            if child_.firstChild:
                sval_ = child_.firstChild.nodeValue
                try:
                    fval_ = float(sval_)
                except ValueError:
                    raise ValueError('requires float (or double) -- %s' % child_.toxml())
                self.phi = fval_
        elif child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'trans':
            trans_ = ''
            for text__content_ in child_.childNodes:
                trans_ += text__content_.nodeValue
            self.trans = trans_
        elif child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'rank':
            if child_.firstChild:
                sval_ = child_.firstChild.nodeValue
                try:
                    fval_ = float(sval_)
                except ValueError:
                    raise ValueError('requires float (or double) -- %s' % child_.toxml())
                self.rank = fval_
# end class kappa_possible_alignment


class kappa_alignment_response(object):
    subclass = None
    def __init__(self, status=None, comment='', possible_orientation=None):
        self.status = status
        self.comment = comment
        if possible_orientation is None:
            self.possible_orientation = []
        else:
            self.possible_orientation = possible_orientation
    def factory(*args_, **kwargs_):
        if kappa_alignment_response.subclass:
            return kappa_alignment_response.subclass(*args_, **kwargs_)
        else:
            return kappa_alignment_response(*args_, **kwargs_)
    factory = staticmethod(factory)
    def getStatus(self): return self.status
    def setStatus(self, status): self.status = status
    def getComment(self): return self.comment
    def setComment(self, comment): self.comment = comment
    def getPossible_orientation(self): return self.possible_orientation
    def setPossible_orientation(self, possible_orientation): self.possible_orientation = possible_orientation
    def addPossible_orientation(self, value): self.possible_orientation.append(value)
    def insertPossible_orientation(self, index, value): self.possible_orientation[index] = value
    def export(self, outfile, level = 0, name_='kappa_alignment_response'):
        showIndent(outfile, level)
        outfile.write('<%s>\n' % name_)
        self.exportChildren(outfile, level + 1, name_)
        showIndent(outfile, level)
        outfile.write('</%s>\n' % name_)
    def exportAttributes(self, outfile, level, name_='kappa_alignment_response'):
        pass
    def exportChildren(self, outfile, level, name_='kappa_alignment_response'):
        if self.status:
            self.status.export(outfile, level)
        showIndent(outfile, level)
        outfile.write('<comment>%s</comment>\n' % quote_xml(self.getComment()))
        for possible_orientation_ in self.getPossible_orientation():
            possible_orientation_.export(outfile, level, name_='possible_orientation')

    #Only to export the entire XML tree to a file stream on disk
    def outputFile( self, _outfileName ):
        outfile = open( _outfileName, "w" )
        outfile.write("<?xml version=\"1.0\" ?>\n")
        self.export( outfile, 0, name_='kappa_alignment_response' )
        outfile.close()


    #Only to export the entire XML tree to a Html Page in a file stream on disk
    def outputPageHtml( self, _outfileName ):
        odtStrTitle = "    <span class=\"title\">kappa_alignment_response:</span> <br> <br> <br>\n" 
        outfile = open( _outfileName, "w" )
        outfile.write( TEMPLATE_PAGE_P1 % ( odtStrTitle ) )
        self.exportLiteralHtml( outfile, 0, name_='kappa_alignment_response' )
        outfile.write( TEMPLATE_PAGE_P2  )
        outfile.close()


    def outputFileHtml( self, _outfileName ):
        self.outputPageHtml( _outfileName )



    #Static method for parsing a string
    def parseString( _inString ):
        doc = minidom.parseString(_inString)
        rootNode = doc.documentElement
        rootObj = kappa_alignment_response.factory()
        rootObj.build(rootNode)
        return rootObj
    parseString = staticmethod( parseString ) 


    #Method for marshalling an object
    def marshal( self ):
        oStreamString = StringIO.StringIO()
        oStreamString.write('<?xml version="1.0" ?>\n')
        self.export( oStreamString, 0, name_="kappa_alignment_response" )
        oStringXML = oStreamString.getvalue()
        oStreamString.close()
        return oStringXML

    def exportLiteral(self, outfile, level = 0, name_='kappa_alignment_response'):
        level += 1
        self.exportLiteralAttributes(outfile, level, name_)
        self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.status:
            showIndent(outfile, level)
            outfile.write('status = status(\n')
            self.status.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        showIndent(outfile, level)
        outfile.write('comment = %s,\n' % quote_python(self.getComment()))
        showIndent(outfile, level)
        outfile.write('possible_orientation=[\n')
        level += 1
        for possible_orientation in self.possible_orientation:
            showIndent(outfile, level)
            outfile.write('kappa_possible_alignment(\n')
            possible_orientation.exportLiteral(outfile, level, name_='possible_orientation')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def exportLiteralHtml(self, outfile, level = 0, name_='kappa_alignment_response'):
        level += 1
        self.exportLiteralAttributesHtml(outfile, level, name_)
        self.exportLiteralChildrenHtml(outfile, level, name_)
    def exportLiteralAttributesHtml(self, outfile, level, name_):
        pass
    def exportLiteralChildrenHtml(self, outfile, level, name_):
        if self.status:
            showIndentHtml(outfile, level)
            outfile.write('status<br>\n')
            self.status.exportLiteralHtml(outfile, level)
            showIndentHtml(outfile, level)
            outfile.write('<br>\n')
        showIndentHtml(outfile, level)
        outfile.write('comment = <a  href:"#">%s</a><br>\n' % quote_python(self.getComment()))
        showIndentHtml(outfile, level)
        outfile.write('possible_orientation<br>\n')
        level += 1
        for possible_orientation in self.possible_orientation:
            possible_orientation.exportLiteralHtml(outfile, level, name_='possible_orientation')
            showIndentHtml(outfile, level)
            outfile.write('<br>\n')
        level -= 1
        showIndentHtml(outfile, level)
        outfile.write('<br>\n')
    def build(self, node_):
        attrs = node_.attributes
        self.buildAttributes(attrs)
        for child_ in node_.childNodes:
            nodeName_ = child_.nodeName.split(':')[-1]
            self.buildChildren(child_, nodeName_)
    def buildAttributes(self, attrs):
        pass
    def buildChildren(self, child_, nodeName_):
        if child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'status':
            obj_ = status.factory()
            obj_.build(child_)
            self.setStatus(obj_)
        elif child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'comment':
            comment_ = ''
            for text__content_ in child_.childNodes:
                comment_ += text__content_.nodeValue
            self.comment = comment_
        elif child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'possible_orientation':
            obj_ = kappa_possible_alignment.factory()
            obj_.build(child_)
            self.possible_orientation.append(obj_)
# end class kappa_alignment_response


class kappa_strategy_request(object):
    subclass = None
    def __init__(self, comment='', desired_datum=None, standard_request=None):
        self.comment = comment
        if desired_datum is None:
            self.desired_datum = []
        else:
            self.desired_datum = desired_datum
        self.standard_request = standard_request
    def factory(*args_, **kwargs_):
        if kappa_strategy_request.subclass:
            return kappa_strategy_request.subclass(*args_, **kwargs_)
        else:
            return kappa_strategy_request(*args_, **kwargs_)
    factory = staticmethod(factory)
    def getComment(self): return self.comment
    def setComment(self, comment): self.comment = comment
    def getDesired_datum(self): return self.desired_datum
    def setDesired_datum(self, desired_datum): self.desired_datum = desired_datum
    def addDesired_datum(self, value): self.desired_datum.append(value)
    def insertDesired_datum(self, index, value): self.desired_datum[index] = value
    def getStandard_request(self): return self.standard_request
    def setStandard_request(self, standard_request): self.standard_request = standard_request
    def export(self, outfile, level = 0, name_='kappa_strategy_request'):
        showIndent(outfile, level)
        outfile.write('<%s>\n' % name_)
        self.exportChildren(outfile, level + 1, name_)
        showIndent(outfile, level)
        outfile.write('</%s>\n' % name_)
    def exportAttributes(self, outfile, level, name_='kappa_strategy_request'):
        pass
    def exportChildren(self, outfile, level, name_='kappa_strategy_request'):
        showIndent(outfile, level)
        outfile.write('<comment>%s</comment>\n' % quote_xml(self.getComment()))
        for desired_datum_ in self.getDesired_datum():
            desired_datum_.export(outfile, level, name_='desired_datum')
        if self.standard_request:
            self.standard_request.export(outfile, level, name_='standard_request')

    #Only to export the entire XML tree to a file stream on disk
    def outputFile( self, _outfileName ):
        outfile = open( _outfileName, "w" )
        outfile.write("<?xml version=\"1.0\" ?>\n")
        self.export( outfile, 0, name_='kappa_strategy_request' )
        outfile.close()


    #Only to export the entire XML tree to a Html Page in a file stream on disk
    def outputPageHtml( self, _outfileName ):
        odtStrTitle = "    <span class=\"title\">kappa_strategy_request:</span> <br> <br> <br>\n" 
        outfile = open( _outfileName, "w" )
        outfile.write( TEMPLATE_PAGE_P1 % ( odtStrTitle ) )
        self.exportLiteralHtml( outfile, 0, name_='kappa_strategy_request' )
        outfile.write( TEMPLATE_PAGE_P2  )
        outfile.close()


    def outputFileHtml( self, _outfileName ):
        self.outputPageHtml( _outfileName )



    #Static method for parsing a string
    def parseString( _inString ):
        doc = minidom.parseString(_inString)
        rootNode = doc.documentElement
        rootObj = kappa_strategy_request.factory()
        rootObj.build(rootNode)
        return rootObj
    parseString = staticmethod( parseString ) 


    #Method for marshalling an object
    def marshal( self ):
        oStreamString = StringIO.StringIO()
        oStreamString.write('<?xml version="1.0" ?>\n')
        self.export( oStreamString, 0, name_="kappa_strategy_request" )
        oStringXML = oStreamString.getvalue()
        oStreamString.close()
        return oStringXML

    def exportLiteral(self, outfile, level = 0, name_='kappa_strategy_request'):
        level += 1
        self.exportLiteralAttributes(outfile, level, name_)
        self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('comment = %s,\n' % quote_python(self.getComment()))
        showIndent(outfile, level)
        outfile.write('desired_datum=[\n')
        level += 1
        for desired_datum in self.desired_datum:
            showIndent(outfile, level)
            outfile.write('kappa_possible_alignment(\n')
            desired_datum.exportLiteral(outfile, level, name_='desired_datum')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        if self.standard_request:
            showIndent(outfile, level)
            outfile.write('standard_request = strategy_request(\n')
            self.standard_request.exportLiteral(outfile, level, name_='standard_request')
            showIndent(outfile, level)
            outfile.write('),\n')
    def exportLiteralHtml(self, outfile, level = 0, name_='kappa_strategy_request'):
        level += 1
        self.exportLiteralAttributesHtml(outfile, level, name_)
        self.exportLiteralChildrenHtml(outfile, level, name_)
    def exportLiteralAttributesHtml(self, outfile, level, name_):
        pass
    def exportLiteralChildrenHtml(self, outfile, level, name_):
        showIndentHtml(outfile, level)
        outfile.write('comment = <a  href:"#">%s</a><br>\n' % quote_python(self.getComment()))
        showIndentHtml(outfile, level)
        outfile.write('desired_datum<br>\n')
        level += 1
        for desired_datum in self.desired_datum:
            desired_datum.exportLiteralHtml(outfile, level, name_='desired_datum')
            showIndentHtml(outfile, level)
            outfile.write('<br>\n')
        level -= 1
        showIndentHtml(outfile, level)
        outfile.write('<br>\n')
        if self.standard_request:
            showIndentHtml(outfile, level)
            outfile.write('standard_request<br>\n')
            self.standard_request.exportLiteralHtml(outfile, level, name_='standard_request')
            showIndentHtml(outfile, level)
            outfile.write('<br>\n')
    def build(self, node_):
        attrs = node_.attributes
        self.buildAttributes(attrs)
        for child_ in node_.childNodes:
            nodeName_ = child_.nodeName.split(':')[-1]
            self.buildChildren(child_, nodeName_)
    def buildAttributes(self, attrs):
        pass
    def buildChildren(self, child_, nodeName_):
        if child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'comment':
            comment_ = ''
            for text__content_ in child_.childNodes:
                comment_ += text__content_.nodeValue
            self.comment = comment_
        elif child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'desired_datum':
            obj_ = kappa_possible_alignment.factory()
            obj_.build(child_)
            self.desired_datum.append(obj_)
        elif child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'standard_request':
            obj_ = strategy_request.factory()
            obj_.build(child_)
            self.setStandard_request(obj_)
# end class kappa_strategy_request


class kappa_strategy_sweep(object):
    subclass = None
    def __init__(self, strategyID='', omegaStart=0.0, omegaEnd=0.0, kappa=0.0, phi=0.0, completeness=0.0, rank=0.0):
        self.strategyID = strategyID
        self.omegaStart = omegaStart
        self.omegaEnd = omegaEnd
        self.kappa = kappa
        self.phi = phi
        self.completeness = completeness
        self.rank = rank
    def factory(*args_, **kwargs_):
        if kappa_strategy_sweep.subclass:
            return kappa_strategy_sweep.subclass(*args_, **kwargs_)
        else:
            return kappa_strategy_sweep(*args_, **kwargs_)
    factory = staticmethod(factory)
    def getStrategyID(self): return self.strategyID
    def setStrategyID(self, strategyID): self.strategyID = strategyID
    def getOmegaStart(self): return self.omegaStart
    def setOmegaStart(self, omegaStart): self.omegaStart = omegaStart
    def getOmegaEnd(self): return self.omegaEnd
    def setOmegaEnd(self, omegaEnd): self.omegaEnd = omegaEnd
    def getKappa(self): return self.kappa
    def setKappa(self, kappa): self.kappa = kappa
    def getPhi(self): return self.phi
    def setPhi(self, phi): self.phi = phi
    def getCompleteness(self): return self.completeness
    def setCompleteness(self, completeness): self.completeness = completeness
    def getRank(self): return self.rank
    def setRank(self, rank): self.rank = rank
    def export(self, outfile, level = 0, name_='kappa_strategy_sweep'):
        showIndent(outfile, level)
        outfile.write('<%s>\n' % name_)
        self.exportChildren(outfile, level + 1, name_)
        showIndent(outfile, level)
        outfile.write('</%s>\n' % name_)
    def exportAttributes(self, outfile, level, name_='kappa_strategy_sweep'):
        pass
    def exportChildren(self, outfile, level, name_='kappa_strategy_sweep'):
        showIndent(outfile, level)
        outfile.write('<strategyID>%s</strategyID>\n' % quote_xml(self.getStrategyID()))
        showIndent(outfile, level)
        outfile.write('<omegaStart>%e</omegaStart>\n' % self.getOmegaStart())
        showIndent(outfile, level)
        outfile.write('<omegaEnd>%e</omegaEnd>\n' % self.getOmegaEnd())
        showIndent(outfile, level)
        outfile.write('<kappa>%e</kappa>\n' % self.getKappa())
        showIndent(outfile, level)
        outfile.write('<phi>%e</phi>\n' % self.getPhi())
        showIndent(outfile, level)
        outfile.write('<completeness>%e</completeness>\n' % self.getCompleteness())
        showIndent(outfile, level)
        outfile.write('<rank>%e</rank>\n' % self.getRank())

    #Only to export the entire XML tree to a file stream on disk
    def outputFile( self, _outfileName ):
        outfile = open( _outfileName, "w" )
        outfile.write("<?xml version=\"1.0\" ?>\n")
        self.export( outfile, 0, name_='kappa_strategy_sweep' )
        outfile.close()


    #Only to export the entire XML tree to a Html Page in a file stream on disk
    def outputPageHtml( self, _outfileName ):
        odtStrTitle = "    <span class=\"title\">kappa_strategy_sweep:</span> <br> <br> <br>\n" 
        outfile = open( _outfileName, "w" )
        outfile.write( TEMPLATE_PAGE_P1 % ( odtStrTitle ) )
        self.exportLiteralHtml( outfile, 0, name_='kappa_strategy_sweep' )
        outfile.write( TEMPLATE_PAGE_P2  )
        outfile.close()


    def outputFileHtml( self, _outfileName ):
        self.outputPageHtml( _outfileName )



    #Static method for parsing a string
    def parseString( _inString ):
        doc = minidom.parseString(_inString)
        rootNode = doc.documentElement
        rootObj = kappa_strategy_sweep.factory()
        rootObj.build(rootNode)
        return rootObj
    parseString = staticmethod( parseString ) 


    #Method for marshalling an object
    def marshal( self ):
        oStreamString = StringIO.StringIO()
        oStreamString.write('<?xml version="1.0" ?>\n')
        self.export( oStreamString, 0, name_="kappa_strategy_sweep" )
        oStringXML = oStreamString.getvalue()
        oStreamString.close()
        return oStringXML

    def exportLiteral(self, outfile, level = 0, name_='kappa_strategy_sweep'):
        level += 1
        self.exportLiteralAttributes(outfile, level, name_)
        self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('strategyID = %s,\n' % quote_python(self.getStrategyID()))
        showIndent(outfile, level)
        outfile.write('omegaStart = %e,\n' % self.getOmegaStart())
        showIndent(outfile, level)
        outfile.write('omegaEnd = %e,\n' % self.getOmegaEnd())
        showIndent(outfile, level)
        outfile.write('kappa = %e,\n' % self.getKappa())
        showIndent(outfile, level)
        outfile.write('phi = %e,\n' % self.getPhi())
        showIndent(outfile, level)
        outfile.write('completeness = %e,\n' % self.getCompleteness())
        showIndent(outfile, level)
        outfile.write('rank = %e,\n' % self.getRank())
    def exportLiteralHtml(self, outfile, level = 0, name_='kappa_strategy_sweep'):
        level += 1
        self.exportLiteralAttributesHtml(outfile, level, name_)
        self.exportLiteralChildrenHtml(outfile, level, name_)
    def exportLiteralAttributesHtml(self, outfile, level, name_):
        pass
    def exportLiteralChildrenHtml(self, outfile, level, name_):
        showIndentHtml(outfile, level)
        outfile.write('strategyID = <a  href:"#">%s</a><br>\n' % quote_python(self.getStrategyID()))
        showIndentHtml(outfile, level)
        outfile.write('omegaStart = <a  href:"#">%e</a><br>\n' % self.getOmegaStart())
        showIndentHtml(outfile, level)
        outfile.write('omegaEnd = <a  href:"#">%e</a><br>\n' % self.getOmegaEnd())
        showIndentHtml(outfile, level)
        outfile.write('kappa = <a  href:"#">%e</a><br>\n' % self.getKappa())
        showIndentHtml(outfile, level)
        outfile.write('phi = <a  href:"#">%e</a><br>\n' % self.getPhi())
        showIndentHtml(outfile, level)
        outfile.write('completeness = <a  href:"#">%e</a><br>\n' % self.getCompleteness())
        showIndentHtml(outfile, level)
        outfile.write('rank = <a  href:"#">%e</a><br>\n' % self.getRank())
    def build(self, node_):
        attrs = node_.attributes
        self.buildAttributes(attrs)
        for child_ in node_.childNodes:
            nodeName_ = child_.nodeName.split(':')[-1]
            self.buildChildren(child_, nodeName_)
    def buildAttributes(self, attrs):
        pass
    def buildChildren(self, child_, nodeName_):
        if child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'strategyID':
            strategyID_ = ''
            for text__content_ in child_.childNodes:
                strategyID_ += text__content_.nodeValue
            self.strategyID = strategyID_
        elif child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'omegaStart':
            if child_.firstChild:
                sval_ = child_.firstChild.nodeValue
                try:
                    fval_ = float(sval_)
                except ValueError:
                    raise ValueError('requires float (or double) -- %s' % child_.toxml())
                self.omegaStart = fval_
        elif child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'omegaEnd':
            if child_.firstChild:
                sval_ = child_.firstChild.nodeValue
                try:
                    fval_ = float(sval_)
                except ValueError:
                    raise ValueError('requires float (or double) -- %s' % child_.toxml())
                self.omegaEnd = fval_
        elif child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'kappa':
            if child_.firstChild:
                sval_ = child_.firstChild.nodeValue
                try:
                    fval_ = float(sval_)
                except ValueError:
                    raise ValueError('requires float (or double) -- %s' % child_.toxml())
                self.kappa = fval_
        elif child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'phi':
            if child_.firstChild:
                sval_ = child_.firstChild.nodeValue
                try:
                    fval_ = float(sval_)
                except ValueError:
                    raise ValueError('requires float (or double) -- %s' % child_.toxml())
                self.phi = fval_
        elif child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'completeness':
            if child_.firstChild:
                sval_ = child_.firstChild.nodeValue
                try:
                    fval_ = float(sval_)
                except ValueError:
                    raise ValueError('requires float (or double) -- %s' % child_.toxml())
                self.completeness = fval_
        elif child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'rank':
            if child_.firstChild:
                sval_ = child_.firstChild.nodeValue
                try:
                    fval_ = float(sval_)
                except ValueError:
                    raise ValueError('requires float (or double) -- %s' % child_.toxml())
                self.rank = fval_
# end class kappa_strategy_sweep


class kappa_strategy_response(object):
    subclass = None
    def __init__(self, status=None, comment='', generated_sweep=None, standard_response=None):
        self.status = status
        self.comment = comment
        if generated_sweep is None:
            self.generated_sweep = []
        else:
            self.generated_sweep = generated_sweep
        self.standard_response = standard_response
    def factory(*args_, **kwargs_):
        if kappa_strategy_response.subclass:
            return kappa_strategy_response.subclass(*args_, **kwargs_)
        else:
            return kappa_strategy_response(*args_, **kwargs_)
    factory = staticmethod(factory)
    def getStatus(self): return self.status
    def setStatus(self, status): self.status = status
    def getComment(self): return self.comment
    def setComment(self, comment): self.comment = comment
    def getGenerated_sweep(self): return self.generated_sweep
    def setGenerated_sweep(self, generated_sweep): self.generated_sweep = generated_sweep
    def addGenerated_sweep(self, value): self.generated_sweep.append(value)
    def insertGenerated_sweep(self, index, value): self.generated_sweep[index] = value
    def getStandard_response(self): return self.standard_response
    def setStandard_response(self, standard_response): self.standard_response = standard_response
    def export(self, outfile, level = 0, name_='kappa_strategy_response'):
        showIndent(outfile, level)
        outfile.write('<%s>\n' % name_)
        self.exportChildren(outfile, level + 1, name_)
        showIndent(outfile, level)
        outfile.write('</%s>\n' % name_)
    def exportAttributes(self, outfile, level, name_='kappa_strategy_response'):
        pass
    def exportChildren(self, outfile, level, name_='kappa_strategy_response'):
        if self.status:
            self.status.export(outfile, level)
        showIndent(outfile, level)
        outfile.write('<comment>%s</comment>\n' % quote_xml(self.getComment()))
        for generated_sweep_ in self.getGenerated_sweep():
            generated_sweep_.export(outfile, level, name_='generated_sweep')
        if self.standard_response:
            self.standard_response.export(outfile, level, name_='standard_response')

    #Only to export the entire XML tree to a file stream on disk
    def outputFile( self, _outfileName ):
        outfile = open( _outfileName, "w" )
        outfile.write("<?xml version=\"1.0\" ?>\n")
        self.export( outfile, 0, name_='kappa_strategy_response' )
        outfile.close()


    #Only to export the entire XML tree to a Html Page in a file stream on disk
    def outputPageHtml( self, _outfileName ):
        odtStrTitle = "    <span class=\"title\">kappa_strategy_response:</span> <br> <br> <br>\n" 
        outfile = open( _outfileName, "w" )
        outfile.write( TEMPLATE_PAGE_P1 % ( odtStrTitle ) )
        self.exportLiteralHtml( outfile, 0, name_='kappa_strategy_response' )
        outfile.write( TEMPLATE_PAGE_P2  )
        outfile.close()


    def outputFileHtml( self, _outfileName ):
        self.outputPageHtml( _outfileName )



    #Static method for parsing a string
    def parseString( _inString ):
        doc = minidom.parseString(_inString)
        rootNode = doc.documentElement
        rootObj = kappa_strategy_response.factory()
        rootObj.build(rootNode)
        return rootObj
    parseString = staticmethod( parseString ) 


    #Method for marshalling an object
    def marshal( self ):
        oStreamString = StringIO.StringIO()
        oStreamString.write('<?xml version="1.0" ?>\n')
        self.export( oStreamString, 0, name_="kappa_strategy_response" )
        oStringXML = oStreamString.getvalue()
        oStreamString.close()
        return oStringXML

    def exportLiteral(self, outfile, level = 0, name_='kappa_strategy_response'):
        level += 1
        self.exportLiteralAttributes(outfile, level, name_)
        self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.status:
            showIndent(outfile, level)
            outfile.write('status = status(\n')
            self.status.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        showIndent(outfile, level)
        outfile.write('comment = %s,\n' % quote_python(self.getComment()))
        showIndent(outfile, level)
        outfile.write('generated_sweep=[\n')
        level += 1
        for generated_sweep in self.generated_sweep:
            showIndent(outfile, level)
            outfile.write('kappa_strategy_sweep(\n')
            generated_sweep.exportLiteral(outfile, level, name_='generated_sweep')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        if self.standard_response:
            showIndent(outfile, level)
            outfile.write('standard_response = strategy_response(\n')
            self.standard_response.exportLiteral(outfile, level, name_='standard_response')
            showIndent(outfile, level)
            outfile.write('),\n')
    def exportLiteralHtml(self, outfile, level = 0, name_='kappa_strategy_response'):
        level += 1
        self.exportLiteralAttributesHtml(outfile, level, name_)
        self.exportLiteralChildrenHtml(outfile, level, name_)
    def exportLiteralAttributesHtml(self, outfile, level, name_):
        pass
    def exportLiteralChildrenHtml(self, outfile, level, name_):
        if self.status:
            showIndentHtml(outfile, level)
            outfile.write('status<br>\n')
            self.status.exportLiteralHtml(outfile, level)
            showIndentHtml(outfile, level)
            outfile.write('<br>\n')
        showIndentHtml(outfile, level)
        outfile.write('comment = <a  href:"#">%s</a><br>\n' % quote_python(self.getComment()))
        showIndentHtml(outfile, level)
        outfile.write('generated_sweep<br>\n')
        level += 1
        for generated_sweep in self.generated_sweep:
            generated_sweep.exportLiteralHtml(outfile, level, name_='generated_sweep')
            showIndentHtml(outfile, level)
            outfile.write('<br>\n')
        level -= 1
        showIndentHtml(outfile, level)
        outfile.write('<br>\n')
        if self.standard_response:
            showIndentHtml(outfile, level)
            outfile.write('standard_response<br>\n')
            self.standard_response.exportLiteralHtml(outfile, level, name_='standard_response')
            showIndentHtml(outfile, level)
            outfile.write('<br>\n')
    def build(self, node_):
        attrs = node_.attributes
        self.buildAttributes(attrs)
        for child_ in node_.childNodes:
            nodeName_ = child_.nodeName.split(':')[-1]
            self.buildChildren(child_, nodeName_)
    def buildAttributes(self, attrs):
        pass
    def buildChildren(self, child_, nodeName_):
        if child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'status':
            obj_ = status.factory()
            obj_.build(child_)
            self.setStatus(obj_)
        elif child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'comment':
            comment_ = ''
            for text__content_ in child_.childNodes:
                comment_ += text__content_.nodeValue
            self.comment = comment_
        elif child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'generated_sweep':
            obj_ = kappa_strategy_sweep.factory()
            obj_.build(child_)
            self.generated_sweep.append(obj_)
        elif child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'standard_response':
            obj_ = strategy_response.factory()
            obj_.build(child_)
            self.setStandard_response(obj_)
# end class kappa_strategy_response


class kappa_motor_setting(object):
    subclass = None
    def __init__(self, motorName='', motorValue=0.0, comment=''):
        self.motorName = motorName
        self.motorValue = motorValue
        self.comment = comment
    def factory(*args_, **kwargs_):
        if kappa_motor_setting.subclass:
            return kappa_motor_setting.subclass(*args_, **kwargs_)
        else:
            return kappa_motor_setting(*args_, **kwargs_)
    factory = staticmethod(factory)
    def getMotorName(self): return self.motorName
    def setMotorName(self, motorName): self.motorName = motorName
    def getMotorValue(self): return self.motorValue
    def setMotorValue(self, motorValue): self.motorValue = motorValue
    def getComment(self): return self.comment
    def setComment(self, comment): self.comment = comment
    def export(self, outfile, level = 0, name_='kappa_motor_setting'):
        showIndent(outfile, level)
        outfile.write('<%s>\n' % name_)
        self.exportChildren(outfile, level + 1, name_)
        showIndent(outfile, level)
        outfile.write('</%s>\n' % name_)
    def exportAttributes(self, outfile, level, name_='kappa_motor_setting'):
        pass
    def exportChildren(self, outfile, level, name_='kappa_motor_setting'):
        showIndent(outfile, level)
        outfile.write('<motorName>%s</motorName>\n' % quote_xml(self.getMotorName()))
        showIndent(outfile, level)
        outfile.write('<motorValue>%e</motorValue>\n' % self.getMotorValue())
        showIndent(outfile, level)
        outfile.write('<comment>%s</comment>\n' % quote_xml(self.getComment()))

    #Only to export the entire XML tree to a file stream on disk
    def outputFile( self, _outfileName ):
        outfile = open( _outfileName, "w" )
        outfile.write("<?xml version=\"1.0\" ?>\n")
        self.export( outfile, 0, name_='kappa_motor_setting' )
        outfile.close()


    #Only to export the entire XML tree to a Html Page in a file stream on disk
    def outputPageHtml( self, _outfileName ):
        odtStrTitle = "    <span class=\"title\">kappa_motor_setting:</span> <br> <br> <br>\n" 
        outfile = open( _outfileName, "w" )
        outfile.write( TEMPLATE_PAGE_P1 % ( odtStrTitle ) )
        self.exportLiteralHtml( outfile, 0, name_='kappa_motor_setting' )
        outfile.write( TEMPLATE_PAGE_P2  )
        outfile.close()


    def outputFileHtml( self, _outfileName ):
        self.outputPageHtml( _outfileName )



    #Static method for parsing a string
    def parseString( _inString ):
        doc = minidom.parseString(_inString)
        rootNode = doc.documentElement
        rootObj = kappa_motor_setting.factory()
        rootObj.build(rootNode)
        return rootObj
    parseString = staticmethod( parseString ) 


    #Method for marshalling an object
    def marshal( self ):
        oStreamString = StringIO.StringIO()
        oStreamString.write('<?xml version="1.0" ?>\n')
        self.export( oStreamString, 0, name_="kappa_motor_setting" )
        oStringXML = oStreamString.getvalue()
        oStreamString.close()
        return oStringXML

    def exportLiteral(self, outfile, level = 0, name_='kappa_motor_setting'):
        level += 1
        self.exportLiteralAttributes(outfile, level, name_)
        self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('motorName = %s,\n' % quote_python(self.getMotorName()))
        showIndent(outfile, level)
        outfile.write('motorValue = %e,\n' % self.getMotorValue())
        showIndent(outfile, level)
        outfile.write('comment = %s,\n' % quote_python(self.getComment()))
    def exportLiteralHtml(self, outfile, level = 0, name_='kappa_motor_setting'):
        level += 1
        self.exportLiteralAttributesHtml(outfile, level, name_)
        self.exportLiteralChildrenHtml(outfile, level, name_)
    def exportLiteralAttributesHtml(self, outfile, level, name_):
        pass
    def exportLiteralChildrenHtml(self, outfile, level, name_):
        showIndentHtml(outfile, level)
        outfile.write('motorName = <a  href:"#">%s</a><br>\n' % quote_python(self.getMotorName()))
        showIndentHtml(outfile, level)
        outfile.write('motorValue = <a  href:"#">%e</a><br>\n' % self.getMotorValue())
        showIndentHtml(outfile, level)
        outfile.write('comment = <a  href:"#">%s</a><br>\n' % quote_python(self.getComment()))
    def build(self, node_):
        attrs = node_.attributes
        self.buildAttributes(attrs)
        for child_ in node_.childNodes:
            nodeName_ = child_.nodeName.split(':')[-1]
            self.buildChildren(child_, nodeName_)
    def buildAttributes(self, attrs):
        pass
    def buildChildren(self, child_, nodeName_):
        if child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'motorName':
            motorName_ = ''
            for text__content_ in child_.childNodes:
                motorName_ += text__content_.nodeValue
            self.motorName = motorName_
        elif child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'motorValue':
            if child_.firstChild:
                sval_ = child_.firstChild.nodeValue
                try:
                    fval_ = float(sval_)
                except ValueError:
                    raise ValueError('requires float (or double) -- %s' % child_.toxml())
                self.motorValue = fval_
        elif child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'comment':
            comment_ = ''
            for text__content_ in child_.childNodes:
                comment_ += text__content_.nodeValue
            self.comment = comment_
# end class kappa_motor_setting


class kappa_collect_settings(object):
    subclass = None
    def __init__(self, motorSettings=None, comment=''):
        if motorSettings is None:
            self.motorSettings = []
        else:
            self.motorSettings = motorSettings
        self.comment = comment
    def factory(*args_, **kwargs_):
        if kappa_collect_settings.subclass:
            return kappa_collect_settings.subclass(*args_, **kwargs_)
        else:
            return kappa_collect_settings(*args_, **kwargs_)
    factory = staticmethod(factory)
    def getMotorSettings(self): return self.motorSettings
    def setMotorSettings(self, motorSettings): self.motorSettings = motorSettings
    def addMotorSettings(self, value): self.motorSettings.append(value)
    def insertMotorSettings(self, index, value): self.motorSettings[index] = value
    def getComment(self): return self.comment
    def setComment(self, comment): self.comment = comment
    def export(self, outfile, level = 0, name_='kappa_collect_settings'):
        showIndent(outfile, level)
        outfile.write('<%s>\n' % name_)
        self.exportChildren(outfile, level + 1, name_)
        showIndent(outfile, level)
        outfile.write('</%s>\n' % name_)
    def exportAttributes(self, outfile, level, name_='kappa_collect_settings'):
        pass
    def exportChildren(self, outfile, level, name_='kappa_collect_settings'):
        for motorSettings_ in self.getMotorSettings():
            motorSettings_.export(outfile, level, name_='motorSettings')
        showIndent(outfile, level)
        outfile.write('<comment>%s</comment>\n' % quote_xml(self.getComment()))

    #Only to export the entire XML tree to a file stream on disk
    def outputFile( self, _outfileName ):
        outfile = open( _outfileName, "w" )
        outfile.write("<?xml version=\"1.0\" ?>\n")
        self.export( outfile, 0, name_='kappa_collect_settings' )
        outfile.close()


    #Only to export the entire XML tree to a Html Page in a file stream on disk
    def outputPageHtml( self, _outfileName ):
        odtStrTitle = "    <span class=\"title\">kappa_collect_settings:</span> <br> <br> <br>\n" 
        outfile = open( _outfileName, "w" )
        outfile.write( TEMPLATE_PAGE_P1 % ( odtStrTitle ) )
        self.exportLiteralHtml( outfile, 0, name_='kappa_collect_settings' )
        outfile.write( TEMPLATE_PAGE_P2  )
        outfile.close()


    def outputFileHtml( self, _outfileName ):
        self.outputPageHtml( _outfileName )



    #Static method for parsing a string
    def parseString( _inString ):
        doc = minidom.parseString(_inString)
        rootNode = doc.documentElement
        rootObj = kappa_collect_settings.factory()
        rootObj.build(rootNode)
        return rootObj
    parseString = staticmethod( parseString ) 


    #Method for marshalling an object
    def marshal( self ):
        oStreamString = StringIO.StringIO()
        oStreamString.write('<?xml version="1.0" ?>\n')
        self.export( oStreamString, 0, name_="kappa_collect_settings" )
        oStringXML = oStreamString.getvalue()
        oStreamString.close()
        return oStringXML

    def exportLiteral(self, outfile, level = 0, name_='kappa_collect_settings'):
        level += 1
        self.exportLiteralAttributes(outfile, level, name_)
        self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('motorSettings=[\n')
        level += 1
        for motorSettings in self.motorSettings:
            showIndent(outfile, level)
            outfile.write('kappa_motor_setting(\n')
            motorSettings.exportLiteral(outfile, level, name_='motorSettings')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('comment = %s,\n' % quote_python(self.getComment()))
    def exportLiteralHtml(self, outfile, level = 0, name_='kappa_collect_settings'):
        level += 1
        self.exportLiteralAttributesHtml(outfile, level, name_)
        self.exportLiteralChildrenHtml(outfile, level, name_)
    def exportLiteralAttributesHtml(self, outfile, level, name_):
        pass
    def exportLiteralChildrenHtml(self, outfile, level, name_):
        showIndentHtml(outfile, level)
        outfile.write('motorSettings<br>\n')
        level += 1
        for motorSettings in self.motorSettings:
            motorSettings.exportLiteralHtml(outfile, level, name_='motorSettings')
            showIndentHtml(outfile, level)
            outfile.write('<br>\n')
        level -= 1
        showIndentHtml(outfile, level)
        outfile.write('<br>\n')
        showIndentHtml(outfile, level)
        outfile.write('comment = <a  href:"#">%s</a><br>\n' % quote_python(self.getComment()))
    def build(self, node_):
        attrs = node_.attributes
        self.buildAttributes(attrs)
        for child_ in node_.childNodes:
            nodeName_ = child_.nodeName.split(':')[-1]
            self.buildChildren(child_, nodeName_)
    def buildAttributes(self, attrs):
        pass
    def buildChildren(self, child_, nodeName_):
        if child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'motorSettings':
            obj_ = kappa_motor_setting.factory()
            obj_.build(child_)
            self.motorSettings.append(obj_)
        elif child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'comment':
            comment_ = ''
            for text__content_ in child_.childNodes:
                comment_ += text__content_.nodeValue
            self.comment = comment_
# end class kappa_collect_settings


class mosflm_commands(object):
    subclass = None
    def __init__(self, command=None):
        if command is None:
            self.command = []
        else:
            self.command = command
    def factory(*args_, **kwargs_):
        if mosflm_commands.subclass:
            return mosflm_commands.subclass(*args_, **kwargs_)
        else:
            return mosflm_commands(*args_, **kwargs_)
    factory = staticmethod(factory)
    def getCommand(self): return self.command
    def setCommand(self, command): self.command = command
    def addCommand(self, value): self.command.append(value)
    def insertCommand(self, index, value): self.command[index] = value
    def export(self, outfile, level = 0, name_='mosflm_commands'):
        showIndent(outfile, level)
        outfile.write('<%s>\n' % name_)
        self.exportChildren(outfile, level + 1, name_)
        showIndent(outfile, level)
        outfile.write('</%s>\n' % name_)
    def exportAttributes(self, outfile, level, name_='mosflm_commands'):
        pass
    def exportChildren(self, outfile, level, name_='mosflm_commands'):
        for command_ in self.getCommand():
            showIndent(outfile, level)
            outfile.write('<command>%s</command>\n' % quote_xml(command_))

    #Only to export the entire XML tree to a file stream on disk
    def outputFile( self, _outfileName ):
        outfile = open( _outfileName, "w" )
        outfile.write("<?xml version=\"1.0\" ?>\n")
        self.export( outfile, 0, name_='mosflm_commands' )
        outfile.close()


    #Only to export the entire XML tree to a Html Page in a file stream on disk
    def outputPageHtml( self, _outfileName ):
        odtStrTitle = "    <span class=\"title\">mosflm_commands:</span> <br> <br> <br>\n" 
        outfile = open( _outfileName, "w" )
        outfile.write( TEMPLATE_PAGE_P1 % ( odtStrTitle ) )
        self.exportLiteralHtml( outfile, 0, name_='mosflm_commands' )
        outfile.write( TEMPLATE_PAGE_P2  )
        outfile.close()


    def outputFileHtml( self, _outfileName ):
        self.outputPageHtml( _outfileName )



    #Static method for parsing a string
    def parseString( _inString ):
        doc = minidom.parseString(_inString)
        rootNode = doc.documentElement
        rootObj = mosflm_commands.factory()
        rootObj.build(rootNode)
        return rootObj
    parseString = staticmethod( parseString ) 


    #Method for marshalling an object
    def marshal( self ):
        oStreamString = StringIO.StringIO()
        oStreamString.write('<?xml version="1.0" ?>\n')
        self.export( oStreamString, 0, name_="mosflm_commands" )
        oStringXML = oStreamString.getvalue()
        oStreamString.close()
        return oStringXML

    def exportLiteral(self, outfile, level = 0, name_='mosflm_commands'):
        level += 1
        self.exportLiteralAttributes(outfile, level, name_)
        self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('command=[\n')
        level += 1
        for command in self.command:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(command))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def exportLiteralHtml(self, outfile, level = 0, name_='mosflm_commands'):
        level += 1
        self.exportLiteralAttributesHtml(outfile, level, name_)
        self.exportLiteralChildrenHtml(outfile, level, name_)
    def exportLiteralAttributesHtml(self, outfile, level, name_):
        pass
    def exportLiteralChildrenHtml(self, outfile, level, name_):
        showIndentHtml(outfile, level)
        outfile.write('command<br>\n')
        level += 1
        for command in self.command:
            showIndentHtml(outfile, level)
            outfile.write('<a  href:"#">%s</a><br>\n' % quote_python(command))
        level -= 1
        showIndentHtml(outfile, level)
        outfile.write('<br>\n')
    def build(self, node_):
        attrs = node_.attributes
        self.buildAttributes(attrs)
        for child_ in node_.childNodes:
            nodeName_ = child_.nodeName.split(':')[-1]
            self.buildChildren(child_, nodeName_)
    def buildAttributes(self, attrs):
        pass
    def buildChildren(self, child_, nodeName_):
        if child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'command':
            command_ = ''
            for text__content_ in child_.childNodes:
                command_ += text__content_.nodeValue
            self.command.append(command_)
# end class mosflm_commands


class scala_commands(object):
    subclass = None
    def __init__(self, command=None):
        if command is None:
            self.command = []
        else:
            self.command = command
    def factory(*args_, **kwargs_):
        if scala_commands.subclass:
            return scala_commands.subclass(*args_, **kwargs_)
        else:
            return scala_commands(*args_, **kwargs_)
    factory = staticmethod(factory)
    def getCommand(self): return self.command
    def setCommand(self, command): self.command = command
    def addCommand(self, value): self.command.append(value)
    def insertCommand(self, index, value): self.command[index] = value
    def export(self, outfile, level = 0, name_='scala_commands'):
        showIndent(outfile, level)
        outfile.write('<%s>\n' % name_)
        self.exportChildren(outfile, level + 1, name_)
        showIndent(outfile, level)
        outfile.write('</%s>\n' % name_)
    def exportAttributes(self, outfile, level, name_='scala_commands'):
        pass
    def exportChildren(self, outfile, level, name_='scala_commands'):
        for command_ in self.getCommand():
            showIndent(outfile, level)
            outfile.write('<command>%s</command>\n' % quote_xml(command_))

    #Only to export the entire XML tree to a file stream on disk
    def outputFile( self, _outfileName ):
        outfile = open( _outfileName, "w" )
        outfile.write("<?xml version=\"1.0\" ?>\n")
        self.export( outfile, 0, name_='scala_commands' )
        outfile.close()


    #Only to export the entire XML tree to a Html Page in a file stream on disk
    def outputPageHtml( self, _outfileName ):
        odtStrTitle = "    <span class=\"title\">scala_commands:</span> <br> <br> <br>\n" 
        outfile = open( _outfileName, "w" )
        outfile.write( TEMPLATE_PAGE_P1 % ( odtStrTitle ) )
        self.exportLiteralHtml( outfile, 0, name_='scala_commands' )
        outfile.write( TEMPLATE_PAGE_P2  )
        outfile.close()


    def outputFileHtml( self, _outfileName ):
        self.outputPageHtml( _outfileName )



    #Static method for parsing a string
    def parseString( _inString ):
        doc = minidom.parseString(_inString)
        rootNode = doc.documentElement
        rootObj = scala_commands.factory()
        rootObj.build(rootNode)
        return rootObj
    parseString = staticmethod( parseString ) 


    #Method for marshalling an object
    def marshal( self ):
        oStreamString = StringIO.StringIO()
        oStreamString.write('<?xml version="1.0" ?>\n')
        self.export( oStreamString, 0, name_="scala_commands" )
        oStringXML = oStreamString.getvalue()
        oStreamString.close()
        return oStringXML

    def exportLiteral(self, outfile, level = 0, name_='scala_commands'):
        level += 1
        self.exportLiteralAttributes(outfile, level, name_)
        self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('command=[\n')
        level += 1
        for command in self.command:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(command))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def exportLiteralHtml(self, outfile, level = 0, name_='scala_commands'):
        level += 1
        self.exportLiteralAttributesHtml(outfile, level, name_)
        self.exportLiteralChildrenHtml(outfile, level, name_)
    def exportLiteralAttributesHtml(self, outfile, level, name_):
        pass
    def exportLiteralChildrenHtml(self, outfile, level, name_):
        showIndentHtml(outfile, level)
        outfile.write('command<br>\n')
        level += 1
        for command in self.command:
            showIndentHtml(outfile, level)
            outfile.write('<a  href:"#">%s</a><br>\n' % quote_python(command))
        level -= 1
        showIndentHtml(outfile, level)
        outfile.write('<br>\n')
    def build(self, node_):
        attrs = node_.attributes
        self.buildAttributes(attrs)
        for child_ in node_.childNodes:
            nodeName_ = child_.nodeName.split(':')[-1]
            self.buildChildren(child_, nodeName_)
    def buildAttributes(self, attrs):
        pass
    def buildChildren(self, child_, nodeName_):
        if child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'command':
            command_ = ''
            for text__content_ in child_.childNodes:
                command_ += text__content_.nodeValue
            self.command.append(command_)
# end class scala_commands


class xds_commands(object):
    subclass = None
    def __init__(self, command=None):
        if command is None:
            self.command = []
        else:
            self.command = command
    def factory(*args_, **kwargs_):
        if xds_commands.subclass:
            return xds_commands.subclass(*args_, **kwargs_)
        else:
            return xds_commands(*args_, **kwargs_)
    factory = staticmethod(factory)
    def getCommand(self): return self.command
    def setCommand(self, command): self.command = command
    def addCommand(self, value): self.command.append(value)
    def insertCommand(self, index, value): self.command[index] = value
    def export(self, outfile, level = 0, name_='xds_commands'):
        showIndent(outfile, level)
        outfile.write('<%s>\n' % name_)
        self.exportChildren(outfile, level + 1, name_)
        showIndent(outfile, level)
        outfile.write('</%s>\n' % name_)
    def exportAttributes(self, outfile, level, name_='xds_commands'):
        pass
    def exportChildren(self, outfile, level, name_='xds_commands'):
        for command_ in self.getCommand():
            showIndent(outfile, level)
            outfile.write('<command>%s</command>\n' % quote_xml(command_))

    #Only to export the entire XML tree to a file stream on disk
    def outputFile( self, _outfileName ):
        outfile = open( _outfileName, "w" )
        outfile.write("<?xml version=\"1.0\" ?>\n")
        self.export( outfile, 0, name_='xds_commands' )
        outfile.close()


    #Only to export the entire XML tree to a Html Page in a file stream on disk
    def outputPageHtml( self, _outfileName ):
        odtStrTitle = "    <span class=\"title\">xds_commands:</span> <br> <br> <br>\n" 
        outfile = open( _outfileName, "w" )
        outfile.write( TEMPLATE_PAGE_P1 % ( odtStrTitle ) )
        self.exportLiteralHtml( outfile, 0, name_='xds_commands' )
        outfile.write( TEMPLATE_PAGE_P2  )
        outfile.close()


    def outputFileHtml( self, _outfileName ):
        self.outputPageHtml( _outfileName )



    #Static method for parsing a string
    def parseString( _inString ):
        doc = minidom.parseString(_inString)
        rootNode = doc.documentElement
        rootObj = xds_commands.factory()
        rootObj.build(rootNode)
        return rootObj
    parseString = staticmethod( parseString ) 


    #Method for marshalling an object
    def marshal( self ):
        oStreamString = StringIO.StringIO()
        oStreamString.write('<?xml version="1.0" ?>\n')
        self.export( oStreamString, 0, name_="xds_commands" )
        oStringXML = oStreamString.getvalue()
        oStreamString.close()
        return oStringXML

    def exportLiteral(self, outfile, level = 0, name_='xds_commands'):
        level += 1
        self.exportLiteralAttributes(outfile, level, name_)
        self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('command=[\n')
        level += 1
        for command in self.command:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(command))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def exportLiteralHtml(self, outfile, level = 0, name_='xds_commands'):
        level += 1
        self.exportLiteralAttributesHtml(outfile, level, name_)
        self.exportLiteralChildrenHtml(outfile, level, name_)
    def exportLiteralAttributesHtml(self, outfile, level, name_):
        pass
    def exportLiteralChildrenHtml(self, outfile, level, name_):
        showIndentHtml(outfile, level)
        outfile.write('command<br>\n')
        level += 1
        for command in self.command:
            showIndentHtml(outfile, level)
            outfile.write('<a  href:"#">%s</a><br>\n' % quote_python(command))
        level -= 1
        showIndentHtml(outfile, level)
        outfile.write('<br>\n')
    def build(self, node_):
        attrs = node_.attributes
        self.buildAttributes(attrs)
        for child_ in node_.childNodes:
            nodeName_ = child_.nodeName.split(':')[-1]
            self.buildChildren(child_, nodeName_)
    def buildAttributes(self, attrs):
        pass
    def buildChildren(self, child_, nodeName_):
        if child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'command':
            command_ = ''
            for text__content_ in child_.childNodes:
                command_ += text__content_.nodeValue
            self.command.append(command_)
# end class xds_commands


class extra_commands(object):
    subclass = None
    def __init__(self, mosflm_commands=None, scala_commands=None, xds_commands=None):
        self.mosflm_commands = mosflm_commands
        self.scala_commands = scala_commands
        self.xds_commands = xds_commands
    def factory(*args_, **kwargs_):
        if extra_commands.subclass:
            return extra_commands.subclass(*args_, **kwargs_)
        else:
            return extra_commands(*args_, **kwargs_)
    factory = staticmethod(factory)
    def getMosflm_commands(self): return self.mosflm_commands
    def setMosflm_commands(self, mosflm_commands): self.mosflm_commands = mosflm_commands
    def getScala_commands(self): return self.scala_commands
    def setScala_commands(self, scala_commands): self.scala_commands = scala_commands
    def getXds_commands(self): return self.xds_commands
    def setXds_commands(self, xds_commands): self.xds_commands = xds_commands
    def export(self, outfile, level = 0, name_='extra_commands'):
        showIndent(outfile, level)
        outfile.write('<%s>\n' % name_)
        self.exportChildren(outfile, level + 1, name_)
        showIndent(outfile, level)
        outfile.write('</%s>\n' % name_)
    def exportAttributes(self, outfile, level, name_='extra_commands'):
        pass
    def exportChildren(self, outfile, level, name_='extra_commands'):
        if self.mosflm_commands:
            self.mosflm_commands.export(outfile, level)
        if self.scala_commands:
            self.scala_commands.export(outfile, level)
        if self.xds_commands:
            self.xds_commands.export(outfile, level)

    #Only to export the entire XML tree to a file stream on disk
    def outputFile( self, _outfileName ):
        outfile = open( _outfileName, "w" )
        outfile.write("<?xml version=\"1.0\" ?>\n")
        self.export( outfile, 0, name_='extra_commands' )
        outfile.close()


    #Only to export the entire XML tree to a Html Page in a file stream on disk
    def outputPageHtml( self, _outfileName ):
        odtStrTitle = "    <span class=\"title\">extra_commands:</span> <br> <br> <br>\n" 
        outfile = open( _outfileName, "w" )
        outfile.write( TEMPLATE_PAGE_P1 % ( odtStrTitle ) )
        self.exportLiteralHtml( outfile, 0, name_='extra_commands' )
        outfile.write( TEMPLATE_PAGE_P2  )
        outfile.close()


    def outputFileHtml( self, _outfileName ):
        self.outputPageHtml( _outfileName )



    #Static method for parsing a string
    def parseString( _inString ):
        doc = minidom.parseString(_inString)
        rootNode = doc.documentElement
        rootObj = extra_commands.factory()
        rootObj.build(rootNode)
        return rootObj
    parseString = staticmethod( parseString ) 


    #Method for marshalling an object
    def marshal( self ):
        oStreamString = StringIO.StringIO()
        oStreamString.write('<?xml version="1.0" ?>\n')
        self.export( oStreamString, 0, name_="extra_commands" )
        oStringXML = oStreamString.getvalue()
        oStreamString.close()
        return oStringXML

    def exportLiteral(self, outfile, level = 0, name_='extra_commands'):
        level += 1
        self.exportLiteralAttributes(outfile, level, name_)
        self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.mosflm_commands:
            showIndent(outfile, level)
            outfile.write('mosflm_commands = mosflm_commands(\n')
            self.mosflm_commands.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.scala_commands:
            showIndent(outfile, level)
            outfile.write('scala_commands = scala_commands(\n')
            self.scala_commands.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.xds_commands:
            showIndent(outfile, level)
            outfile.write('xds_commands = xds_commands(\n')
            self.xds_commands.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
    def exportLiteralHtml(self, outfile, level = 0, name_='extra_commands'):
        level += 1
        self.exportLiteralAttributesHtml(outfile, level, name_)
        self.exportLiteralChildrenHtml(outfile, level, name_)
    def exportLiteralAttributesHtml(self, outfile, level, name_):
        pass
    def exportLiteralChildrenHtml(self, outfile, level, name_):
        if self.mosflm_commands:
            showIndentHtml(outfile, level)
            outfile.write('mosflm_commands<br>\n')
            self.mosflm_commands.exportLiteralHtml(outfile, level)
            showIndentHtml(outfile, level)
            outfile.write('<br>\n')
        if self.scala_commands:
            showIndentHtml(outfile, level)
            outfile.write('scala_commands<br>\n')
            self.scala_commands.exportLiteralHtml(outfile, level)
            showIndentHtml(outfile, level)
            outfile.write('<br>\n')
        if self.xds_commands:
            showIndentHtml(outfile, level)
            outfile.write('xds_commands<br>\n')
            self.xds_commands.exportLiteralHtml(outfile, level)
            showIndentHtml(outfile, level)
            outfile.write('<br>\n')
    def build(self, node_):
        attrs = node_.attributes
        self.buildAttributes(attrs)
        for child_ in node_.childNodes:
            nodeName_ = child_.nodeName.split(':')[-1]
            self.buildChildren(child_, nodeName_)
    def buildAttributes(self, attrs):
        pass
    def buildChildren(self, child_, nodeName_):
        if child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'mosflm_commands':
            obj_ = mosflm_commands.factory()
            obj_.build(child_)
            self.setMosflm_commands(obj_)
        elif child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'scala_commands':
            obj_ = scala_commands.factory()
            obj_.build(child_)
            self.setScala_commands(obj_)
        elif child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'xds_commands':
            obj_ = xds_commands.factory()
            obj_.build(child_)
            self.setXds_commands(obj_)
# end class extra_commands


class status(object):
    subclass = None
    def __init__(self, code='', message=''):
        self.code = code
        self.message = message
    def factory(*args_, **kwargs_):
        if status.subclass:
            return status.subclass(*args_, **kwargs_)
        else:
            return status(*args_, **kwargs_)
    factory = staticmethod(factory)
    def getCode(self): return self.code
    def setCode(self, code): self.code = code
    def getMessage(self): return self.message
    def setMessage(self, message): self.message = message
    def export(self, outfile, level = 0, name_='status'):
        showIndent(outfile, level)
        outfile.write('<%s>\n' % name_)
        self.exportChildren(outfile, level + 1, name_)
        showIndent(outfile, level)
        outfile.write('</%s>\n' % name_)
    def exportAttributes(self, outfile, level, name_='status'):
        pass
    def exportChildren(self, outfile, level, name_='status'):
        showIndent(outfile, level)
        outfile.write('<code>%s</code>\n' % quote_xml(self.getCode()))
        showIndent(outfile, level)
        outfile.write('<message>%s</message>\n' % quote_xml(self.getMessage()))

    #Only to export the entire XML tree to a file stream on disk
    def outputFile( self, _outfileName ):
        outfile = open( _outfileName, "w" )
        outfile.write("<?xml version=\"1.0\" ?>\n")
        self.export( outfile, 0, name_='status' )
        outfile.close()


    #Only to export the entire XML tree to a Html Page in a file stream on disk
    def outputPageHtml( self, _outfileName ):
        odtStrTitle = "    <span class=\"title\">status:</span> <br> <br> <br>\n" 
        outfile = open( _outfileName, "w" )
        outfile.write( TEMPLATE_PAGE_P1 % ( odtStrTitle ) )
        self.exportLiteralHtml( outfile, 0, name_='status' )
        outfile.write( TEMPLATE_PAGE_P2  )
        outfile.close()


    def outputFileHtml( self, _outfileName ):
        self.outputPageHtml( _outfileName )



    #Static method for parsing a string
    def parseString( _inString ):
        doc = minidom.parseString(_inString)
        rootNode = doc.documentElement
        rootObj = status.factory()
        rootObj.build(rootNode)
        return rootObj
    parseString = staticmethod( parseString ) 


    #Method for marshalling an object
    def marshal( self ):
        oStreamString = StringIO.StringIO()
        oStreamString.write('<?xml version="1.0" ?>\n')
        self.export( oStreamString, 0, name_="status" )
        oStringXML = oStreamString.getvalue()
        oStreamString.close()
        return oStringXML

    def exportLiteral(self, outfile, level = 0, name_='status'):
        level += 1
        self.exportLiteralAttributes(outfile, level, name_)
        self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('code = %s,\n' % quote_python(self.getCode()))
        showIndent(outfile, level)
        outfile.write('message = %s,\n' % quote_python(self.getMessage()))
    def exportLiteralHtml(self, outfile, level = 0, name_='status'):
        level += 1
        self.exportLiteralAttributesHtml(outfile, level, name_)
        self.exportLiteralChildrenHtml(outfile, level, name_)
    def exportLiteralAttributesHtml(self, outfile, level, name_):
        pass
    def exportLiteralChildrenHtml(self, outfile, level, name_):
        showIndentHtml(outfile, level)
        outfile.write('code = <a  href:"#">%s</a><br>\n' % quote_python(self.getCode()))
        showIndentHtml(outfile, level)
        outfile.write('message = <a  href:"#">%s</a><br>\n' % quote_python(self.getMessage()))
    def build(self, node_):
        attrs = node_.attributes
        self.buildAttributes(attrs)
        for child_ in node_.childNodes:
            nodeName_ = child_.nodeName.split(':')[-1]
            self.buildChildren(child_, nodeName_)
    def buildAttributes(self, attrs):
        pass
    def buildChildren(self, child_, nodeName_):
        if child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'code':
            code_ = ''
            for text__content_ in child_.childNodes:
                code_ += text__content_.nodeValue
            self.code = code_
        elif child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'message':
            message_ = ''
            for text__content_ in child_.childNodes:
                message_ += text__content_.nodeValue
            self.message = message_
# end class status


class fileinfo(object):
    subclass = None
    def __init__(self, directory='', prefix='', suffix='', template='', run_number=''):
        self.directory = directory
        self.prefix = prefix
        self.suffix = suffix
        self.template = template
        self.run_number = run_number
    def factory(*args_, **kwargs_):
        if fileinfo.subclass:
            return fileinfo.subclass(*args_, **kwargs_)
        else:
            return fileinfo(*args_, **kwargs_)
    factory = staticmethod(factory)
    def getDirectory(self): return self.directory
    def setDirectory(self, directory): self.directory = directory
    def getPrefix(self): return self.prefix
    def setPrefix(self, prefix): self.prefix = prefix
    def getSuffix(self): return self.suffix
    def setSuffix(self, suffix): self.suffix = suffix
    def getTemplate(self): return self.template
    def setTemplate(self, template): self.template = template
    def getRun_number(self): return self.run_number
    def setRun_number(self, run_number): self.run_number = run_number
    def export(self, outfile, level = 0, name_='fileinfo'):
        showIndent(outfile, level)
        outfile.write('<%s>\n' % name_)
        self.exportChildren(outfile, level + 1, name_)
        showIndent(outfile, level)
        outfile.write('</%s>\n' % name_)
    def exportAttributes(self, outfile, level, name_='fileinfo'):
        pass
    def exportChildren(self, outfile, level, name_='fileinfo'):
        showIndent(outfile, level)
        outfile.write('<directory>%s</directory>\n' % quote_xml(self.getDirectory()))
        showIndent(outfile, level)
        outfile.write('<prefix>%s</prefix>\n' % quote_xml(self.getPrefix()))
        showIndent(outfile, level)
        outfile.write('<suffix>%s</suffix>\n' % quote_xml(self.getSuffix()))
        showIndent(outfile, level)
        outfile.write('<template>%s</template>\n' % quote_xml(self.getTemplate()))
        showIndent(outfile, level)
        outfile.write('<run_number>%s</run_number>\n' % quote_xml(self.getRun_number()))

    #Only to export the entire XML tree to a file stream on disk
    def outputFile( self, _outfileName ):
        outfile = open( _outfileName, "w" )
        outfile.write("<?xml version=\"1.0\" ?>\n")
        self.export( outfile, 0, name_='fileinfo' )
        outfile.close()


    #Only to export the entire XML tree to a Html Page in a file stream on disk
    def outputPageHtml( self, _outfileName ):
        odtStrTitle = "    <span class=\"title\">fileinfo:</span> <br> <br> <br>\n" 
        outfile = open( _outfileName, "w" )
        outfile.write( TEMPLATE_PAGE_P1 % ( odtStrTitle ) )
        self.exportLiteralHtml( outfile, 0, name_='fileinfo' )
        outfile.write( TEMPLATE_PAGE_P2  )
        outfile.close()


    def outputFileHtml( self, _outfileName ):
        self.outputPageHtml( _outfileName )



    #Static method for parsing a string
    def parseString( _inString ):
        doc = minidom.parseString(_inString)
        rootNode = doc.documentElement
        rootObj = fileinfo.factory()
        rootObj.build(rootNode)
        return rootObj
    parseString = staticmethod( parseString ) 


    #Method for marshalling an object
    def marshal( self ):
        oStreamString = StringIO.StringIO()
        oStreamString.write('<?xml version="1.0" ?>\n')
        self.export( oStreamString, 0, name_="fileinfo" )
        oStringXML = oStreamString.getvalue()
        oStreamString.close()
        return oStringXML

    def exportLiteral(self, outfile, level = 0, name_='fileinfo'):
        level += 1
        self.exportLiteralAttributes(outfile, level, name_)
        self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('directory = %s,\n' % quote_python(self.getDirectory()))
        showIndent(outfile, level)
        outfile.write('prefix = %s,\n' % quote_python(self.getPrefix()))
        showIndent(outfile, level)
        outfile.write('suffix = %s,\n' % quote_python(self.getSuffix()))
        showIndent(outfile, level)
        outfile.write('template = %s,\n' % quote_python(self.getTemplate()))
        showIndent(outfile, level)
        outfile.write('run_number = %s,\n' % quote_python(self.getRun_number()))
    def exportLiteralHtml(self, outfile, level = 0, name_='fileinfo'):
        level += 1
        self.exportLiteralAttributesHtml(outfile, level, name_)
        self.exportLiteralChildrenHtml(outfile, level, name_)
    def exportLiteralAttributesHtml(self, outfile, level, name_):
        pass
    def exportLiteralChildrenHtml(self, outfile, level, name_):
        showIndentHtml(outfile, level)
        outfile.write('directory = <a  href:"#">%s</a><br>\n' % quote_python(self.getDirectory()))
        showIndentHtml(outfile, level)
        outfile.write('prefix = <a  href:"#">%s</a><br>\n' % quote_python(self.getPrefix()))
        showIndentHtml(outfile, level)
        outfile.write('suffix = <a  href:"#">%s</a><br>\n' % quote_python(self.getSuffix()))
        showIndentHtml(outfile, level)
        outfile.write('template = <a  href:"#">%s</a><br>\n' % quote_python(self.getTemplate()))
        showIndentHtml(outfile, level)
        outfile.write('run_number = <a  href:"#">%s</a><br>\n' % quote_python(self.getRun_number()))
    def build(self, node_):
        attrs = node_.attributes
        self.buildAttributes(attrs)
        for child_ in node_.childNodes:
            nodeName_ = child_.nodeName.split(':')[-1]
            self.buildChildren(child_, nodeName_)
    def buildAttributes(self, attrs):
        pass
    def buildChildren(self, child_, nodeName_):
        if child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'directory':
            directory_ = ''
            for text__content_ in child_.childNodes:
                directory_ += text__content_.nodeValue
            self.directory = directory_
        elif child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'prefix':
            prefix_ = ''
            for text__content_ in child_.childNodes:
                prefix_ += text__content_.nodeValue
            self.prefix = prefix_
        elif child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'suffix':
            suffix_ = ''
            for text__content_ in child_.childNodes:
                suffix_ += text__content_.nodeValue
            self.suffix = suffix_
        elif child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'template':
            template_ = ''
            for text__content_ in child_.childNodes:
                template_ += text__content_.nodeValue
            self.template = template_
        elif child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'run_number':
            run_number_ = ''
            for text__content_ in child_.childNodes:
                run_number_ += text__content_.nodeValue
            self.run_number = run_number_
# end class fileinfo


class oscillation_sequence(object):
    subclass = None
    def __init__(self, start=0.0, end=0.0, range=0.0, number_of_images='', overlap=0.0, exposure_time=0.0, start_image_number='', number_of_passes=''):
        self.start = start
        self.end = end
        self.range = range
        self.number_of_images = number_of_images
        self.overlap = overlap
        self.exposure_time = exposure_time
        self.start_image_number = start_image_number
        self.number_of_passes = number_of_passes
    def factory(*args_, **kwargs_):
        if oscillation_sequence.subclass:
            return oscillation_sequence.subclass(*args_, **kwargs_)
        else:
            return oscillation_sequence(*args_, **kwargs_)
    factory = staticmethod(factory)
    def getStart(self): return self.start
    def setStart(self, start): self.start = start
    def getEnd(self): return self.end
    def setEnd(self, end): self.end = end
    def getRange(self): return self.range
    def setRange(self, range): self.range = range
    def getNumber_of_images(self): return self.number_of_images
    def setNumber_of_images(self, number_of_images): self.number_of_images = number_of_images
    def getOverlap(self): return self.overlap
    def setOverlap(self, overlap): self.overlap = overlap
    def getExposure_time(self): return self.exposure_time
    def setExposure_time(self, exposure_time): self.exposure_time = exposure_time
    def getStart_image_number(self): return self.start_image_number
    def setStart_image_number(self, start_image_number): self.start_image_number = start_image_number
    def getNumber_of_passes(self): return self.number_of_passes
    def setNumber_of_passes(self, number_of_passes): self.number_of_passes = number_of_passes
    def export(self, outfile, level = 0, name_='oscillation_sequence'):
        showIndent(outfile, level)
        outfile.write('<%s>\n' % name_)
        self.exportChildren(outfile, level + 1, name_)
        showIndent(outfile, level)
        outfile.write('</%s>\n' % name_)
    def exportAttributes(self, outfile, level, name_='oscillation_sequence'):
        pass
    def exportChildren(self, outfile, level, name_='oscillation_sequence'):
        showIndent(outfile, level)
        outfile.write('<start>%e</start>\n' % self.getStart())
        showIndent(outfile, level)
        outfile.write('<end>%e</end>\n' % self.getEnd())
        showIndent(outfile, level)
        outfile.write('<range>%e</range>\n' % self.getRange())
        showIndent(outfile, level)
        outfile.write('<number_of_images>%s</number_of_images>\n' % quote_xml(self.getNumber_of_images()))
        showIndent(outfile, level)
        outfile.write('<overlap>%e</overlap>\n' % self.getOverlap())
        showIndent(outfile, level)
        outfile.write('<exposure_time>%e</exposure_time>\n' % self.getExposure_time())
        showIndent(outfile, level)
        outfile.write('<start_image_number>%s</start_image_number>\n' % quote_xml(self.getStart_image_number()))
        showIndent(outfile, level)
        outfile.write('<number_of_passes>%s</number_of_passes>\n' % quote_xml(self.getNumber_of_passes()))

    #Only to export the entire XML tree to a file stream on disk
    def outputFile( self, _outfileName ):
        outfile = open( _outfileName, "w" )
        outfile.write("<?xml version=\"1.0\" ?>\n")
        self.export( outfile, 0, name_='oscillation_sequence' )
        outfile.close()


    #Only to export the entire XML tree to a Html Page in a file stream on disk
    def outputPageHtml( self, _outfileName ):
        odtStrTitle = "    <span class=\"title\">oscillation_sequence:</span> <br> <br> <br>\n" 
        outfile = open( _outfileName, "w" )
        outfile.write( TEMPLATE_PAGE_P1 % ( odtStrTitle ) )
        self.exportLiteralHtml( outfile, 0, name_='oscillation_sequence' )
        outfile.write( TEMPLATE_PAGE_P2  )
        outfile.close()


    def outputFileHtml( self, _outfileName ):
        self.outputPageHtml( _outfileName )



    #Static method for parsing a string
    def parseString( _inString ):
        doc = minidom.parseString(_inString)
        rootNode = doc.documentElement
        rootObj = oscillation_sequence.factory()
        rootObj.build(rootNode)
        return rootObj
    parseString = staticmethod( parseString ) 


    #Method for marshalling an object
    def marshal( self ):
        oStreamString = StringIO.StringIO()
        oStreamString.write('<?xml version="1.0" ?>\n')
        self.export( oStreamString, 0, name_="oscillation_sequence" )
        oStringXML = oStreamString.getvalue()
        oStreamString.close()
        return oStringXML

    def exportLiteral(self, outfile, level = 0, name_='oscillation_sequence'):
        level += 1
        self.exportLiteralAttributes(outfile, level, name_)
        self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('start = %e,\n' % self.getStart())
        showIndent(outfile, level)
        outfile.write('end = %e,\n' % self.getEnd())
        showIndent(outfile, level)
        outfile.write('range = %e,\n' % self.getRange())
        showIndent(outfile, level)
        outfile.write('number_of_images = %s,\n' % quote_python(self.getNumber_of_images()))
        showIndent(outfile, level)
        outfile.write('overlap = %e,\n' % self.getOverlap())
        showIndent(outfile, level)
        outfile.write('exposure_time = %e,\n' % self.getExposure_time())
        showIndent(outfile, level)
        outfile.write('start_image_number = %s,\n' % quote_python(self.getStart_image_number()))
        showIndent(outfile, level)
        outfile.write('number_of_passes = %s,\n' % quote_python(self.getNumber_of_passes()))
    def exportLiteralHtml(self, outfile, level = 0, name_='oscillation_sequence'):
        level += 1
        self.exportLiteralAttributesHtml(outfile, level, name_)
        self.exportLiteralChildrenHtml(outfile, level, name_)
    def exportLiteralAttributesHtml(self, outfile, level, name_):
        pass
    def exportLiteralChildrenHtml(self, outfile, level, name_):
        showIndentHtml(outfile, level)
        outfile.write('start = <a  href:"#">%e</a><br>\n' % self.getStart())
        showIndentHtml(outfile, level)
        outfile.write('end = <a  href:"#">%e</a><br>\n' % self.getEnd())
        showIndentHtml(outfile, level)
        outfile.write('range = <a  href:"#">%e</a><br>\n' % self.getRange())
        showIndentHtml(outfile, level)
        outfile.write('number_of_images = <a  href:"#">%s</a><br>\n' % quote_python(self.getNumber_of_images()))
        showIndentHtml(outfile, level)
        outfile.write('overlap = <a  href:"#">%e</a><br>\n' % self.getOverlap())
        showIndentHtml(outfile, level)
        outfile.write('exposure_time = <a  href:"#">%e</a><br>\n' % self.getExposure_time())
        showIndentHtml(outfile, level)
        outfile.write('start_image_number = <a  href:"#">%s</a><br>\n' % quote_python(self.getStart_image_number()))
        showIndentHtml(outfile, level)
        outfile.write('number_of_passes = <a  href:"#">%s</a><br>\n' % quote_python(self.getNumber_of_passes()))
    def build(self, node_):
        attrs = node_.attributes
        self.buildAttributes(attrs)
        for child_ in node_.childNodes:
            nodeName_ = child_.nodeName.split(':')[-1]
            self.buildChildren(child_, nodeName_)
    def buildAttributes(self, attrs):
        pass
    def buildChildren(self, child_, nodeName_):
        if child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'start':
            if child_.firstChild:
                sval_ = child_.firstChild.nodeValue
                try:
                    fval_ = float(sval_)
                except ValueError:
                    raise ValueError('requires float (or double) -- %s' % child_.toxml())
                self.start = fval_
        elif child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'end':
            if child_.firstChild:
                sval_ = child_.firstChild.nodeValue
                try:
                    fval_ = float(sval_)
                except ValueError:
                    raise ValueError('requires float (or double) -- %s' % child_.toxml())
                self.end = fval_
        elif child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'range':
            if child_.firstChild:
                sval_ = child_.firstChild.nodeValue
                try:
                    fval_ = float(sval_)
                except ValueError:
                    raise ValueError('requires float (or double) -- %s' % child_.toxml())
                self.range = fval_
        elif child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'number_of_images':
            number_of_images_ = ''
            for text__content_ in child_.childNodes:
                number_of_images_ += text__content_.nodeValue
            self.number_of_images = number_of_images_
        elif child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'overlap':
            if child_.firstChild:
                sval_ = child_.firstChild.nodeValue
                try:
                    fval_ = float(sval_)
                except ValueError:
                    raise ValueError('requires float (or double) -- %s' % child_.toxml())
                self.overlap = fval_
        elif child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'exposure_time':
            if child_.firstChild:
                sval_ = child_.firstChild.nodeValue
                try:
                    fval_ = float(sval_)
                except ValueError:
                    raise ValueError('requires float (or double) -- %s' % child_.toxml())
                self.exposure_time = fval_
        elif child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'start_image_number':
            start_image_number_ = ''
            for text__content_ in child_.childNodes:
                start_image_number_ += text__content_.nodeValue
            self.start_image_number = start_image_number_
        elif child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'number_of_passes':
            number_of_passes_ = ''
            for text__content_ in child_.childNodes:
                number_of_passes_ += text__content_.nodeValue
            self.number_of_passes = number_of_passes_
# end class oscillation_sequence


class detector(object):
    subclass = None
    def __init__(self, ttype='', suffix=''):
        self.ttype = ttype
        self.suffix = suffix
    def factory(*args_, **kwargs_):
        if detector.subclass:
            return detector.subclass(*args_, **kwargs_)
        else:
            return detector(*args_, **kwargs_)
    factory = staticmethod(factory)
    def getType(self): return self.ttype
    def setType(self, ttype): self.ttype = ttype
    def getSuffix(self): return self.suffix
    def setSuffix(self, suffix): self.suffix = suffix
    def export(self, outfile, level = 0, name_='detector'):
        showIndent(outfile, level)
        outfile.write('<%s>\n' % name_)
        self.exportChildren(outfile, level + 1, name_)
        showIndent(outfile, level)
        outfile.write('</%s>\n' % name_)
    def exportAttributes(self, outfile, level, name_='detector'):
        pass
    def exportChildren(self, outfile, level, name_='detector'):
        showIndent(outfile, level)
        outfile.write('<type>%s</type>\n' % quote_xml(self.getType()))
        showIndent(outfile, level)
        outfile.write('<suffix>%s</suffix>\n' % quote_xml(self.getSuffix()))

    #Only to export the entire XML tree to a file stream on disk
    def outputFile( self, _outfileName ):
        outfile = open( _outfileName, "w" )
        outfile.write("<?xml version=\"1.0\" ?>\n")
        self.export( outfile, 0, name_='detector' )
        outfile.close()


    #Only to export the entire XML tree to a Html Page in a file stream on disk
    def outputPageHtml( self, _outfileName ):
        odtStrTitle = "    <span class=\"title\">detector:</span> <br> <br> <br>\n" 
        outfile = open( _outfileName, "w" )
        outfile.write( TEMPLATE_PAGE_P1 % ( odtStrTitle ) )
        self.exportLiteralHtml( outfile, 0, name_='detector' )
        outfile.write( TEMPLATE_PAGE_P2  )
        outfile.close()


    def outputFileHtml( self, _outfileName ):
        self.outputPageHtml( _outfileName )



    #Static method for parsing a string
    def parseString( _inString ):
        doc = minidom.parseString(_inString)
        rootNode = doc.documentElement
        rootObj = detector.factory()
        rootObj.build(rootNode)
        return rootObj
    parseString = staticmethod( parseString ) 


    #Method for marshalling an object
    def marshal( self ):
        oStreamString = StringIO.StringIO()
        oStreamString.write('<?xml version="1.0" ?>\n')
        self.export( oStreamString, 0, name_="detector" )
        oStringXML = oStreamString.getvalue()
        oStreamString.close()
        return oStringXML

    def exportLiteral(self, outfile, level = 0, name_='detector'):
        level += 1
        self.exportLiteralAttributes(outfile, level, name_)
        self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('ttype = %s,\n' % quote_python(self.getType()))
        showIndent(outfile, level)
        outfile.write('suffix = %s,\n' % quote_python(self.getSuffix()))
    def exportLiteralHtml(self, outfile, level = 0, name_='detector'):
        level += 1
        self.exportLiteralAttributesHtml(outfile, level, name_)
        self.exportLiteralChildrenHtml(outfile, level, name_)
    def exportLiteralAttributesHtml(self, outfile, level, name_):
        pass
    def exportLiteralChildrenHtml(self, outfile, level, name_):
        showIndentHtml(outfile, level)
        outfile.write('ttype = <a  href:"#">%s</a><br>\n' % quote_python(self.getType()))
        showIndentHtml(outfile, level)
        outfile.write('suffix = <a  href:"#">%s</a><br>\n' % quote_python(self.getSuffix()))
    def build(self, node_):
        attrs = node_.attributes
        self.buildAttributes(attrs)
        for child_ in node_.childNodes:
            nodeName_ = child_.nodeName.split(':')[-1]
            self.buildChildren(child_, nodeName_)
    def buildAttributes(self, attrs):
        pass
    def buildChildren(self, child_, nodeName_):
        if child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'type':
            type_ = ''
            for text__content_ in child_.childNodes:
                type_ += text__content_.nodeValue
            self.ttype = type_
        elif child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'suffix':
            suffix_ = ''
            for text__content_ in child_.childNodes:
                suffix_ += text__content_.nodeValue
            self.suffix = suffix_
# end class detector


class beam(object):
    subclass = None
    def __init__(self, x=0.0, y=0.0):
        self.x = x
        self.y = y
    def factory(*args_, **kwargs_):
        if beam.subclass:
            return beam.subclass(*args_, **kwargs_)
        else:
            return beam(*args_, **kwargs_)
    factory = staticmethod(factory)
    def getX(self): return self.x
    def setX(self, x): self.x = x
    def getY(self): return self.y
    def setY(self, y): self.y = y
    def export(self, outfile, level = 0, name_='beam'):
        showIndent(outfile, level)
        outfile.write('<%s>\n' % name_)
        self.exportChildren(outfile, level + 1, name_)
        showIndent(outfile, level)
        outfile.write('</%s>\n' % name_)
    def exportAttributes(self, outfile, level, name_='beam'):
        pass
    def exportChildren(self, outfile, level, name_='beam'):
        showIndent(outfile, level)
        outfile.write('<x>%e</x>\n' % self.getX())
        showIndent(outfile, level)
        outfile.write('<y>%e</y>\n' % self.getY())

    #Only to export the entire XML tree to a file stream on disk
    def outputFile( self, _outfileName ):
        outfile = open( _outfileName, "w" )
        outfile.write("<?xml version=\"1.0\" ?>\n")
        self.export( outfile, 0, name_='beam' )
        outfile.close()


    #Only to export the entire XML tree to a Html Page in a file stream on disk
    def outputPageHtml( self, _outfileName ):
        odtStrTitle = "    <span class=\"title\">beam:</span> <br> <br> <br>\n" 
        outfile = open( _outfileName, "w" )
        outfile.write( TEMPLATE_PAGE_P1 % ( odtStrTitle ) )
        self.exportLiteralHtml( outfile, 0, name_='beam' )
        outfile.write( TEMPLATE_PAGE_P2  )
        outfile.close()


    def outputFileHtml( self, _outfileName ):
        self.outputPageHtml( _outfileName )



    #Static method for parsing a string
    def parseString( _inString ):
        doc = minidom.parseString(_inString)
        rootNode = doc.documentElement
        rootObj = beam.factory()
        rootObj.build(rootNode)
        return rootObj
    parseString = staticmethod( parseString ) 


    #Method for marshalling an object
    def marshal( self ):
        oStreamString = StringIO.StringIO()
        oStreamString.write('<?xml version="1.0" ?>\n')
        self.export( oStreamString, 0, name_="beam" )
        oStringXML = oStreamString.getvalue()
        oStreamString.close()
        return oStringXML

    def exportLiteral(self, outfile, level = 0, name_='beam'):
        level += 1
        self.exportLiteralAttributes(outfile, level, name_)
        self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('x = %e,\n' % self.getX())
        showIndent(outfile, level)
        outfile.write('y = %e,\n' % self.getY())
    def exportLiteralHtml(self, outfile, level = 0, name_='beam'):
        level += 1
        self.exportLiteralAttributesHtml(outfile, level, name_)
        self.exportLiteralChildrenHtml(outfile, level, name_)
    def exportLiteralAttributesHtml(self, outfile, level, name_):
        pass
    def exportLiteralChildrenHtml(self, outfile, level, name_):
        showIndentHtml(outfile, level)
        outfile.write('x = <a  href:"#">%e</a><br>\n' % self.getX())
        showIndentHtml(outfile, level)
        outfile.write('y = <a  href:"#">%e</a><br>\n' % self.getY())
    def build(self, node_):
        attrs = node_.attributes
        self.buildAttributes(attrs)
        for child_ in node_.childNodes:
            nodeName_ = child_.nodeName.split(':')[-1]
            self.buildChildren(child_, nodeName_)
    def buildAttributes(self, attrs):
        pass
    def buildChildren(self, child_, nodeName_):
        if child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'x':
            if child_.firstChild:
                sval_ = child_.firstChild.nodeValue
                try:
                    fval_ = float(sval_)
                except ValueError:
                    raise ValueError('requires float (or double) -- %s' % child_.toxml())
                self.x = fval_
        elif child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'y':
            if child_.firstChild:
                sval_ = child_.firstChild.nodeValue
                try:
                    fval_ = float(sval_)
                except ValueError:
                    raise ValueError('requires float (or double) -- %s' % child_.toxml())
                self.y = fval_
# end class beam


class cell(object):
    subclass = None
    def __init__(self, a=0.0, b=0.0, c=0.0, alpha=0.0, beta=0.0, gamma=0.0):
        self.a = a
        self.b = b
        self.c = c
        self.alpha = alpha
        self.beta = beta
        self.gamma = gamma
    def factory(*args_, **kwargs_):
        if cell.subclass:
            return cell.subclass(*args_, **kwargs_)
        else:
            return cell(*args_, **kwargs_)
    factory = staticmethod(factory)
    def getA(self): return self.a
    def setA(self, a): self.a = a
    def getB(self): return self.b
    def setB(self, b): self.b = b
    def getC(self): return self.c
    def setC(self, c): self.c = c
    def getAlpha(self): return self.alpha
    def setAlpha(self, alpha): self.alpha = alpha
    def getBeta(self): return self.beta
    def setBeta(self, beta): self.beta = beta
    def getGamma(self): return self.gamma
    def setGamma(self, gamma): self.gamma = gamma
    def export(self, outfile, level = 0, name_='cell'):
        showIndent(outfile, level)
        outfile.write('<%s>\n' % name_)
        self.exportChildren(outfile, level + 1, name_)
        showIndent(outfile, level)
        outfile.write('</%s>\n' % name_)
    def exportAttributes(self, outfile, level, name_='cell'):
        pass
    def exportChildren(self, outfile, level, name_='cell'):
        showIndent(outfile, level)
        outfile.write('<a>%e</a>\n' % self.getA())
        showIndent(outfile, level)
        outfile.write('<b>%e</b>\n' % self.getB())
        showIndent(outfile, level)
        outfile.write('<c>%e</c>\n' % self.getC())
        showIndent(outfile, level)
        outfile.write('<alpha>%e</alpha>\n' % self.getAlpha())
        showIndent(outfile, level)
        outfile.write('<beta>%e</beta>\n' % self.getBeta())
        showIndent(outfile, level)
        outfile.write('<gamma>%e</gamma>\n' % self.getGamma())

    #Only to export the entire XML tree to a file stream on disk
    def outputFile( self, _outfileName ):
        outfile = open( _outfileName, "w" )
        outfile.write("<?xml version=\"1.0\" ?>\n")
        self.export( outfile, 0, name_='cell' )
        outfile.close()


    #Only to export the entire XML tree to a Html Page in a file stream on disk
    def outputPageHtml( self, _outfileName ):
        odtStrTitle = "    <span class=\"title\">cell:</span> <br> <br> <br>\n" 
        outfile = open( _outfileName, "w" )
        outfile.write( TEMPLATE_PAGE_P1 % ( odtStrTitle ) )
        self.exportLiteralHtml( outfile, 0, name_='cell' )
        outfile.write( TEMPLATE_PAGE_P2  )
        outfile.close()


    def outputFileHtml( self, _outfileName ):
        self.outputPageHtml( _outfileName )



    #Static method for parsing a string
    def parseString( _inString ):
        doc = minidom.parseString(_inString)
        rootNode = doc.documentElement
        rootObj = cell.factory()
        rootObj.build(rootNode)
        return rootObj
    parseString = staticmethod( parseString ) 


    #Method for marshalling an object
    def marshal( self ):
        oStreamString = StringIO.StringIO()
        oStreamString.write('<?xml version="1.0" ?>\n')
        self.export( oStreamString, 0, name_="cell" )
        oStringXML = oStreamString.getvalue()
        oStreamString.close()
        return oStringXML

    def exportLiteral(self, outfile, level = 0, name_='cell'):
        level += 1
        self.exportLiteralAttributes(outfile, level, name_)
        self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('a = %e,\n' % self.getA())
        showIndent(outfile, level)
        outfile.write('b = %e,\n' % self.getB())
        showIndent(outfile, level)
        outfile.write('c = %e,\n' % self.getC())
        showIndent(outfile, level)
        outfile.write('alpha = %e,\n' % self.getAlpha())
        showIndent(outfile, level)
        outfile.write('beta = %e,\n' % self.getBeta())
        showIndent(outfile, level)
        outfile.write('gamma = %e,\n' % self.getGamma())
    def exportLiteralHtml(self, outfile, level = 0, name_='cell'):
        level += 1
        self.exportLiteralAttributesHtml(outfile, level, name_)
        self.exportLiteralChildrenHtml(outfile, level, name_)
    def exportLiteralAttributesHtml(self, outfile, level, name_):
        pass
    def exportLiteralChildrenHtml(self, outfile, level, name_):
        showIndentHtml(outfile, level)
        outfile.write('a = <a  href:"#">%e</a><br>\n' % self.getA())
        showIndentHtml(outfile, level)
        outfile.write('b = <a  href:"#">%e</a><br>\n' % self.getB())
        showIndentHtml(outfile, level)
        outfile.write('c = <a  href:"#">%e</a><br>\n' % self.getC())
        showIndentHtml(outfile, level)
        outfile.write('alpha = <a  href:"#">%e</a><br>\n' % self.getAlpha())
        showIndentHtml(outfile, level)
        outfile.write('beta = <a  href:"#">%e</a><br>\n' % self.getBeta())
        showIndentHtml(outfile, level)
        outfile.write('gamma = <a  href:"#">%e</a><br>\n' % self.getGamma())
    def build(self, node_):
        attrs = node_.attributes
        self.buildAttributes(attrs)
        for child_ in node_.childNodes:
            nodeName_ = child_.nodeName.split(':')[-1]
            self.buildChildren(child_, nodeName_)
    def buildAttributes(self, attrs):
        pass
    def buildChildren(self, child_, nodeName_):
        if child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'a':
            if child_.firstChild:
                sval_ = child_.firstChild.nodeValue
                try:
                    fval_ = float(sval_)
                except ValueError:
                    raise ValueError('requires float (or double) -- %s' % child_.toxml())
                self.a = fval_
        elif child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'b':
            if child_.firstChild:
                sval_ = child_.firstChild.nodeValue
                try:
                    fval_ = float(sval_)
                except ValueError:
                    raise ValueError('requires float (or double) -- %s' % child_.toxml())
                self.b = fval_
        elif child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'c':
            if child_.firstChild:
                sval_ = child_.firstChild.nodeValue
                try:
                    fval_ = float(sval_)
                except ValueError:
                    raise ValueError('requires float (or double) -- %s' % child_.toxml())
                self.c = fval_
        elif child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'alpha':
            if child_.firstChild:
                sval_ = child_.firstChild.nodeValue
                try:
                    fval_ = float(sval_)
                except ValueError:
                    raise ValueError('requires float (or double) -- %s' % child_.toxml())
                self.alpha = fval_
        elif child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'beta':
            if child_.firstChild:
                sval_ = child_.firstChild.nodeValue
                try:
                    fval_ = float(sval_)
                except ValueError:
                    raise ValueError('requires float (or double) -- %s' % child_.toxml())
                self.beta = fval_
        elif child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'gamma':
            if child_.firstChild:
                sval_ = child_.firstChild.nodeValue
                try:
                    fval_ = float(sval_)
                except ValueError:
                    raise ValueError('requires float (or double) -- %s' % child_.toxml())
                self.gamma = fval_
# end class cell


class experiment(object):
    subclass = None
    def __init__(self, wavelength=0.0, distance=0.0, resolution=None):
        self.wavelength = wavelength
        self.distance = distance
        self.resolution = resolution
    def factory(*args_, **kwargs_):
        if experiment.subclass:
            return experiment.subclass(*args_, **kwargs_)
        else:
            return experiment(*args_, **kwargs_)
    factory = staticmethod(factory)
    def getWavelength(self): return self.wavelength
    def setWavelength(self, wavelength): self.wavelength = wavelength
    def getDistance(self): return self.distance
    def setDistance(self, distance): self.distance = distance
    def getResolution(self): return self.resolution
    def setResolution(self, resolution): self.resolution = resolution
    def export(self, outfile, level = 0, name_='experiment'):
        showIndent(outfile, level)
        outfile.write('<%s>\n' % name_)
        self.exportChildren(outfile, level + 1, name_)
        showIndent(outfile, level)
        outfile.write('</%s>\n' % name_)
    def exportAttributes(self, outfile, level, name_='experiment'):
        pass
    def exportChildren(self, outfile, level, name_='experiment'):
        showIndent(outfile, level)
        outfile.write('<wavelength>%e</wavelength>\n' % self.getWavelength())
        showIndent(outfile, level)
        outfile.write('<distance>%e</distance>\n' % self.getDistance())
        if self.resolution:
            self.resolution.export(outfile, level)

    #Only to export the entire XML tree to a file stream on disk
    def outputFile( self, _outfileName ):
        outfile = open( _outfileName, "w" )
        outfile.write("<?xml version=\"1.0\" ?>\n")
        self.export( outfile, 0, name_='experiment' )
        outfile.close()


    #Only to export the entire XML tree to a Html Page in a file stream on disk
    def outputPageHtml( self, _outfileName ):
        odtStrTitle = "    <span class=\"title\">experiment:</span> <br> <br> <br>\n" 
        outfile = open( _outfileName, "w" )
        outfile.write( TEMPLATE_PAGE_P1 % ( odtStrTitle ) )
        self.exportLiteralHtml( outfile, 0, name_='experiment' )
        outfile.write( TEMPLATE_PAGE_P2  )
        outfile.close()


    def outputFileHtml( self, _outfileName ):
        self.outputPageHtml( _outfileName )



    #Static method for parsing a string
    def parseString( _inString ):
        doc = minidom.parseString(_inString)
        rootNode = doc.documentElement
        rootObj = experiment.factory()
        rootObj.build(rootNode)
        return rootObj
    parseString = staticmethod( parseString ) 


    #Method for marshalling an object
    def marshal( self ):
        oStreamString = StringIO.StringIO()
        oStreamString.write('<?xml version="1.0" ?>\n')
        self.export( oStreamString, 0, name_="experiment" )
        oStringXML = oStreamString.getvalue()
        oStreamString.close()
        return oStringXML

    def exportLiteral(self, outfile, level = 0, name_='experiment'):
        level += 1
        self.exportLiteralAttributes(outfile, level, name_)
        self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('wavelength = %e,\n' % self.getWavelength())
        showIndent(outfile, level)
        outfile.write('distance = %e,\n' % self.getDistance())
        if self.resolution:
            showIndent(outfile, level)
            outfile.write('resolution = resolution(\n')
            self.resolution.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
    def exportLiteralHtml(self, outfile, level = 0, name_='experiment'):
        level += 1
        self.exportLiteralAttributesHtml(outfile, level, name_)
        self.exportLiteralChildrenHtml(outfile, level, name_)
    def exportLiteralAttributesHtml(self, outfile, level, name_):
        pass
    def exportLiteralChildrenHtml(self, outfile, level, name_):
        showIndentHtml(outfile, level)
        outfile.write('wavelength = <a  href:"#">%e</a><br>\n' % self.getWavelength())
        showIndentHtml(outfile, level)
        outfile.write('distance = <a  href:"#">%e</a><br>\n' % self.getDistance())
        if self.resolution:
            showIndentHtml(outfile, level)
            outfile.write('resolution<br>\n')
            self.resolution.exportLiteralHtml(outfile, level)
            showIndentHtml(outfile, level)
            outfile.write('<br>\n')
    def build(self, node_):
        attrs = node_.attributes
        self.buildAttributes(attrs)
        for child_ in node_.childNodes:
            nodeName_ = child_.nodeName.split(':')[-1]
            self.buildChildren(child_, nodeName_)
    def buildAttributes(self, attrs):
        pass
    def buildChildren(self, child_, nodeName_):
        if child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'wavelength':
            if child_.firstChild:
                sval_ = child_.firstChild.nodeValue
                try:
                    fval_ = float(sval_)
                except ValueError:
                    raise ValueError('requires float (or double) -- %s' % child_.toxml())
                self.wavelength = fval_
        elif child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'distance':
            if child_.firstChild:
                sval_ = child_.firstChild.nodeValue
                try:
                    fval_ = float(sval_)
                except ValueError:
                    raise ValueError('requires float (or double) -- %s' % child_.toxml())
                self.distance = fval_
        elif child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'resolution':
            obj_ = resolution.factory()
            obj_.build(child_)
            self.setResolution(obj_)
# end class experiment


class matrix(object):
    subclass = None
    def __init__(self, e11=0.0, e12=0.0, e13=0.0, e21=0.0, e22=0.0, e23=0.0, e31=0.0, e32=0.0, e33=0.0):
        self.e11 = e11
        self.e12 = e12
        self.e13 = e13
        self.e21 = e21
        self.e22 = e22
        self.e23 = e23
        self.e31 = e31
        self.e32 = e32
        self.e33 = e33
    def factory(*args_, **kwargs_):
        if matrix.subclass:
            return matrix.subclass(*args_, **kwargs_)
        else:
            return matrix(*args_, **kwargs_)
    factory = staticmethod(factory)
    def getE11(self): return self.e11
    def setE11(self, e11): self.e11 = e11
    def getE12(self): return self.e12
    def setE12(self, e12): self.e12 = e12
    def getE13(self): return self.e13
    def setE13(self, e13): self.e13 = e13
    def getE21(self): return self.e21
    def setE21(self, e21): self.e21 = e21
    def getE22(self): return self.e22
    def setE22(self, e22): self.e22 = e22
    def getE23(self): return self.e23
    def setE23(self, e23): self.e23 = e23
    def getE31(self): return self.e31
    def setE31(self, e31): self.e31 = e31
    def getE32(self): return self.e32
    def setE32(self, e32): self.e32 = e32
    def getE33(self): return self.e33
    def setE33(self, e33): self.e33 = e33
    def export(self, outfile, level = 0, name_='matrix'):
        showIndent(outfile, level)
        outfile.write('<%s>\n' % name_)
        self.exportChildren(outfile, level + 1, name_)
        showIndent(outfile, level)
        outfile.write('</%s>\n' % name_)
    def exportAttributes(self, outfile, level, name_='matrix'):
        pass
    def exportChildren(self, outfile, level, name_='matrix'):
        showIndent(outfile, level)
        outfile.write('<e11>%e</e11>\n' % self.getE11())
        showIndent(outfile, level)
        outfile.write('<e12>%e</e12>\n' % self.getE12())
        showIndent(outfile, level)
        outfile.write('<e13>%e</e13>\n' % self.getE13())
        showIndent(outfile, level)
        outfile.write('<e21>%e</e21>\n' % self.getE21())
        showIndent(outfile, level)
        outfile.write('<e22>%e</e22>\n' % self.getE22())
        showIndent(outfile, level)
        outfile.write('<e23>%e</e23>\n' % self.getE23())
        showIndent(outfile, level)
        outfile.write('<e31>%e</e31>\n' % self.getE31())
        showIndent(outfile, level)
        outfile.write('<e32>%e</e32>\n' % self.getE32())
        showIndent(outfile, level)
        outfile.write('<e33>%e</e33>\n' % self.getE33())

    #Only to export the entire XML tree to a file stream on disk
    def outputFile( self, _outfileName ):
        outfile = open( _outfileName, "w" )
        outfile.write("<?xml version=\"1.0\" ?>\n")
        self.export( outfile, 0, name_='matrix' )
        outfile.close()


    #Only to export the entire XML tree to a Html Page in a file stream on disk
    def outputPageHtml( self, _outfileName ):
        odtStrTitle = "    <span class=\"title\">matrix:</span> <br> <br> <br>\n" 
        outfile = open( _outfileName, "w" )
        outfile.write( TEMPLATE_PAGE_P1 % ( odtStrTitle ) )
        self.exportLiteralHtml( outfile, 0, name_='matrix' )
        outfile.write( TEMPLATE_PAGE_P2  )
        outfile.close()


    def outputFileHtml( self, _outfileName ):
        self.outputPageHtml( _outfileName )



    #Static method for parsing a string
    def parseString( _inString ):
        doc = minidom.parseString(_inString)
        rootNode = doc.documentElement
        rootObj = matrix.factory()
        rootObj.build(rootNode)
        return rootObj
    parseString = staticmethod( parseString ) 


    #Method for marshalling an object
    def marshal( self ):
        oStreamString = StringIO.StringIO()
        oStreamString.write('<?xml version="1.0" ?>\n')
        self.export( oStreamString, 0, name_="matrix" )
        oStringXML = oStreamString.getvalue()
        oStreamString.close()
        return oStringXML

    def exportLiteral(self, outfile, level = 0, name_='matrix'):
        level += 1
        self.exportLiteralAttributes(outfile, level, name_)
        self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('e11 = %e,\n' % self.getE11())
        showIndent(outfile, level)
        outfile.write('e12 = %e,\n' % self.getE12())
        showIndent(outfile, level)
        outfile.write('e13 = %e,\n' % self.getE13())
        showIndent(outfile, level)
        outfile.write('e21 = %e,\n' % self.getE21())
        showIndent(outfile, level)
        outfile.write('e22 = %e,\n' % self.getE22())
        showIndent(outfile, level)
        outfile.write('e23 = %e,\n' % self.getE23())
        showIndent(outfile, level)
        outfile.write('e31 = %e,\n' % self.getE31())
        showIndent(outfile, level)
        outfile.write('e32 = %e,\n' % self.getE32())
        showIndent(outfile, level)
        outfile.write('e33 = %e,\n' % self.getE33())
    def exportLiteralHtml(self, outfile, level = 0, name_='matrix'):
        level += 1
        self.exportLiteralAttributesHtml(outfile, level, name_)
        self.exportLiteralChildrenHtml(outfile, level, name_)
    def exportLiteralAttributesHtml(self, outfile, level, name_):
        pass
    def exportLiteralChildrenHtml(self, outfile, level, name_):
        showIndentHtml(outfile, level)
        outfile.write('e11 = <a  href:"#">%e</a><br>\n' % self.getE11())
        showIndentHtml(outfile, level)
        outfile.write('e12 = <a  href:"#">%e</a><br>\n' % self.getE12())
        showIndentHtml(outfile, level)
        outfile.write('e13 = <a  href:"#">%e</a><br>\n' % self.getE13())
        showIndentHtml(outfile, level)
        outfile.write('e21 = <a  href:"#">%e</a><br>\n' % self.getE21())
        showIndentHtml(outfile, level)
        outfile.write('e22 = <a  href:"#">%e</a><br>\n' % self.getE22())
        showIndentHtml(outfile, level)
        outfile.write('e23 = <a  href:"#">%e</a><br>\n' % self.getE23())
        showIndentHtml(outfile, level)
        outfile.write('e31 = <a  href:"#">%e</a><br>\n' % self.getE31())
        showIndentHtml(outfile, level)
        outfile.write('e32 = <a  href:"#">%e</a><br>\n' % self.getE32())
        showIndentHtml(outfile, level)
        outfile.write('e33 = <a  href:"#">%e</a><br>\n' % self.getE33())
    def build(self, node_):
        attrs = node_.attributes
        self.buildAttributes(attrs)
        for child_ in node_.childNodes:
            nodeName_ = child_.nodeName.split(':')[-1]
            self.buildChildren(child_, nodeName_)
    def buildAttributes(self, attrs):
        pass
    def buildChildren(self, child_, nodeName_):
        if child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'e11':
            if child_.firstChild:
                sval_ = child_.firstChild.nodeValue
                try:
                    fval_ = float(sval_)
                except ValueError:
                    raise ValueError('requires float (or double) -- %s' % child_.toxml())
                self.e11 = fval_
        elif child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'e12':
            if child_.firstChild:
                sval_ = child_.firstChild.nodeValue
                try:
                    fval_ = float(sval_)
                except ValueError:
                    raise ValueError('requires float (or double) -- %s' % child_.toxml())
                self.e12 = fval_
        elif child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'e13':
            if child_.firstChild:
                sval_ = child_.firstChild.nodeValue
                try:
                    fval_ = float(sval_)
                except ValueError:
                    raise ValueError('requires float (or double) -- %s' % child_.toxml())
                self.e13 = fval_
        elif child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'e21':
            if child_.firstChild:
                sval_ = child_.firstChild.nodeValue
                try:
                    fval_ = float(sval_)
                except ValueError:
                    raise ValueError('requires float (or double) -- %s' % child_.toxml())
                self.e21 = fval_
        elif child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'e22':
            if child_.firstChild:
                sval_ = child_.firstChild.nodeValue
                try:
                    fval_ = float(sval_)
                except ValueError:
                    raise ValueError('requires float (or double) -- %s' % child_.toxml())
                self.e22 = fval_
        elif child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'e23':
            if child_.firstChild:
                sval_ = child_.firstChild.nodeValue
                try:
                    fval_ = float(sval_)
                except ValueError:
                    raise ValueError('requires float (or double) -- %s' % child_.toxml())
                self.e23 = fval_
        elif child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'e31':
            if child_.firstChild:
                sval_ = child_.firstChild.nodeValue
                try:
                    fval_ = float(sval_)
                except ValueError:
                    raise ValueError('requires float (or double) -- %s' % child_.toxml())
                self.e31 = fval_
        elif child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'e32':
            if child_.firstChild:
                sval_ = child_.firstChild.nodeValue
                try:
                    fval_ = float(sval_)
                except ValueError:
                    raise ValueError('requires float (or double) -- %s' % child_.toxml())
                self.e32 = fval_
        elif child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'e33':
            if child_.firstChild:
                sval_ = child_.firstChild.nodeValue
                try:
                    fval_ = float(sval_)
                except ValueError:
                    raise ValueError('requires float (or double) -- %s' % child_.toxml())
                self.e33 = fval_
# end class matrix


class dna_message(object):
    subclass = None
    def __init__(self, ttype='', content_type='', level='', message=''):
        self.ttype = ttype
        self.content_type = content_type
        self.level = level
        self.message = message
    def factory(*args_, **kwargs_):
        if dna_message.subclass:
            return dna_message.subclass(*args_, **kwargs_)
        else:
            return dna_message(*args_, **kwargs_)
    factory = staticmethod(factory)
    def getType(self): return self.ttype
    def setType(self, ttype): self.ttype = ttype
    def getContent_type(self): return self.content_type
    def setContent_type(self, content_type): self.content_type = content_type
    def getLevel(self): return self.level
    def setLevel(self, level): self.level = level
    def getMessage(self): return self.message
    def setMessage(self, message): self.message = message
    def export(self, outfile, level = 0, name_='dna_message'):
        showIndent(outfile, level)
        outfile.write('<%s>\n' % name_)
        self.exportChildren(outfile, level + 1, name_)
        showIndent(outfile, level)
        outfile.write('</%s>\n' % name_)
    def exportAttributes(self, outfile, level, name_='dna_message'):
        pass
    def exportChildren(self, outfile, level, name_='dna_message'):
        showIndent(outfile, level)
        outfile.write('<type>%s</type>\n' % quote_xml(self.getType()))
        showIndent(outfile, level)
        outfile.write('<content_type>%s</content_type>\n' % quote_xml(self.getContent_type()))
        showIndent(outfile, level)
        outfile.write('<level>%s</level>\n' % quote_xml(self.getLevel()))
        showIndent(outfile, level)
        outfile.write('<message>%s</message>\n' % quote_xml(self.getMessage()))

    #Only to export the entire XML tree to a file stream on disk
    def outputFile( self, _outfileName ):
        outfile = open( _outfileName, "w" )
        outfile.write("<?xml version=\"1.0\" ?>\n")
        self.export( outfile, 0, name_='dna_message' )
        outfile.close()


    #Only to export the entire XML tree to a Html Page in a file stream on disk
    def outputPageHtml( self, _outfileName ):
        odtStrTitle = "    <span class=\"title\">dna_message:</span> <br> <br> <br>\n" 
        outfile = open( _outfileName, "w" )
        outfile.write( TEMPLATE_PAGE_P1 % ( odtStrTitle ) )
        self.exportLiteralHtml( outfile, 0, name_='dna_message' )
        outfile.write( TEMPLATE_PAGE_P2  )
        outfile.close()


    def outputFileHtml( self, _outfileName ):
        self.outputPageHtml( _outfileName )



    #Static method for parsing a string
    def parseString( _inString ):
        doc = minidom.parseString(_inString)
        rootNode = doc.documentElement
        rootObj = dna_message.factory()
        rootObj.build(rootNode)
        return rootObj
    parseString = staticmethod( parseString ) 


    #Method for marshalling an object
    def marshal( self ):
        oStreamString = StringIO.StringIO()
        oStreamString.write('<?xml version="1.0" ?>\n')
        self.export( oStreamString, 0, name_="dna_message" )
        oStringXML = oStreamString.getvalue()
        oStreamString.close()
        return oStringXML

    def exportLiteral(self, outfile, level = 0, name_='dna_message'):
        level += 1
        self.exportLiteralAttributes(outfile, level, name_)
        self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('ttype = %s,\n' % quote_python(self.getType()))
        showIndent(outfile, level)
        outfile.write('content_type = %s,\n' % quote_python(self.getContent_type()))
        showIndent(outfile, level)
        outfile.write('level = %s,\n' % quote_python(self.getLevel()))
        showIndent(outfile, level)
        outfile.write('message = %s,\n' % quote_python(self.getMessage()))
    def exportLiteralHtml(self, outfile, level = 0, name_='dna_message'):
        level += 1
        self.exportLiteralAttributesHtml(outfile, level, name_)
        self.exportLiteralChildrenHtml(outfile, level, name_)
    def exportLiteralAttributesHtml(self, outfile, level, name_):
        pass
    def exportLiteralChildrenHtml(self, outfile, level, name_):
        showIndentHtml(outfile, level)
        outfile.write('ttype = <a  href:"#">%s</a><br>\n' % quote_python(self.getType()))
        showIndentHtml(outfile, level)
        outfile.write('content_type = <a  href:"#">%s</a><br>\n' % quote_python(self.getContent_type()))
        showIndentHtml(outfile, level)
        outfile.write('level = <a  href:"#">%s</a><br>\n' % quote_python(self.getLevel()))
        showIndentHtml(outfile, level)
        outfile.write('message = <a  href:"#">%s</a><br>\n' % quote_python(self.getMessage()))
    def build(self, node_):
        attrs = node_.attributes
        self.buildAttributes(attrs)
        for child_ in node_.childNodes:
            nodeName_ = child_.nodeName.split(':')[-1]
            self.buildChildren(child_, nodeName_)
    def buildAttributes(self, attrs):
        pass
    def buildChildren(self, child_, nodeName_):
        if child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'type':
            type_ = ''
            for text__content_ in child_.childNodes:
                type_ += text__content_.nodeValue
            self.ttype = type_
        elif child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'content_type':
            content_type_ = ''
            for text__content_ in child_.childNodes:
                content_type_ += text__content_.nodeValue
            self.content_type = content_type_
        elif child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'level':
            level_ = ''
            for text__content_ in child_.childNodes:
                level_ += text__content_.nodeValue
            self.level = level_
        elif child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'message':
            message_ = ''
            for text__content_ in child_.childNodes:
                message_ += text__content_.nodeValue
            self.message = message_
# end class dna_message


class input_reflections(object):
    subclass = None
    def __init__(self, hklin=None):
        if hklin is None:
            self.hklin = []
        else:
            self.hklin = hklin
    def factory(*args_, **kwargs_):
        if input_reflections.subclass:
            return input_reflections.subclass(*args_, **kwargs_)
        else:
            return input_reflections(*args_, **kwargs_)
    factory = staticmethod(factory)
    def getHklin(self): return self.hklin
    def setHklin(self, hklin): self.hklin = hklin
    def addHklin(self, value): self.hklin.append(value)
    def insertHklin(self, index, value): self.hklin[index] = value
    def export(self, outfile, level = 0, name_='input_reflections'):
        showIndent(outfile, level)
        outfile.write('<%s>\n' % name_)
        self.exportChildren(outfile, level + 1, name_)
        showIndent(outfile, level)
        outfile.write('</%s>\n' % name_)
    def exportAttributes(self, outfile, level, name_='input_reflections'):
        pass
    def exportChildren(self, outfile, level, name_='input_reflections'):
        for hklin_ in self.getHklin():
            showIndent(outfile, level)
            outfile.write('<hklin>%s</hklin>\n' % quote_xml(hklin_))

    #Only to export the entire XML tree to a file stream on disk
    def outputFile( self, _outfileName ):
        outfile = open( _outfileName, "w" )
        outfile.write("<?xml version=\"1.0\" ?>\n")
        self.export( outfile, 0, name_='input_reflections' )
        outfile.close()


    #Only to export the entire XML tree to a Html Page in a file stream on disk
    def outputPageHtml( self, _outfileName ):
        odtStrTitle = "    <span class=\"title\">input_reflections:</span> <br> <br> <br>\n" 
        outfile = open( _outfileName, "w" )
        outfile.write( TEMPLATE_PAGE_P1 % ( odtStrTitle ) )
        self.exportLiteralHtml( outfile, 0, name_='input_reflections' )
        outfile.write( TEMPLATE_PAGE_P2  )
        outfile.close()


    def outputFileHtml( self, _outfileName ):
        self.outputPageHtml( _outfileName )



    #Static method for parsing a string
    def parseString( _inString ):
        doc = minidom.parseString(_inString)
        rootNode = doc.documentElement
        rootObj = input_reflections.factory()
        rootObj.build(rootNode)
        return rootObj
    parseString = staticmethod( parseString ) 


    #Method for marshalling an object
    def marshal( self ):
        oStreamString = StringIO.StringIO()
        oStreamString.write('<?xml version="1.0" ?>\n')
        self.export( oStreamString, 0, name_="input_reflections" )
        oStringXML = oStreamString.getvalue()
        oStreamString.close()
        return oStringXML

    def exportLiteral(self, outfile, level = 0, name_='input_reflections'):
        level += 1
        self.exportLiteralAttributes(outfile, level, name_)
        self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('hklin=[\n')
        level += 1
        for hklin in self.hklin:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(hklin))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def exportLiteralHtml(self, outfile, level = 0, name_='input_reflections'):
        level += 1
        self.exportLiteralAttributesHtml(outfile, level, name_)
        self.exportLiteralChildrenHtml(outfile, level, name_)
    def exportLiteralAttributesHtml(self, outfile, level, name_):
        pass
    def exportLiteralChildrenHtml(self, outfile, level, name_):
        showIndentHtml(outfile, level)
        outfile.write('hklin<br>\n')
        level += 1
        for hklin in self.hklin:
            showIndentHtml(outfile, level)
            outfile.write('<a  href:"#">%s</a><br>\n' % quote_python(hklin))
        level -= 1
        showIndentHtml(outfile, level)
        outfile.write('<br>\n')
    def build(self, node_):
        attrs = node_.attributes
        self.buildAttributes(attrs)
        for child_ in node_.childNodes:
            nodeName_ = child_.nodeName.split(':')[-1]
            self.buildChildren(child_, nodeName_)
    def buildAttributes(self, attrs):
        pass
    def buildChildren(self, child_, nodeName_):
        if child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'hklin':
            hklin_ = ''
            for text__content_ in child_.childNodes:
                hklin_ += text__content_.nodeValue
            self.hklin.append(hklin_)
# end class input_reflections


class output_reflections(object):
    subclass = None
    def __init__(self, hklout=''):
        self.hklout = hklout
    def factory(*args_, **kwargs_):
        if output_reflections.subclass:
            return output_reflections.subclass(*args_, **kwargs_)
        else:
            return output_reflections(*args_, **kwargs_)
    factory = staticmethod(factory)
    def getHklout(self): return self.hklout
    def setHklout(self, hklout): self.hklout = hklout
    def export(self, outfile, level = 0, name_='output_reflections'):
        showIndent(outfile, level)
        outfile.write('<%s>\n' % name_)
        self.exportChildren(outfile, level + 1, name_)
        showIndent(outfile, level)
        outfile.write('</%s>\n' % name_)
    def exportAttributes(self, outfile, level, name_='output_reflections'):
        pass
    def exportChildren(self, outfile, level, name_='output_reflections'):
        showIndent(outfile, level)
        outfile.write('<hklout>%s</hklout>\n' % quote_xml(self.getHklout()))

    #Only to export the entire XML tree to a file stream on disk
    def outputFile( self, _outfileName ):
        outfile = open( _outfileName, "w" )
        outfile.write("<?xml version=\"1.0\" ?>\n")
        self.export( outfile, 0, name_='output_reflections' )
        outfile.close()


    #Only to export the entire XML tree to a Html Page in a file stream on disk
    def outputPageHtml( self, _outfileName ):
        odtStrTitle = "    <span class=\"title\">output_reflections:</span> <br> <br> <br>\n" 
        outfile = open( _outfileName, "w" )
        outfile.write( TEMPLATE_PAGE_P1 % ( odtStrTitle ) )
        self.exportLiteralHtml( outfile, 0, name_='output_reflections' )
        outfile.write( TEMPLATE_PAGE_P2  )
        outfile.close()


    def outputFileHtml( self, _outfileName ):
        self.outputPageHtml( _outfileName )



    #Static method for parsing a string
    def parseString( _inString ):
        doc = minidom.parseString(_inString)
        rootNode = doc.documentElement
        rootObj = output_reflections.factory()
        rootObj.build(rootNode)
        return rootObj
    parseString = staticmethod( parseString ) 


    #Method for marshalling an object
    def marshal( self ):
        oStreamString = StringIO.StringIO()
        oStreamString.write('<?xml version="1.0" ?>\n')
        self.export( oStreamString, 0, name_="output_reflections" )
        oStringXML = oStreamString.getvalue()
        oStreamString.close()
        return oStringXML

    def exportLiteral(self, outfile, level = 0, name_='output_reflections'):
        level += 1
        self.exportLiteralAttributes(outfile, level, name_)
        self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('hklout = %s,\n' % quote_python(self.getHklout()))
    def exportLiteralHtml(self, outfile, level = 0, name_='output_reflections'):
        level += 1
        self.exportLiteralAttributesHtml(outfile, level, name_)
        self.exportLiteralChildrenHtml(outfile, level, name_)
    def exportLiteralAttributesHtml(self, outfile, level, name_):
        pass
    def exportLiteralChildrenHtml(self, outfile, level, name_):
        showIndentHtml(outfile, level)
        outfile.write('hklout = <a  href:"#">%s</a><br>\n' % quote_python(self.getHklout()))
    def build(self, node_):
        attrs = node_.attributes
        self.buildAttributes(attrs)
        for child_ in node_.childNodes:
            nodeName_ = child_.nodeName.split(':')[-1]
            self.buildChildren(child_, nodeName_)
    def buildAttributes(self, attrs):
        pass
    def buildChildren(self, child_, nodeName_):
        if child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'hklout':
            hklout_ = ''
            for text__content_ in child_.childNodes:
                hklout_ += text__content_.nodeValue
            self.hklout = hklout_
# end class output_reflections


class resolution(object):
    subclass = None
    def __init__(self, lower=0.0, upper=0.0):
        self.lower = lower
        self.upper = upper
    def factory(*args_, **kwargs_):
        if resolution.subclass:
            return resolution.subclass(*args_, **kwargs_)
        else:
            return resolution(*args_, **kwargs_)
    factory = staticmethod(factory)
    def getLower(self): return self.lower
    def setLower(self, lower): self.lower = lower
    def getUpper(self): return self.upper
    def setUpper(self, upper): self.upper = upper
    def export(self, outfile, level = 0, name_='resolution'):
        showIndent(outfile, level)
        outfile.write('<%s>\n' % name_)
        self.exportChildren(outfile, level + 1, name_)
        showIndent(outfile, level)
        outfile.write('</%s>\n' % name_)
    def exportAttributes(self, outfile, level, name_='resolution'):
        pass
    def exportChildren(self, outfile, level, name_='resolution'):
        showIndent(outfile, level)
        outfile.write('<lower>%e</lower>\n' % self.getLower())
        showIndent(outfile, level)
        outfile.write('<upper>%e</upper>\n' % self.getUpper())

    #Only to export the entire XML tree to a file stream on disk
    def outputFile( self, _outfileName ):
        outfile = open( _outfileName, "w" )
        outfile.write("<?xml version=\"1.0\" ?>\n")
        self.export( outfile, 0, name_='resolution' )
        outfile.close()


    #Only to export the entire XML tree to a Html Page in a file stream on disk
    def outputPageHtml( self, _outfileName ):
        odtStrTitle = "    <span class=\"title\">resolution:</span> <br> <br> <br>\n" 
        outfile = open( _outfileName, "w" )
        outfile.write( TEMPLATE_PAGE_P1 % ( odtStrTitle ) )
        self.exportLiteralHtml( outfile, 0, name_='resolution' )
        outfile.write( TEMPLATE_PAGE_P2  )
        outfile.close()


    def outputFileHtml( self, _outfileName ):
        self.outputPageHtml( _outfileName )



    #Static method for parsing a string
    def parseString( _inString ):
        doc = minidom.parseString(_inString)
        rootNode = doc.documentElement
        rootObj = resolution.factory()
        rootObj.build(rootNode)
        return rootObj
    parseString = staticmethod( parseString ) 


    #Method for marshalling an object
    def marshal( self ):
        oStreamString = StringIO.StringIO()
        oStreamString.write('<?xml version="1.0" ?>\n')
        self.export( oStreamString, 0, name_="resolution" )
        oStringXML = oStreamString.getvalue()
        oStreamString.close()
        return oStringXML

    def exportLiteral(self, outfile, level = 0, name_='resolution'):
        level += 1
        self.exportLiteralAttributes(outfile, level, name_)
        self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('lower = %e,\n' % self.getLower())
        showIndent(outfile, level)
        outfile.write('upper = %e,\n' % self.getUpper())
    def exportLiteralHtml(self, outfile, level = 0, name_='resolution'):
        level += 1
        self.exportLiteralAttributesHtml(outfile, level, name_)
        self.exportLiteralChildrenHtml(outfile, level, name_)
    def exportLiteralAttributesHtml(self, outfile, level, name_):
        pass
    def exportLiteralChildrenHtml(self, outfile, level, name_):
        showIndentHtml(outfile, level)
        outfile.write('lower = <a  href:"#">%e</a><br>\n' % self.getLower())
        showIndentHtml(outfile, level)
        outfile.write('upper = <a  href:"#">%e</a><br>\n' % self.getUpper())
    def build(self, node_):
        attrs = node_.attributes
        self.buildAttributes(attrs)
        for child_ in node_.childNodes:
            nodeName_ = child_.nodeName.split(':')[-1]
            self.buildChildren(child_, nodeName_)
    def buildAttributes(self, attrs):
        pass
    def buildChildren(self, child_, nodeName_):
        if child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'lower':
            if child_.firstChild:
                sval_ = child_.firstChild.nodeValue
                try:
                    fval_ = float(sval_)
                except ValueError:
                    raise ValueError('requires float (or double) -- %s' % child_.toxml())
                self.lower = fval_
        elif child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'upper':
            if child_.firstChild:
                sval_ = child_.firstChild.nodeValue
                try:
                    fval_ = float(sval_)
                except ValueError:
                    raise ValueError('requires float (or double) -- %s' % child_.toxml())
                self.upper = fval_
# end class resolution


class abort_request(object):
    subclass = None
    def __init__(self, level=''):
        self.level = level
    def factory(*args_, **kwargs_):
        if abort_request.subclass:
            return abort_request.subclass(*args_, **kwargs_)
        else:
            return abort_request(*args_, **kwargs_)
    factory = staticmethod(factory)
    def getLevel(self): return self.level
    def setLevel(self, level): self.level = level
    def export(self, outfile, level = 0, name_='abort_request'):
        showIndent(outfile, level)
        outfile.write('<%s>\n' % name_)
        self.exportChildren(outfile, level + 1, name_)
        showIndent(outfile, level)
        outfile.write('</%s>\n' % name_)
    def exportAttributes(self, outfile, level, name_='abort_request'):
        pass
    def exportChildren(self, outfile, level, name_='abort_request'):
        showIndent(outfile, level)
        outfile.write('<level>%s</level>\n' % quote_xml(self.getLevel()))

    #Only to export the entire XML tree to a file stream on disk
    def outputFile( self, _outfileName ):
        outfile = open( _outfileName, "w" )
        outfile.write("<?xml version=\"1.0\" ?>\n")
        self.export( outfile, 0, name_='abort_request' )
        outfile.close()


    #Only to export the entire XML tree to a Html Page in a file stream on disk
    def outputPageHtml( self, _outfileName ):
        odtStrTitle = "    <span class=\"title\">abort_request:</span> <br> <br> <br>\n" 
        outfile = open( _outfileName, "w" )
        outfile.write( TEMPLATE_PAGE_P1 % ( odtStrTitle ) )
        self.exportLiteralHtml( outfile, 0, name_='abort_request' )
        outfile.write( TEMPLATE_PAGE_P2  )
        outfile.close()


    def outputFileHtml( self, _outfileName ):
        self.outputPageHtml( _outfileName )



    #Static method for parsing a string
    def parseString( _inString ):
        doc = minidom.parseString(_inString)
        rootNode = doc.documentElement
        rootObj = abort_request.factory()
        rootObj.build(rootNode)
        return rootObj
    parseString = staticmethod( parseString ) 


    #Method for marshalling an object
    def marshal( self ):
        oStreamString = StringIO.StringIO()
        oStreamString.write('<?xml version="1.0" ?>\n')
        self.export( oStreamString, 0, name_="abort_request" )
        oStringXML = oStreamString.getvalue()
        oStreamString.close()
        return oStringXML

    def exportLiteral(self, outfile, level = 0, name_='abort_request'):
        level += 1
        self.exportLiteralAttributes(outfile, level, name_)
        self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('level = %s,\n' % quote_python(self.getLevel()))
    def exportLiteralHtml(self, outfile, level = 0, name_='abort_request'):
        level += 1
        self.exportLiteralAttributesHtml(outfile, level, name_)
        self.exportLiteralChildrenHtml(outfile, level, name_)
    def exportLiteralAttributesHtml(self, outfile, level, name_):
        pass
    def exportLiteralChildrenHtml(self, outfile, level, name_):
        showIndentHtml(outfile, level)
        outfile.write('level = <a  href:"#">%s</a><br>\n' % quote_python(self.getLevel()))
    def build(self, node_):
        attrs = node_.attributes
        self.buildAttributes(attrs)
        for child_ in node_.childNodes:
            nodeName_ = child_.nodeName.split(':')[-1]
            self.buildChildren(child_, nodeName_)
    def buildAttributes(self, attrs):
        pass
    def buildChildren(self, child_, nodeName_):
        if child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'level':
            level_ = ''
            for text__content_ in child_.childNodes:
                level_ += text__content_.nodeValue
            self.level = level_
# end class abort_request


class abort_response(object):
    subclass = None
    def __init__(self, status=None):
        self.status = status
    def factory(*args_, **kwargs_):
        if abort_response.subclass:
            return abort_response.subclass(*args_, **kwargs_)
        else:
            return abort_response(*args_, **kwargs_)
    factory = staticmethod(factory)
    def getStatus(self): return self.status
    def setStatus(self, status): self.status = status
    def export(self, outfile, level = 0, name_='abort_response'):
        showIndent(outfile, level)
        outfile.write('<%s>\n' % name_)
        self.exportChildren(outfile, level + 1, name_)
        showIndent(outfile, level)
        outfile.write('</%s>\n' % name_)
    def exportAttributes(self, outfile, level, name_='abort_response'):
        pass
    def exportChildren(self, outfile, level, name_='abort_response'):
        if self.status:
            self.status.export(outfile, level)

    #Only to export the entire XML tree to a file stream on disk
    def outputFile( self, _outfileName ):
        outfile = open( _outfileName, "w" )
        outfile.write("<?xml version=\"1.0\" ?>\n")
        self.export( outfile, 0, name_='abort_response' )
        outfile.close()


    #Only to export the entire XML tree to a Html Page in a file stream on disk
    def outputPageHtml( self, _outfileName ):
        odtStrTitle = "    <span class=\"title\">abort_response:</span> <br> <br> <br>\n" 
        outfile = open( _outfileName, "w" )
        outfile.write( TEMPLATE_PAGE_P1 % ( odtStrTitle ) )
        self.exportLiteralHtml( outfile, 0, name_='abort_response' )
        outfile.write( TEMPLATE_PAGE_P2  )
        outfile.close()


    def outputFileHtml( self, _outfileName ):
        self.outputPageHtml( _outfileName )



    #Static method for parsing a string
    def parseString( _inString ):
        doc = minidom.parseString(_inString)
        rootNode = doc.documentElement
        rootObj = abort_response.factory()
        rootObj.build(rootNode)
        return rootObj
    parseString = staticmethod( parseString ) 


    #Method for marshalling an object
    def marshal( self ):
        oStreamString = StringIO.StringIO()
        oStreamString.write('<?xml version="1.0" ?>\n')
        self.export( oStreamString, 0, name_="abort_response" )
        oStringXML = oStreamString.getvalue()
        oStreamString.close()
        return oStringXML

    def exportLiteral(self, outfile, level = 0, name_='abort_response'):
        level += 1
        self.exportLiteralAttributes(outfile, level, name_)
        self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.status:
            showIndent(outfile, level)
            outfile.write('status = status(\n')
            self.status.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
    def exportLiteralHtml(self, outfile, level = 0, name_='abort_response'):
        level += 1
        self.exportLiteralAttributesHtml(outfile, level, name_)
        self.exportLiteralChildrenHtml(outfile, level, name_)
    def exportLiteralAttributesHtml(self, outfile, level, name_):
        pass
    def exportLiteralChildrenHtml(self, outfile, level, name_):
        if self.status:
            showIndentHtml(outfile, level)
            outfile.write('status<br>\n')
            self.status.exportLiteralHtml(outfile, level)
            showIndentHtml(outfile, level)
            outfile.write('<br>\n')
    def build(self, node_):
        attrs = node_.attributes
        self.buildAttributes(attrs)
        for child_ in node_.childNodes:
            nodeName_ = child_.nodeName.split(':')[-1]
            self.buildChildren(child_, nodeName_)
    def buildAttributes(self, attrs):
        pass
    def buildChildren(self, child_, nodeName_):
        if child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'status':
            obj_ = status.factory()
            obj_.build(child_)
            self.setStatus(obj_)
# end class abort_response


class sample_reference(object):
    subclass = None
    def __init__(self, code='', container_reference='', container_code='', sample_location='', blSampleId=''):
        self.code = code
        self.container_reference = container_reference
        self.container_code = container_code
        self.sample_location = sample_location
        self.blSampleId = blSampleId
    def factory(*args_, **kwargs_):
        if sample_reference.subclass:
            return sample_reference.subclass(*args_, **kwargs_)
        else:
            return sample_reference(*args_, **kwargs_)
    factory = staticmethod(factory)
    def getCode(self): return self.code
    def setCode(self, code): self.code = code
    def getContainer_reference(self): return self.container_reference
    def setContainer_reference(self, container_reference): self.container_reference = container_reference
    def getContainer_code(self): return self.container_code
    def setContainer_code(self, container_code): self.container_code = container_code
    def getSample_location(self): return self.sample_location
    def setSample_location(self, sample_location): self.sample_location = sample_location
    def getBlSampleId(self): return self.blSampleId
    def setBlSampleId(self, blSampleId): self.blSampleId = blSampleId
    def export(self, outfile, level = 0, name_='sample_reference'):
        showIndent(outfile, level)
        outfile.write('<%s>\n' % name_)
        self.exportChildren(outfile, level + 1, name_)
        showIndent(outfile, level)
        outfile.write('</%s>\n' % name_)
    def exportAttributes(self, outfile, level, name_='sample_reference'):
        pass
    def exportChildren(self, outfile, level, name_='sample_reference'):
        showIndent(outfile, level)
        outfile.write('<code>%s</code>\n' % quote_xml(self.getCode()))
        showIndent(outfile, level)
        outfile.write('<container_reference>%s</container_reference>\n' % quote_xml(self.getContainer_reference()))
        showIndent(outfile, level)
        outfile.write('<container_code>%s</container_code>\n' % quote_xml(self.getContainer_code()))
        showIndent(outfile, level)
        outfile.write('<sample_location>%s</sample_location>\n' % quote_xml(self.getSample_location()))
        showIndent(outfile, level)
        outfile.write('<blSampleId>%s</blSampleId>\n' % quote_xml(self.getBlSampleId()))

    #Only to export the entire XML tree to a file stream on disk
    def outputFile( self, _outfileName ):
        outfile = open( _outfileName, "w" )
        outfile.write("<?xml version=\"1.0\" ?>\n")
        self.export( outfile, 0, name_='sample_reference' )
        outfile.close()


    #Only to export the entire XML tree to a Html Page in a file stream on disk
    def outputPageHtml( self, _outfileName ):
        odtStrTitle = "    <span class=\"title\">sample_reference:</span> <br> <br> <br>\n" 
        outfile = open( _outfileName, "w" )
        outfile.write( TEMPLATE_PAGE_P1 % ( odtStrTitle ) )
        self.exportLiteralHtml( outfile, 0, name_='sample_reference' )
        outfile.write( TEMPLATE_PAGE_P2  )
        outfile.close()


    def outputFileHtml( self, _outfileName ):
        self.outputPageHtml( _outfileName )



    #Static method for parsing a string
    def parseString( _inString ):
        doc = minidom.parseString(_inString)
        rootNode = doc.documentElement
        rootObj = sample_reference.factory()
        rootObj.build(rootNode)
        return rootObj
    parseString = staticmethod( parseString ) 


    #Method for marshalling an object
    def marshal( self ):
        oStreamString = StringIO.StringIO()
        oStreamString.write('<?xml version="1.0" ?>\n')
        self.export( oStreamString, 0, name_="sample_reference" )
        oStringXML = oStreamString.getvalue()
        oStreamString.close()
        return oStringXML

    def exportLiteral(self, outfile, level = 0, name_='sample_reference'):
        level += 1
        self.exportLiteralAttributes(outfile, level, name_)
        self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('code = %s,\n' % quote_python(self.getCode()))
        showIndent(outfile, level)
        outfile.write('container_reference = %s,\n' % quote_python(self.getContainer_reference()))
        showIndent(outfile, level)
        outfile.write('container_code = %s,\n' % quote_python(self.getContainer_code()))
        showIndent(outfile, level)
        outfile.write('sample_location = %s,\n' % quote_python(self.getSample_location()))
        showIndent(outfile, level)
        outfile.write('blSampleId = %s,\n' % quote_python(self.getBlSampleId()))
    def exportLiteralHtml(self, outfile, level = 0, name_='sample_reference'):
        level += 1
        self.exportLiteralAttributesHtml(outfile, level, name_)
        self.exportLiteralChildrenHtml(outfile, level, name_)
    def exportLiteralAttributesHtml(self, outfile, level, name_):
        pass
    def exportLiteralChildrenHtml(self, outfile, level, name_):
        showIndentHtml(outfile, level)
        outfile.write('code = <a  href:"#">%s</a><br>\n' % quote_python(self.getCode()))
        showIndentHtml(outfile, level)
        outfile.write('container_reference = <a  href:"#">%s</a><br>\n' % quote_python(self.getContainer_reference()))
        showIndentHtml(outfile, level)
        outfile.write('container_code = <a  href:"#">%s</a><br>\n' % quote_python(self.getContainer_code()))
        showIndentHtml(outfile, level)
        outfile.write('sample_location = <a  href:"#">%s</a><br>\n' % quote_python(self.getSample_location()))
        showIndentHtml(outfile, level)
        outfile.write('blSampleId = <a  href:"#">%s</a><br>\n' % quote_python(self.getBlSampleId()))
    def build(self, node_):
        attrs = node_.attributes
        self.buildAttributes(attrs)
        for child_ in node_.childNodes:
            nodeName_ = child_.nodeName.split(':')[-1]
            self.buildChildren(child_, nodeName_)
    def buildAttributes(self, attrs):
        pass
    def buildChildren(self, child_, nodeName_):
        if child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'code':
            code_ = ''
            for text__content_ in child_.childNodes:
                code_ += text__content_.nodeValue
            self.code = code_
        elif child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'container_reference':
            container_reference_ = ''
            for text__content_ in child_.childNodes:
                container_reference_ += text__content_.nodeValue
            self.container_reference = container_reference_
        elif child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'container_code':
            container_code_ = ''
            for text__content_ in child_.childNodes:
                container_code_ += text__content_.nodeValue
            self.container_code = container_code_
        elif child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'sample_location':
            sample_location_ = ''
            for text__content_ in child_.childNodes:
                sample_location_ += text__content_.nodeValue
            self.sample_location = sample_location_
        elif child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'blSampleId':
            blSampleId_ = ''
            for text__content_ in child_.childNodes:
                blSampleId_ += text__content_.nodeValue
            self.blSampleId = blSampleId_
# end class sample_reference


class beamline_parameters(object):
    subclass = None
    def __init__(self, maximum_exposure=0.0, minimum_exposure_time=0.0, minimum_phi_speed=0.0, maximum_phi_speed=0.0, minimum_phi_oscillation=0.0):
        self.maximum_exposure = maximum_exposure
        self.minimum_exposure_time = minimum_exposure_time
        self.minimum_phi_speed = minimum_phi_speed
        self.maximum_phi_speed = maximum_phi_speed
        self.minimum_phi_oscillation = minimum_phi_oscillation
    def factory(*args_, **kwargs_):
        if beamline_parameters.subclass:
            return beamline_parameters.subclass(*args_, **kwargs_)
        else:
            return beamline_parameters(*args_, **kwargs_)
    factory = staticmethod(factory)
    def getMaximum_exposure(self): return self.maximum_exposure
    def setMaximum_exposure(self, maximum_exposure): self.maximum_exposure = maximum_exposure
    def getMinimum_exposure_time(self): return self.minimum_exposure_time
    def setMinimum_exposure_time(self, minimum_exposure_time): self.minimum_exposure_time = minimum_exposure_time
    def getMinimum_phi_speed(self): return self.minimum_phi_speed
    def setMinimum_phi_speed(self, minimum_phi_speed): self.minimum_phi_speed = minimum_phi_speed
    def getMaximum_phi_speed(self): return self.maximum_phi_speed
    def setMaximum_phi_speed(self, maximum_phi_speed): self.maximum_phi_speed = maximum_phi_speed
    def getMinimum_phi_oscillation(self): return self.minimum_phi_oscillation
    def setMinimum_phi_oscillation(self, minimum_phi_oscillation): self.minimum_phi_oscillation = minimum_phi_oscillation
    def export(self, outfile, level = 0, name_='beamline_parameters'):
        showIndent(outfile, level)
        outfile.write('<%s>\n' % name_)
        self.exportChildren(outfile, level + 1, name_)
        showIndent(outfile, level)
        outfile.write('</%s>\n' % name_)
    def exportAttributes(self, outfile, level, name_='beamline_parameters'):
        pass
    def exportChildren(self, outfile, level, name_='beamline_parameters'):
        showIndent(outfile, level)
        outfile.write('<maximum_exposure>%e</maximum_exposure>\n' % self.getMaximum_exposure())
        showIndent(outfile, level)
        outfile.write('<minimum_exposure_time>%e</minimum_exposure_time>\n' % self.getMinimum_exposure_time())
        showIndent(outfile, level)
        outfile.write('<minimum_phi_speed>%e</minimum_phi_speed>\n' % self.getMinimum_phi_speed())
        showIndent(outfile, level)
        outfile.write('<maximum_phi_speed>%e</maximum_phi_speed>\n' % self.getMaximum_phi_speed())
        showIndent(outfile, level)
        outfile.write('<minimum_phi_oscillation>%e</minimum_phi_oscillation>\n' % self.getMinimum_phi_oscillation())

    #Only to export the entire XML tree to a file stream on disk
    def outputFile( self, _outfileName ):
        outfile = open( _outfileName, "w" )
        outfile.write("<?xml version=\"1.0\" ?>\n")
        self.export( outfile, 0, name_='beamline_parameters' )
        outfile.close()


    #Only to export the entire XML tree to a Html Page in a file stream on disk
    def outputPageHtml( self, _outfileName ):
        odtStrTitle = "    <span class=\"title\">beamline_parameters:</span> <br> <br> <br>\n" 
        outfile = open( _outfileName, "w" )
        outfile.write( TEMPLATE_PAGE_P1 % ( odtStrTitle ) )
        self.exportLiteralHtml( outfile, 0, name_='beamline_parameters' )
        outfile.write( TEMPLATE_PAGE_P2  )
        outfile.close()


    def outputFileHtml( self, _outfileName ):
        self.outputPageHtml( _outfileName )



    #Static method for parsing a string
    def parseString( _inString ):
        doc = minidom.parseString(_inString)
        rootNode = doc.documentElement
        rootObj = beamline_parameters.factory()
        rootObj.build(rootNode)
        return rootObj
    parseString = staticmethod( parseString ) 


    #Method for marshalling an object
    def marshal( self ):
        oStreamString = StringIO.StringIO()
        oStreamString.write('<?xml version="1.0" ?>\n')
        self.export( oStreamString, 0, name_="beamline_parameters" )
        oStringXML = oStreamString.getvalue()
        oStreamString.close()
        return oStringXML

    def exportLiteral(self, outfile, level = 0, name_='beamline_parameters'):
        level += 1
        self.exportLiteralAttributes(outfile, level, name_)
        self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('maximum_exposure = %e,\n' % self.getMaximum_exposure())
        showIndent(outfile, level)
        outfile.write('minimum_exposure_time = %e,\n' % self.getMinimum_exposure_time())
        showIndent(outfile, level)
        outfile.write('minimum_phi_speed = %e,\n' % self.getMinimum_phi_speed())
        showIndent(outfile, level)
        outfile.write('maximum_phi_speed = %e,\n' % self.getMaximum_phi_speed())
        showIndent(outfile, level)
        outfile.write('minimum_phi_oscillation = %e,\n' % self.getMinimum_phi_oscillation())
    def exportLiteralHtml(self, outfile, level = 0, name_='beamline_parameters'):
        level += 1
        self.exportLiteralAttributesHtml(outfile, level, name_)
        self.exportLiteralChildrenHtml(outfile, level, name_)
    def exportLiteralAttributesHtml(self, outfile, level, name_):
        pass
    def exportLiteralChildrenHtml(self, outfile, level, name_):
        showIndentHtml(outfile, level)
        outfile.write('maximum_exposure = <a  href:"#">%e</a><br>\n' % self.getMaximum_exposure())
        showIndentHtml(outfile, level)
        outfile.write('minimum_exposure_time = <a  href:"#">%e</a><br>\n' % self.getMinimum_exposure_time())
        showIndentHtml(outfile, level)
        outfile.write('minimum_phi_speed = <a  href:"#">%e</a><br>\n' % self.getMinimum_phi_speed())
        showIndentHtml(outfile, level)
        outfile.write('maximum_phi_speed = <a  href:"#">%e</a><br>\n' % self.getMaximum_phi_speed())
        showIndentHtml(outfile, level)
        outfile.write('minimum_phi_oscillation = <a  href:"#">%e</a><br>\n' % self.getMinimum_phi_oscillation())
    def build(self, node_):
        attrs = node_.attributes
        self.buildAttributes(attrs)
        for child_ in node_.childNodes:
            nodeName_ = child_.nodeName.split(':')[-1]
            self.buildChildren(child_, nodeName_)
    def buildAttributes(self, attrs):
        pass
    def buildChildren(self, child_, nodeName_):
        if child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'maximum_exposure':
            if child_.firstChild:
                sval_ = child_.firstChild.nodeValue
                try:
                    fval_ = float(sval_)
                except ValueError:
                    raise ValueError('requires float (or double) -- %s' % child_.toxml())
                self.maximum_exposure = fval_
        elif child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'minimum_exposure_time':
            if child_.firstChild:
                sval_ = child_.firstChild.nodeValue
                try:
                    fval_ = float(sval_)
                except ValueError:
                    raise ValueError('requires float (or double) -- %s' % child_.toxml())
                self.minimum_exposure_time = fval_
        elif child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'minimum_phi_speed':
            if child_.firstChild:
                sval_ = child_.firstChild.nodeValue
                try:
                    fval_ = float(sval_)
                except ValueError:
                    raise ValueError('requires float (or double) -- %s' % child_.toxml())
                self.minimum_phi_speed = fval_
        elif child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'maximum_phi_speed':
            if child_.firstChild:
                sval_ = child_.firstChild.nodeValue
                try:
                    fval_ = float(sval_)
                except ValueError:
                    raise ValueError('requires float (or double) -- %s' % child_.toxml())
                self.maximum_phi_speed = fval_
        elif child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'minimum_phi_oscillation':
            if child_.firstChild:
                sval_ = child_.firstChild.nodeValue
                try:
                    fval_ = float(sval_)
                except ValueError:
                    raise ValueError('requires float (or double) -- %s' % child_.toxml())
                self.minimum_phi_oscillation = fval_
# end class beamline_parameters


class strategy_request(object):
    subclass = None
    def __init__(self, extra_commands=None, strategy_settings=None, symmetry=''):
        self.extra_commands = extra_commands
        self.strategy_settings = strategy_settings
        self.symmetry = symmetry
    def factory(*args_, **kwargs_):
        if strategy_request.subclass:
            return strategy_request.subclass(*args_, **kwargs_)
        else:
            return strategy_request(*args_, **kwargs_)
    factory = staticmethod(factory)
    def getExtra_commands(self): return self.extra_commands
    def setExtra_commands(self, extra_commands): self.extra_commands = extra_commands
    def getStrategy_settings(self): return self.strategy_settings
    def setStrategy_settings(self, strategy_settings): self.strategy_settings = strategy_settings
    def getSymmetry(self): return self.symmetry
    def setSymmetry(self, symmetry): self.symmetry = symmetry
    def export(self, outfile, level = 0, name_='strategy_request'):
        showIndent(outfile, level)
        outfile.write('<%s>\n' % name_)
        self.exportChildren(outfile, level + 1, name_)
        showIndent(outfile, level)
        outfile.write('</%s>\n' % name_)
    def exportAttributes(self, outfile, level, name_='strategy_request'):
        pass
    def exportChildren(self, outfile, level, name_='strategy_request'):
        if self.extra_commands:
            self.extra_commands.export(outfile, level)
        if self.strategy_settings:
            self.strategy_settings.export(outfile, level)
        showIndent(outfile, level)
        outfile.write('<symmetry>%s</symmetry>\n' % quote_xml(self.getSymmetry()))

    #Only to export the entire XML tree to a file stream on disk
    def outputFile( self, _outfileName ):
        outfile = open( _outfileName, "w" )
        outfile.write("<?xml version=\"1.0\" ?>\n")
        self.export( outfile, 0, name_='strategy_request' )
        outfile.close()


    #Only to export the entire XML tree to a Html Page in a file stream on disk
    def outputPageHtml( self, _outfileName ):
        odtStrTitle = "    <span class=\"title\">strategy_request:</span> <br> <br> <br>\n" 
        outfile = open( _outfileName, "w" )
        outfile.write( TEMPLATE_PAGE_P1 % ( odtStrTitle ) )
        self.exportLiteralHtml( outfile, 0, name_='strategy_request' )
        outfile.write( TEMPLATE_PAGE_P2  )
        outfile.close()


    def outputFileHtml( self, _outfileName ):
        self.outputPageHtml( _outfileName )



    #Static method for parsing a string
    def parseString( _inString ):
        doc = minidom.parseString(_inString)
        rootNode = doc.documentElement
        rootObj = strategy_request.factory()
        rootObj.build(rootNode)
        return rootObj
    parseString = staticmethod( parseString ) 


    #Method for marshalling an object
    def marshal( self ):
        oStreamString = StringIO.StringIO()
        oStreamString.write('<?xml version="1.0" ?>\n')
        self.export( oStreamString, 0, name_="strategy_request" )
        oStringXML = oStreamString.getvalue()
        oStreamString.close()
        return oStringXML

    def exportLiteral(self, outfile, level = 0, name_='strategy_request'):
        level += 1
        self.exportLiteralAttributes(outfile, level, name_)
        self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.extra_commands:
            showIndent(outfile, level)
            outfile.write('extra_commands = extra_commands(\n')
            self.extra_commands.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.strategy_settings:
            showIndent(outfile, level)
            outfile.write('strategy_settings = strategy_settings(\n')
            self.strategy_settings.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        showIndent(outfile, level)
        outfile.write('symmetry = %s,\n' % quote_python(self.getSymmetry()))
    def exportLiteralHtml(self, outfile, level = 0, name_='strategy_request'):
        level += 1
        self.exportLiteralAttributesHtml(outfile, level, name_)
        self.exportLiteralChildrenHtml(outfile, level, name_)
    def exportLiteralAttributesHtml(self, outfile, level, name_):
        pass
    def exportLiteralChildrenHtml(self, outfile, level, name_):
        if self.extra_commands:
            showIndentHtml(outfile, level)
            outfile.write('extra_commands<br>\n')
            self.extra_commands.exportLiteralHtml(outfile, level)
            showIndentHtml(outfile, level)
            outfile.write('<br>\n')
        if self.strategy_settings:
            showIndentHtml(outfile, level)
            outfile.write('strategy_settings<br>\n')
            self.strategy_settings.exportLiteralHtml(outfile, level)
            showIndentHtml(outfile, level)
            outfile.write('<br>\n')
        showIndentHtml(outfile, level)
        outfile.write('symmetry = <a  href:"#">%s</a><br>\n' % quote_python(self.getSymmetry()))
    def build(self, node_):
        attrs = node_.attributes
        self.buildAttributes(attrs)
        for child_ in node_.childNodes:
            nodeName_ = child_.nodeName.split(':')[-1]
            self.buildChildren(child_, nodeName_)
    def buildAttributes(self, attrs):
        pass
    def buildChildren(self, child_, nodeName_):
        if child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'extra_commands':
            obj_ = extra_commands.factory()
            obj_.build(child_)
            self.setExtra_commands(obj_)
        elif child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'strategy_settings':
            obj_ = strategy_settings.factory()
            obj_.build(child_)
            self.setStrategy_settings(obj_)
        elif child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'symmetry':
            symmetry_ = ''
            for text__content_ in child_.childNodes:
                symmetry_ += text__content_.nodeValue
            self.symmetry = symmetry_
# end class strategy_request


class strategy_settings(object):
    subclass = None
    def __init__(self, resolution=None, overlap_limit=0.0, completeness=0.0, multiplicity=0.0, i_over_sigma=0.0, anomalous=False, beamline_parameters=None, user_desired_minimum_phi_oscillation=0.0):
        self.resolution = resolution
        self.overlap_limit = overlap_limit
        self.completeness = completeness
        self.multiplicity = multiplicity
        self.i_over_sigma = i_over_sigma
        self.anomalous = anomalous
        self.beamline_parameters = beamline_parameters
        self.user_desired_minimum_phi_oscillation = user_desired_minimum_phi_oscillation
    def factory(*args_, **kwargs_):
        if strategy_settings.subclass:
            return strategy_settings.subclass(*args_, **kwargs_)
        else:
            return strategy_settings(*args_, **kwargs_)
    factory = staticmethod(factory)
    def getResolution(self): return self.resolution
    def setResolution(self, resolution): self.resolution = resolution
    def getOverlap_limit(self): return self.overlap_limit
    def setOverlap_limit(self, overlap_limit): self.overlap_limit = overlap_limit
    def getCompleteness(self): return self.completeness
    def setCompleteness(self, completeness): self.completeness = completeness
    def getMultiplicity(self): return self.multiplicity
    def setMultiplicity(self, multiplicity): self.multiplicity = multiplicity
    def getI_over_sigma(self): return self.i_over_sigma
    def setI_over_sigma(self, i_over_sigma): self.i_over_sigma = i_over_sigma
    def getAnomalous(self): return self.anomalous
    def setAnomalous(self, anomalous): self.anomalous = anomalous
    def getBeamline_parameters(self): return self.beamline_parameters
    def setBeamline_parameters(self, beamline_parameters): self.beamline_parameters = beamline_parameters
    def getUser_desired_minimum_phi_oscillation(self): return self.user_desired_minimum_phi_oscillation
    def setUser_desired_minimum_phi_oscillation(self, user_desired_minimum_phi_oscillation): self.user_desired_minimum_phi_oscillation = user_desired_minimum_phi_oscillation
    def export(self, outfile, level = 0, name_='strategy_settings'):
        showIndent(outfile, level)
        outfile.write('<%s>\n' % name_)
        self.exportChildren(outfile, level + 1, name_)
        showIndent(outfile, level)
        outfile.write('</%s>\n' % name_)
    def exportAttributes(self, outfile, level, name_='strategy_settings'):
        pass
    def exportChildren(self, outfile, level, name_='strategy_settings'):
        if self.resolution:
            self.resolution.export(outfile, level)
        showIndent(outfile, level)
        outfile.write('<overlap_limit>%e</overlap_limit>\n' % self.getOverlap_limit())
        showIndent(outfile, level)
        outfile.write('<completeness>%e</completeness>\n' % self.getCompleteness())
        showIndent(outfile, level)
        outfile.write('<multiplicity>%e</multiplicity>\n' % self.getMultiplicity())
        showIndent(outfile, level)
        outfile.write('<i_over_sigma>%e</i_over_sigma>\n' % self.getI_over_sigma())
        showIndent(outfile, level)
        outfile.write('<anomalous>%s</anomalous>\n' % self.getAnomalous())
        if self.beamline_parameters:
            self.beamline_parameters.export(outfile, level)
        showIndent(outfile, level)
        outfile.write('<user_desired_minimum_phi_oscillation>%e</user_desired_minimum_phi_oscillation>\n' % self.getUser_desired_minimum_phi_oscillation())

    #Only to export the entire XML tree to a file stream on disk
    def outputFile( self, _outfileName ):
        outfile = open( _outfileName, "w" )
        outfile.write("<?xml version=\"1.0\" ?>\n")
        self.export( outfile, 0, name_='strategy_settings' )
        outfile.close()


    #Only to export the entire XML tree to a Html Page in a file stream on disk
    def outputPageHtml( self, _outfileName ):
        odtStrTitle = "    <span class=\"title\">strategy_settings:</span> <br> <br> <br>\n" 
        outfile = open( _outfileName, "w" )
        outfile.write( TEMPLATE_PAGE_P1 % ( odtStrTitle ) )
        self.exportLiteralHtml( outfile, 0, name_='strategy_settings' )
        outfile.write( TEMPLATE_PAGE_P2  )
        outfile.close()


    def outputFileHtml( self, _outfileName ):
        self.outputPageHtml( _outfileName )



    #Static method for parsing a string
    def parseString( _inString ):
        doc = minidom.parseString(_inString)
        rootNode = doc.documentElement
        rootObj = strategy_settings.factory()
        rootObj.build(rootNode)
        return rootObj
    parseString = staticmethod( parseString ) 


    #Method for marshalling an object
    def marshal( self ):
        oStreamString = StringIO.StringIO()
        oStreamString.write('<?xml version="1.0" ?>\n')
        self.export( oStreamString, 0, name_="strategy_settings" )
        oStringXML = oStreamString.getvalue()
        oStreamString.close()
        return oStringXML

    def exportLiteral(self, outfile, level = 0, name_='strategy_settings'):
        level += 1
        self.exportLiteralAttributes(outfile, level, name_)
        self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.resolution:
            showIndent(outfile, level)
            outfile.write('resolution = resolution(\n')
            self.resolution.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        showIndent(outfile, level)
        outfile.write('overlap_limit = %e,\n' % self.getOverlap_limit())
        showIndent(outfile, level)
        outfile.write('completeness = %e,\n' % self.getCompleteness())
        showIndent(outfile, level)
        outfile.write('multiplicity = %e,\n' % self.getMultiplicity())
        showIndent(outfile, level)
        outfile.write('i_over_sigma = %e,\n' % self.getI_over_sigma())
        showIndent(outfile, level)
        outfile.write('anomalous = %s,\n' % self.getAnomalous())
        if self.beamline_parameters:
            showIndent(outfile, level)
            outfile.write('beamline_parameters = beamline_parameters(\n')
            self.beamline_parameters.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        showIndent(outfile, level)
        outfile.write('user_desired_minimum_phi_oscillation = %e,\n' % self.getUser_desired_minimum_phi_oscillation())
    def exportLiteralHtml(self, outfile, level = 0, name_='strategy_settings'):
        level += 1
        self.exportLiteralAttributesHtml(outfile, level, name_)
        self.exportLiteralChildrenHtml(outfile, level, name_)
    def exportLiteralAttributesHtml(self, outfile, level, name_):
        pass
    def exportLiteralChildrenHtml(self, outfile, level, name_):
        if self.resolution:
            showIndentHtml(outfile, level)
            outfile.write('resolution<br>\n')
            self.resolution.exportLiteralHtml(outfile, level)
            showIndentHtml(outfile, level)
            outfile.write('<br>\n')
        showIndentHtml(outfile, level)
        outfile.write('overlap_limit = <a  href:"#">%e</a><br>\n' % self.getOverlap_limit())
        showIndentHtml(outfile, level)
        outfile.write('completeness = <a  href:"#">%e</a><br>\n' % self.getCompleteness())
        showIndentHtml(outfile, level)
        outfile.write('multiplicity = <a  href:"#">%e</a><br>\n' % self.getMultiplicity())
        showIndentHtml(outfile, level)
        outfile.write('i_over_sigma = <a  href:"#">%e</a><br>\n' % self.getI_over_sigma())
        showIndentHtml(outfile, level)
        outfile.write('anomalous = <a  href:"#">%s</a><br>\n' % self.getAnomalous())
        if self.beamline_parameters:
            showIndentHtml(outfile, level)
            outfile.write('beamline_parameters<br>\n')
            self.beamline_parameters.exportLiteralHtml(outfile, level)
            showIndentHtml(outfile, level)
            outfile.write('<br>\n')
        showIndentHtml(outfile, level)
        outfile.write('user_desired_minimum_phi_oscillation = <a  href:"#">%e</a><br>\n' % self.getUser_desired_minimum_phi_oscillation())
    def build(self, node_):
        attrs = node_.attributes
        self.buildAttributes(attrs)
        for child_ in node_.childNodes:
            nodeName_ = child_.nodeName.split(':')[-1]
            self.buildChildren(child_, nodeName_)
    def buildAttributes(self, attrs):
        pass
    def buildChildren(self, child_, nodeName_):
        if child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'resolution':
            obj_ = resolution.factory()
            obj_.build(child_)
            self.setResolution(obj_)
        elif child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'overlap_limit':
            if child_.firstChild:
                sval_ = child_.firstChild.nodeValue
                try:
                    fval_ = float(sval_)
                except ValueError:
                    raise ValueError('requires float (or double) -- %s' % child_.toxml())
                self.overlap_limit = fval_
        elif child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'completeness':
            if child_.firstChild:
                sval_ = child_.firstChild.nodeValue
                try:
                    fval_ = float(sval_)
                except ValueError:
                    raise ValueError('requires float (or double) -- %s' % child_.toxml())
                self.completeness = fval_
        elif child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'multiplicity':
            if child_.firstChild:
                sval_ = child_.firstChild.nodeValue
                try:
                    fval_ = float(sval_)
                except ValueError:
                    raise ValueError('requires float (or double) -- %s' % child_.toxml())
                self.multiplicity = fval_
        elif child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'i_over_sigma':
            if child_.firstChild:
                sval_ = child_.firstChild.nodeValue
                try:
                    fval_ = float(sval_)
                except ValueError:
                    raise ValueError('requires float (or double) -- %s' % child_.toxml())
                self.i_over_sigma = fval_
        elif child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'anomalous':
            if child_.firstChild:
                sval_ = child_.firstChild.nodeValue
                if sval_ in ('true', 'True', '1'):
                    ival_ = True
                elif sval_ in ('false', 'False', '0'):
                    ival_ = False
                else:
                    raise ValueError('requires boolean -- %s' % child_.toxml())
                self.anomalous = ival_
        elif child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'beamline_parameters':
            obj_ = beamline_parameters.factory()
            obj_.build(child_)
            self.setBeamline_parameters(obj_)
        elif child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'user_desired_minimum_phi_oscillation':
            if child_.firstChild:
                sval_ = child_.firstChild.nodeValue
                try:
                    fval_ = float(sval_)
                except ValueError:
                    raise ValueError('requires float (or double) -- %s' % child_.toxml())
                self.user_desired_minimum_phi_oscillation = fval_
# end class strategy_settings


class completeness(object):
    subclass = None
    def __init__(self, standard=0.0):
        self.standard = standard
    def factory(*args_, **kwargs_):
        if completeness.subclass:
            return completeness.subclass(*args_, **kwargs_)
        else:
            return completeness(*args_, **kwargs_)
    factory = staticmethod(factory)
    def getStandard(self): return self.standard
    def setStandard(self, standard): self.standard = standard
    def export(self, outfile, level = 0, name_='completeness'):
        showIndent(outfile, level)
        outfile.write('<%s>\n' % name_)
        self.exportChildren(outfile, level + 1, name_)
        showIndent(outfile, level)
        outfile.write('</%s>\n' % name_)
    def exportAttributes(self, outfile, level, name_='completeness'):
        pass
    def exportChildren(self, outfile, level, name_='completeness'):
        showIndent(outfile, level)
        outfile.write('<standard>%e</standard>\n' % self.getStandard())

    #Only to export the entire XML tree to a file stream on disk
    def outputFile( self, _outfileName ):
        outfile = open( _outfileName, "w" )
        outfile.write("<?xml version=\"1.0\" ?>\n")
        self.export( outfile, 0, name_='completeness' )
        outfile.close()


    #Only to export the entire XML tree to a Html Page in a file stream on disk
    def outputPageHtml( self, _outfileName ):
        odtStrTitle = "    <span class=\"title\">completeness:</span> <br> <br> <br>\n" 
        outfile = open( _outfileName, "w" )
        outfile.write( TEMPLATE_PAGE_P1 % ( odtStrTitle ) )
        self.exportLiteralHtml( outfile, 0, name_='completeness' )
        outfile.write( TEMPLATE_PAGE_P2  )
        outfile.close()


    def outputFileHtml( self, _outfileName ):
        self.outputPageHtml( _outfileName )



    #Static method for parsing a string
    def parseString( _inString ):
        doc = minidom.parseString(_inString)
        rootNode = doc.documentElement
        rootObj = completeness.factory()
        rootObj.build(rootNode)
        return rootObj
    parseString = staticmethod( parseString ) 


    #Method for marshalling an object
    def marshal( self ):
        oStreamString = StringIO.StringIO()
        oStreamString.write('<?xml version="1.0" ?>\n')
        self.export( oStreamString, 0, name_="completeness" )
        oStringXML = oStreamString.getvalue()
        oStreamString.close()
        return oStringXML

    def exportLiteral(self, outfile, level = 0, name_='completeness'):
        level += 1
        self.exportLiteralAttributes(outfile, level, name_)
        self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('standard = %e,\n' % self.getStandard())
    def exportLiteralHtml(self, outfile, level = 0, name_='completeness'):
        level += 1
        self.exportLiteralAttributesHtml(outfile, level, name_)
        self.exportLiteralChildrenHtml(outfile, level, name_)
    def exportLiteralAttributesHtml(self, outfile, level, name_):
        pass
    def exportLiteralChildrenHtml(self, outfile, level, name_):
        showIndentHtml(outfile, level)
        outfile.write('standard = <a  href:"#">%e</a><br>\n' % self.getStandard())
    def build(self, node_):
        attrs = node_.attributes
        self.buildAttributes(attrs)
        for child_ in node_.childNodes:
            nodeName_ = child_.nodeName.split(':')[-1]
            self.buildChildren(child_, nodeName_)
    def buildAttributes(self, attrs):
        pass
    def buildChildren(self, child_, nodeName_):
        if child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'standard':
            if child_.firstChild:
                sval_ = child_.firstChild.nodeValue
                try:
                    fval_ = float(sval_)
                except ValueError:
                    raise ValueError('requires float (or double) -- %s' % child_.toxml())
                self.standard = fval_
# end class completeness


class predicted_spots(object):
    subclass = None
    def __init__(self, full='', overlap=''):
        self.full = full
        self.overlap = overlap
    def factory(*args_, **kwargs_):
        if predicted_spots.subclass:
            return predicted_spots.subclass(*args_, **kwargs_)
        else:
            return predicted_spots(*args_, **kwargs_)
    factory = staticmethod(factory)
    def getFull(self): return self.full
    def setFull(self, full): self.full = full
    def getOverlap(self): return self.overlap
    def setOverlap(self, overlap): self.overlap = overlap
    def export(self, outfile, level = 0, name_='predicted_spots'):
        showIndent(outfile, level)
        outfile.write('<%s>\n' % name_)
        self.exportChildren(outfile, level + 1, name_)
        showIndent(outfile, level)
        outfile.write('</%s>\n' % name_)
    def exportAttributes(self, outfile, level, name_='predicted_spots'):
        pass
    def exportChildren(self, outfile, level, name_='predicted_spots'):
        showIndent(outfile, level)
        outfile.write('<full>%s</full>\n' % quote_xml(self.getFull()))
        showIndent(outfile, level)
        outfile.write('<overlap>%s</overlap>\n' % quote_xml(self.getOverlap()))

    #Only to export the entire XML tree to a file stream on disk
    def outputFile( self, _outfileName ):
        outfile = open( _outfileName, "w" )
        outfile.write("<?xml version=\"1.0\" ?>\n")
        self.export( outfile, 0, name_='predicted_spots' )
        outfile.close()


    #Only to export the entire XML tree to a Html Page in a file stream on disk
    def outputPageHtml( self, _outfileName ):
        odtStrTitle = "    <span class=\"title\">predicted_spots:</span> <br> <br> <br>\n" 
        outfile = open( _outfileName, "w" )
        outfile.write( TEMPLATE_PAGE_P1 % ( odtStrTitle ) )
        self.exportLiteralHtml( outfile, 0, name_='predicted_spots' )
        outfile.write( TEMPLATE_PAGE_P2  )
        outfile.close()


    def outputFileHtml( self, _outfileName ):
        self.outputPageHtml( _outfileName )



    #Static method for parsing a string
    def parseString( _inString ):
        doc = minidom.parseString(_inString)
        rootNode = doc.documentElement
        rootObj = predicted_spots.factory()
        rootObj.build(rootNode)
        return rootObj
    parseString = staticmethod( parseString ) 


    #Method for marshalling an object
    def marshal( self ):
        oStreamString = StringIO.StringIO()
        oStreamString.write('<?xml version="1.0" ?>\n')
        self.export( oStreamString, 0, name_="predicted_spots" )
        oStringXML = oStreamString.getvalue()
        oStreamString.close()
        return oStringXML

    def exportLiteral(self, outfile, level = 0, name_='predicted_spots'):
        level += 1
        self.exportLiteralAttributes(outfile, level, name_)
        self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('full = %s,\n' % quote_python(self.getFull()))
        showIndent(outfile, level)
        outfile.write('overlap = %s,\n' % quote_python(self.getOverlap()))
    def exportLiteralHtml(self, outfile, level = 0, name_='predicted_spots'):
        level += 1
        self.exportLiteralAttributesHtml(outfile, level, name_)
        self.exportLiteralChildrenHtml(outfile, level, name_)
    def exportLiteralAttributesHtml(self, outfile, level, name_):
        pass
    def exportLiteralChildrenHtml(self, outfile, level, name_):
        showIndentHtml(outfile, level)
        outfile.write('full = <a  href:"#">%s</a><br>\n' % quote_python(self.getFull()))
        showIndentHtml(outfile, level)
        outfile.write('overlap = <a  href:"#">%s</a><br>\n' % quote_python(self.getOverlap()))
    def build(self, node_):
        attrs = node_.attributes
        self.buildAttributes(attrs)
        for child_ in node_.childNodes:
            nodeName_ = child_.nodeName.split(':')[-1]
            self.buildChildren(child_, nodeName_)
    def buildAttributes(self, attrs):
        pass
    def buildChildren(self, child_, nodeName_):
        if child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'full':
            full_ = ''
            for text__content_ in child_.childNodes:
                full_ += text__content_.nodeValue
            self.full = full_
        elif child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'overlap':
            overlap_ = ''
            for text__content_ in child_.childNodes:
                overlap_ += text__content_.nodeValue
            self.overlap = overlap_
# end class predicted_spots


class segment(object):
    subclass = None
    def __init__(self, oscillation_sequence=None, predicted_spots=None):
        self.oscillation_sequence = oscillation_sequence
        self.predicted_spots = predicted_spots
    def factory(*args_, **kwargs_):
        if segment.subclass:
            return segment.subclass(*args_, **kwargs_)
        else:
            return segment(*args_, **kwargs_)
    factory = staticmethod(factory)
    def getOscillation_sequence(self): return self.oscillation_sequence
    def setOscillation_sequence(self, oscillation_sequence): self.oscillation_sequence = oscillation_sequence
    def getPredicted_spots(self): return self.predicted_spots
    def setPredicted_spots(self, predicted_spots): self.predicted_spots = predicted_spots
    def export(self, outfile, level = 0, name_='segment'):
        showIndent(outfile, level)
        outfile.write('<%s>\n' % name_)
        self.exportChildren(outfile, level + 1, name_)
        showIndent(outfile, level)
        outfile.write('</%s>\n' % name_)
    def exportAttributes(self, outfile, level, name_='segment'):
        pass
    def exportChildren(self, outfile, level, name_='segment'):
        if self.oscillation_sequence:
            self.oscillation_sequence.export(outfile, level)
        if self.predicted_spots:
            self.predicted_spots.export(outfile, level)

    #Only to export the entire XML tree to a file stream on disk
    def outputFile( self, _outfileName ):
        outfile = open( _outfileName, "w" )
        outfile.write("<?xml version=\"1.0\" ?>\n")
        self.export( outfile, 0, name_='segment' )
        outfile.close()


    #Only to export the entire XML tree to a Html Page in a file stream on disk
    def outputPageHtml( self, _outfileName ):
        odtStrTitle = "    <span class=\"title\">segment:</span> <br> <br> <br>\n" 
        outfile = open( _outfileName, "w" )
        outfile.write( TEMPLATE_PAGE_P1 % ( odtStrTitle ) )
        self.exportLiteralHtml( outfile, 0, name_='segment' )
        outfile.write( TEMPLATE_PAGE_P2  )
        outfile.close()


    def outputFileHtml( self, _outfileName ):
        self.outputPageHtml( _outfileName )



    #Static method for parsing a string
    def parseString( _inString ):
        doc = minidom.parseString(_inString)
        rootNode = doc.documentElement
        rootObj = segment.factory()
        rootObj.build(rootNode)
        return rootObj
    parseString = staticmethod( parseString ) 


    #Method for marshalling an object
    def marshal( self ):
        oStreamString = StringIO.StringIO()
        oStreamString.write('<?xml version="1.0" ?>\n')
        self.export( oStreamString, 0, name_="segment" )
        oStringXML = oStreamString.getvalue()
        oStreamString.close()
        return oStringXML

    def exportLiteral(self, outfile, level = 0, name_='segment'):
        level += 1
        self.exportLiteralAttributes(outfile, level, name_)
        self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.oscillation_sequence:
            showIndent(outfile, level)
            outfile.write('oscillation_sequence = oscillation_sequence(\n')
            self.oscillation_sequence.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.predicted_spots:
            showIndent(outfile, level)
            outfile.write('predicted_spots = predicted_spots(\n')
            self.predicted_spots.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
    def exportLiteralHtml(self, outfile, level = 0, name_='segment'):
        level += 1
        self.exportLiteralAttributesHtml(outfile, level, name_)
        self.exportLiteralChildrenHtml(outfile, level, name_)
    def exportLiteralAttributesHtml(self, outfile, level, name_):
        pass
    def exportLiteralChildrenHtml(self, outfile, level, name_):
        if self.oscillation_sequence:
            showIndentHtml(outfile, level)
            outfile.write('oscillation_sequence<br>\n')
            self.oscillation_sequence.exportLiteralHtml(outfile, level)
            showIndentHtml(outfile, level)
            outfile.write('<br>\n')
        if self.predicted_spots:
            showIndentHtml(outfile, level)
            outfile.write('predicted_spots<br>\n')
            self.predicted_spots.exportLiteralHtml(outfile, level)
            showIndentHtml(outfile, level)
            outfile.write('<br>\n')
    def build(self, node_):
        attrs = node_.attributes
        self.buildAttributes(attrs)
        for child_ in node_.childNodes:
            nodeName_ = child_.nodeName.split(':')[-1]
            self.buildChildren(child_, nodeName_)
    def buildAttributes(self, attrs):
        pass
    def buildChildren(self, child_, nodeName_):
        if child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'oscillation_sequence':
            obj_ = oscillation_sequence.factory()
            obj_.build(child_)
            self.setOscillation_sequence(obj_)
        elif child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'predicted_spots':
            obj_ = predicted_spots.factory()
            obj_.build(child_)
            self.setPredicted_spots(obj_)
# end class segment


class strategy_summary(object):
    subclass = None
    def __init__(self, number_of_segments='', segment=None):
        self.number_of_segments = number_of_segments
        if segment is None:
            self.segment = []
        else:
            self.segment = segment
    def factory(*args_, **kwargs_):
        if strategy_summary.subclass:
            return strategy_summary.subclass(*args_, **kwargs_)
        else:
            return strategy_summary(*args_, **kwargs_)
    factory = staticmethod(factory)
    def getNumber_of_segments(self): return self.number_of_segments
    def setNumber_of_segments(self, number_of_segments): self.number_of_segments = number_of_segments
    def getSegment(self): return self.segment
    def setSegment(self, segment): self.segment = segment
    def addSegment(self, value): self.segment.append(value)
    def insertSegment(self, index, value): self.segment[index] = value
    def export(self, outfile, level = 0, name_='strategy_summary'):
        showIndent(outfile, level)
        outfile.write('<%s>\n' % name_)
        self.exportChildren(outfile, level + 1, name_)
        showIndent(outfile, level)
        outfile.write('</%s>\n' % name_)
    def exportAttributes(self, outfile, level, name_='strategy_summary'):
        pass
    def exportChildren(self, outfile, level, name_='strategy_summary'):
        showIndent(outfile, level)
        outfile.write('<number_of_segments>%s</number_of_segments>\n' % quote_xml(self.getNumber_of_segments()))
        for segment_ in self.getSegment():
            segment_.export(outfile, level)

    #Only to export the entire XML tree to a file stream on disk
    def outputFile( self, _outfileName ):
        outfile = open( _outfileName, "w" )
        outfile.write("<?xml version=\"1.0\" ?>\n")
        self.export( outfile, 0, name_='strategy_summary' )
        outfile.close()


    #Only to export the entire XML tree to a Html Page in a file stream on disk
    def outputPageHtml( self, _outfileName ):
        odtStrTitle = "    <span class=\"title\">strategy_summary:</span> <br> <br> <br>\n" 
        outfile = open( _outfileName, "w" )
        outfile.write( TEMPLATE_PAGE_P1 % ( odtStrTitle ) )
        self.exportLiteralHtml( outfile, 0, name_='strategy_summary' )
        outfile.write( TEMPLATE_PAGE_P2  )
        outfile.close()


    def outputFileHtml( self, _outfileName ):
        self.outputPageHtml( _outfileName )



    #Static method for parsing a string
    def parseString( _inString ):
        doc = minidom.parseString(_inString)
        rootNode = doc.documentElement
        rootObj = strategy_summary.factory()
        rootObj.build(rootNode)
        return rootObj
    parseString = staticmethod( parseString ) 


    #Method for marshalling an object
    def marshal( self ):
        oStreamString = StringIO.StringIO()
        oStreamString.write('<?xml version="1.0" ?>\n')
        self.export( oStreamString, 0, name_="strategy_summary" )
        oStringXML = oStreamString.getvalue()
        oStreamString.close()
        return oStringXML

    def exportLiteral(self, outfile, level = 0, name_='strategy_summary'):
        level += 1
        self.exportLiteralAttributes(outfile, level, name_)
        self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('number_of_segments = %s,\n' % quote_python(self.getNumber_of_segments()))
        showIndent(outfile, level)
        outfile.write('segment=[\n')
        level += 1
        for segment in self.segment:
            showIndent(outfile, level)
            outfile.write('segment(\n')
            segment.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def exportLiteralHtml(self, outfile, level = 0, name_='strategy_summary'):
        level += 1
        self.exportLiteralAttributesHtml(outfile, level, name_)
        self.exportLiteralChildrenHtml(outfile, level, name_)
    def exportLiteralAttributesHtml(self, outfile, level, name_):
        pass
    def exportLiteralChildrenHtml(self, outfile, level, name_):
        showIndentHtml(outfile, level)
        outfile.write('number_of_segments = <a  href:"#">%s</a><br>\n' % quote_python(self.getNumber_of_segments()))
        showIndentHtml(outfile, level)
        outfile.write('segment<br>\n')
        level += 1
        for segment in self.segment:
            segment.exportLiteralHtml(outfile, level)
            showIndentHtml(outfile, level)
            outfile.write('<br>\n')
        level -= 1
        showIndentHtml(outfile, level)
        outfile.write('<br>\n')
    def build(self, node_):
        attrs = node_.attributes
        self.buildAttributes(attrs)
        for child_ in node_.childNodes:
            nodeName_ = child_.nodeName.split(':')[-1]
            self.buildChildren(child_, nodeName_)
    def buildAttributes(self, attrs):
        pass
    def buildChildren(self, child_, nodeName_):
        if child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'number_of_segments':
            number_of_segments_ = ''
            for text__content_ in child_.childNodes:
                number_of_segments_ += text__content_.nodeValue
            self.number_of_segments = number_of_segments_
        elif child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'segment':
            obj_ = segment.factory()
            obj_.build(child_)
            self.segment.append(obj_)
# end class strategy_summary


class strategy_interpretation(object):
    subclass = None
    def __init__(self, oscillation_sequence=None):
        if oscillation_sequence is None:
            self.oscillation_sequence = []
        else:
            self.oscillation_sequence = oscillation_sequence
    def factory(*args_, **kwargs_):
        if strategy_interpretation.subclass:
            return strategy_interpretation.subclass(*args_, **kwargs_)
        else:
            return strategy_interpretation(*args_, **kwargs_)
    factory = staticmethod(factory)
    def getOscillation_sequence(self): return self.oscillation_sequence
    def setOscillation_sequence(self, oscillation_sequence): self.oscillation_sequence = oscillation_sequence
    def addOscillation_sequence(self, value): self.oscillation_sequence.append(value)
    def insertOscillation_sequence(self, index, value): self.oscillation_sequence[index] = value
    def export(self, outfile, level = 0, name_='strategy_interpretation'):
        showIndent(outfile, level)
        outfile.write('<%s>\n' % name_)
        self.exportChildren(outfile, level + 1, name_)
        showIndent(outfile, level)
        outfile.write('</%s>\n' % name_)
    def exportAttributes(self, outfile, level, name_='strategy_interpretation'):
        pass
    def exportChildren(self, outfile, level, name_='strategy_interpretation'):
        for oscillation_sequence_ in self.getOscillation_sequence():
            oscillation_sequence_.export(outfile, level)

    #Only to export the entire XML tree to a file stream on disk
    def outputFile( self, _outfileName ):
        outfile = open( _outfileName, "w" )
        outfile.write("<?xml version=\"1.0\" ?>\n")
        self.export( outfile, 0, name_='strategy_interpretation' )
        outfile.close()


    #Only to export the entire XML tree to a Html Page in a file stream on disk
    def outputPageHtml( self, _outfileName ):
        odtStrTitle = "    <span class=\"title\">strategy_interpretation:</span> <br> <br> <br>\n" 
        outfile = open( _outfileName, "w" )
        outfile.write( TEMPLATE_PAGE_P1 % ( odtStrTitle ) )
        self.exportLiteralHtml( outfile, 0, name_='strategy_interpretation' )
        outfile.write( TEMPLATE_PAGE_P2  )
        outfile.close()


    def outputFileHtml( self, _outfileName ):
        self.outputPageHtml( _outfileName )



    #Static method for parsing a string
    def parseString( _inString ):
        doc = minidom.parseString(_inString)
        rootNode = doc.documentElement
        rootObj = strategy_interpretation.factory()
        rootObj.build(rootNode)
        return rootObj
    parseString = staticmethod( parseString ) 


    #Method for marshalling an object
    def marshal( self ):
        oStreamString = StringIO.StringIO()
        oStreamString.write('<?xml version="1.0" ?>\n')
        self.export( oStreamString, 0, name_="strategy_interpretation" )
        oStringXML = oStreamString.getvalue()
        oStreamString.close()
        return oStringXML

    def exportLiteral(self, outfile, level = 0, name_='strategy_interpretation'):
        level += 1
        self.exportLiteralAttributes(outfile, level, name_)
        self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('oscillation_sequence=[\n')
        level += 1
        for oscillation_sequence in self.oscillation_sequence:
            showIndent(outfile, level)
            outfile.write('oscillation_sequence(\n')
            oscillation_sequence.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def exportLiteralHtml(self, outfile, level = 0, name_='strategy_interpretation'):
        level += 1
        self.exportLiteralAttributesHtml(outfile, level, name_)
        self.exportLiteralChildrenHtml(outfile, level, name_)
    def exportLiteralAttributesHtml(self, outfile, level, name_):
        pass
    def exportLiteralChildrenHtml(self, outfile, level, name_):
        showIndentHtml(outfile, level)
        outfile.write('oscillation_sequence<br>\n')
        level += 1
        for oscillation_sequence in self.oscillation_sequence:
            oscillation_sequence.exportLiteralHtml(outfile, level)
            showIndentHtml(outfile, level)
            outfile.write('<br>\n')
        level -= 1
        showIndentHtml(outfile, level)
        outfile.write('<br>\n')
    def build(self, node_):
        attrs = node_.attributes
        self.buildAttributes(attrs)
        for child_ in node_.childNodes:
            nodeName_ = child_.nodeName.split(':')[-1]
            self.buildChildren(child_, nodeName_)
    def buildAttributes(self, attrs):
        pass
    def buildChildren(self, child_, nodeName_):
        if child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'oscillation_sequence':
            obj_ = oscillation_sequence.factory()
            obj_.build(child_)
            self.oscillation_sequence.append(obj_)
# end class strategy_interpretation


class strategy_response(object):
    subclass = None
    def __init__(self, status=None, completeness=None, strategy_summary=None, segment=None, strategy_interpretation=None, strategy_statistics=None):
        self.status = status
        self.completeness = completeness
        if strategy_summary is None:
            self.strategy_summary = []
        else:
            self.strategy_summary = strategy_summary
        if segment is None:
            self.segment = []
        else:
            self.segment = segment
        self.strategy_interpretation = strategy_interpretation
        self.strategy_statistics = strategy_statistics
    def factory(*args_, **kwargs_):
        if strategy_response.subclass:
            return strategy_response.subclass(*args_, **kwargs_)
        else:
            return strategy_response(*args_, **kwargs_)
    factory = staticmethod(factory)
    def getStatus(self): return self.status
    def setStatus(self, status): self.status = status
    def getCompleteness(self): return self.completeness
    def setCompleteness(self, completeness): self.completeness = completeness
    def getStrategy_summary(self): return self.strategy_summary
    def setStrategy_summary(self, strategy_summary): self.strategy_summary = strategy_summary
    def addStrategy_summary(self, value): self.strategy_summary.append(value)
    def insertStrategy_summary(self, index, value): self.strategy_summary[index] = value
    def getSegment(self): return self.segment
    def setSegment(self, segment): self.segment = segment
    def addSegment(self, value): self.segment.append(value)
    def insertSegment(self, index, value): self.segment[index] = value
    def getStrategy_interpretation(self): return self.strategy_interpretation
    def setStrategy_interpretation(self, strategy_interpretation): self.strategy_interpretation = strategy_interpretation
    def getStrategy_statistics(self): return self.strategy_statistics
    def setStrategy_statistics(self, strategy_statistics): self.strategy_statistics = strategy_statistics
    def export(self, outfile, level = 0, name_='strategy_response'):
        showIndent(outfile, level)
        outfile.write('<%s>\n' % name_)
        self.exportChildren(outfile, level + 1, name_)
        showIndent(outfile, level)
        outfile.write('</%s>\n' % name_)
    def exportAttributes(self, outfile, level, name_='strategy_response'):
        pass
    def exportChildren(self, outfile, level, name_='strategy_response'):
        if self.status:
            self.status.export(outfile, level)
        if self.completeness:
            self.completeness.export(outfile, level)
        for strategy_summary_ in self.getStrategy_summary():
            strategy_summary_.export(outfile, level)
        for segment_ in self.getSegment():
            segment_.export(outfile, level)
        if self.strategy_interpretation:
            self.strategy_interpretation.export(outfile, level)
        if self.strategy_statistics:
            self.strategy_statistics.export(outfile, level)

    #Only to export the entire XML tree to a file stream on disk
    def outputFile( self, _outfileName ):
        outfile = open( _outfileName, "w" )
        outfile.write("<?xml version=\"1.0\" ?>\n")
        self.export( outfile, 0, name_='strategy_response' )
        outfile.close()


    #Only to export the entire XML tree to a Html Page in a file stream on disk
    def outputPageHtml( self, _outfileName ):
        odtStrTitle = "    <span class=\"title\">strategy_response:</span> <br> <br> <br>\n" 
        outfile = open( _outfileName, "w" )
        outfile.write( TEMPLATE_PAGE_P1 % ( odtStrTitle ) )
        self.exportLiteralHtml( outfile, 0, name_='strategy_response' )
        outfile.write( TEMPLATE_PAGE_P2  )
        outfile.close()


    def outputFileHtml( self, _outfileName ):
        self.outputPageHtml( _outfileName )



    #Static method for parsing a string
    def parseString( _inString ):
        doc = minidom.parseString(_inString)
        rootNode = doc.documentElement
        rootObj = strategy_response.factory()
        rootObj.build(rootNode)
        return rootObj
    parseString = staticmethod( parseString ) 


    #Method for marshalling an object
    def marshal( self ):
        oStreamString = StringIO.StringIO()
        oStreamString.write('<?xml version="1.0" ?>\n')
        self.export( oStreamString, 0, name_="strategy_response" )
        oStringXML = oStreamString.getvalue()
        oStreamString.close()
        return oStringXML

    def exportLiteral(self, outfile, level = 0, name_='strategy_response'):
        level += 1
        self.exportLiteralAttributes(outfile, level, name_)
        self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.status:
            showIndent(outfile, level)
            outfile.write('status = status(\n')
            self.status.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.completeness:
            showIndent(outfile, level)
            outfile.write('completeness = completeness(\n')
            self.completeness.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        showIndent(outfile, level)
        outfile.write('strategy_summary=[\n')
        level += 1
        for strategy_summary in self.strategy_summary:
            showIndent(outfile, level)
            outfile.write('strategy_summary(\n')
            strategy_summary.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('segment=[\n')
        level += 1
        for segment in self.segment:
            showIndent(outfile, level)
            outfile.write('segment(\n')
            segment.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        if self.strategy_interpretation:
            showIndent(outfile, level)
            outfile.write('strategy_interpretation = strategy_interpretation(\n')
            self.strategy_interpretation.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.strategy_statistics:
            showIndent(outfile, level)
            outfile.write('strategy_statistics = strategy_statistics(\n')
            self.strategy_statistics.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
    def exportLiteralHtml(self, outfile, level = 0, name_='strategy_response'):
        level += 1
        self.exportLiteralAttributesHtml(outfile, level, name_)
        self.exportLiteralChildrenHtml(outfile, level, name_)
    def exportLiteralAttributesHtml(self, outfile, level, name_):
        pass
    def exportLiteralChildrenHtml(self, outfile, level, name_):
        if self.status:
            showIndentHtml(outfile, level)
            outfile.write('status<br>\n')
            self.status.exportLiteralHtml(outfile, level)
            showIndentHtml(outfile, level)
            outfile.write('<br>\n')
        if self.completeness:
            showIndentHtml(outfile, level)
            outfile.write('completeness<br>\n')
            self.completeness.exportLiteralHtml(outfile, level)
            showIndentHtml(outfile, level)
            outfile.write('<br>\n')
        showIndentHtml(outfile, level)
        outfile.write('strategy_summary<br>\n')
        level += 1
        for strategy_summary in self.strategy_summary:
            strategy_summary.exportLiteralHtml(outfile, level)
            showIndentHtml(outfile, level)
            outfile.write('<br>\n')
        level -= 1
        showIndentHtml(outfile, level)
        outfile.write('<br>\n')
        showIndentHtml(outfile, level)
        outfile.write('segment<br>\n')
        level += 1
        for segment in self.segment:
            segment.exportLiteralHtml(outfile, level)
            showIndentHtml(outfile, level)
            outfile.write('<br>\n')
        level -= 1
        showIndentHtml(outfile, level)
        outfile.write('<br>\n')
        if self.strategy_interpretation:
            showIndentHtml(outfile, level)
            outfile.write('strategy_interpretation<br>\n')
            self.strategy_interpretation.exportLiteralHtml(outfile, level)
            showIndentHtml(outfile, level)
            outfile.write('<br>\n')
        if self.strategy_statistics:
            showIndentHtml(outfile, level)
            outfile.write('strategy_statistics<br>\n')
            self.strategy_statistics.exportLiteralHtml(outfile, level)
            showIndentHtml(outfile, level)
            outfile.write('<br>\n')
    def build(self, node_):
        attrs = node_.attributes
        self.buildAttributes(attrs)
        for child_ in node_.childNodes:
            nodeName_ = child_.nodeName.split(':')[-1]
            self.buildChildren(child_, nodeName_)
    def buildAttributes(self, attrs):
        pass
    def buildChildren(self, child_, nodeName_):
        if child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'status':
            obj_ = status.factory()
            obj_.build(child_)
            self.setStatus(obj_)
        elif child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'completeness':
            obj_ = completeness.factory()
            obj_.build(child_)
            self.setCompleteness(obj_)
        elif child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'strategy_summary':
            obj_ = strategy_summary.factory()
            obj_.build(child_)
            self.strategy_summary.append(obj_)
        elif child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'segment':
            obj_ = segment.factory()
            obj_.build(child_)
            self.segment.append(obj_)
        elif child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'strategy_interpretation':
            obj_ = strategy_interpretation.factory()
            obj_.build(child_)
            self.setStrategy_interpretation(obj_)
        elif child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'strategy_statistics':
            obj_ = strategy_statistics.factory()
            obj_.build(child_)
            self.setStrategy_statistics(obj_)
# end class strategy_response


class strategy_statistics(object):
    subclass = None
    def __init__(self, r_merge=0.0, i_over_sigma=0.0, overloads=0.0, max_overloads=0.0, multiplicity=0.0, completeness=0.0, resolution=0.0, ranking_resolution=0.0, maximum_exposure=''):
        self.r_merge = r_merge
        self.i_over_sigma = i_over_sigma
        self.overloads = overloads
        self.max_overloads = max_overloads
        self.multiplicity = multiplicity
        self.completeness = completeness
        self.resolution = resolution
        self.ranking_resolution = ranking_resolution
        self.maximum_exposure = maximum_exposure
    def factory(*args_, **kwargs_):
        if strategy_statistics.subclass:
            return strategy_statistics.subclass(*args_, **kwargs_)
        else:
            return strategy_statistics(*args_, **kwargs_)
    factory = staticmethod(factory)
    def getR_merge(self): return self.r_merge
    def setR_merge(self, r_merge): self.r_merge = r_merge
    def getI_over_sigma(self): return self.i_over_sigma
    def setI_over_sigma(self, i_over_sigma): self.i_over_sigma = i_over_sigma
    def getOverloads(self): return self.overloads
    def setOverloads(self, overloads): self.overloads = overloads
    def getMax_overloads(self): return self.max_overloads
    def setMax_overloads(self, max_overloads): self.max_overloads = max_overloads
    def getMultiplicity(self): return self.multiplicity
    def setMultiplicity(self, multiplicity): self.multiplicity = multiplicity
    def getCompleteness(self): return self.completeness
    def setCompleteness(self, completeness): self.completeness = completeness
    def getResolution(self): return self.resolution
    def setResolution(self, resolution): self.resolution = resolution
    def getRanking_resolution(self): return self.ranking_resolution
    def setRanking_resolution(self, ranking_resolution): self.ranking_resolution = ranking_resolution
    def getMaximum_exposure(self): return self.maximum_exposure
    def setMaximum_exposure(self, maximum_exposure): self.maximum_exposure = maximum_exposure
    def export(self, outfile, level = 0, name_='strategy_statistics'):
        showIndent(outfile, level)
        outfile.write('<%s>\n' % name_)
        self.exportChildren(outfile, level + 1, name_)
        showIndent(outfile, level)
        outfile.write('</%s>\n' % name_)
    def exportAttributes(self, outfile, level, name_='strategy_statistics'):
        pass
    def exportChildren(self, outfile, level, name_='strategy_statistics'):
        showIndent(outfile, level)
        outfile.write('<r_merge>%e</r_merge>\n' % self.getR_merge())
        showIndent(outfile, level)
        outfile.write('<i_over_sigma>%e</i_over_sigma>\n' % self.getI_over_sigma())
        showIndent(outfile, level)
        outfile.write('<overloads>%e</overloads>\n' % self.getOverloads())
        showIndent(outfile, level)
        outfile.write('<max_overloads>%e</max_overloads>\n' % self.getMax_overloads())
        showIndent(outfile, level)
        outfile.write('<multiplicity>%e</multiplicity>\n' % self.getMultiplicity())
        showIndent(outfile, level)
        outfile.write('<completeness>%e</completeness>\n' % self.getCompleteness())
        showIndent(outfile, level)
        outfile.write('<resolution>%e</resolution>\n' % self.getResolution())
        showIndent(outfile, level)
        outfile.write('<ranking_resolution>%e</ranking_resolution>\n' % self.getRanking_resolution())
        showIndent(outfile, level)
        outfile.write('<maximum_exposure>%s</maximum_exposure>\n' % quote_xml(self.getMaximum_exposure()))

    #Only to export the entire XML tree to a file stream on disk
    def outputFile( self, _outfileName ):
        outfile = open( _outfileName, "w" )
        outfile.write("<?xml version=\"1.0\" ?>\n")
        self.export( outfile, 0, name_='strategy_statistics' )
        outfile.close()


    #Only to export the entire XML tree to a Html Page in a file stream on disk
    def outputPageHtml( self, _outfileName ):
        odtStrTitle = "    <span class=\"title\">strategy_statistics:</span> <br> <br> <br>\n" 
        outfile = open( _outfileName, "w" )
        outfile.write( TEMPLATE_PAGE_P1 % ( odtStrTitle ) )
        self.exportLiteralHtml( outfile, 0, name_='strategy_statistics' )
        outfile.write( TEMPLATE_PAGE_P2  )
        outfile.close()


    def outputFileHtml( self, _outfileName ):
        self.outputPageHtml( _outfileName )



    #Static method for parsing a string
    def parseString( _inString ):
        doc = minidom.parseString(_inString)
        rootNode = doc.documentElement
        rootObj = strategy_statistics.factory()
        rootObj.build(rootNode)
        return rootObj
    parseString = staticmethod( parseString ) 


    #Method for marshalling an object
    def marshal( self ):
        oStreamString = StringIO.StringIO()
        oStreamString.write('<?xml version="1.0" ?>\n')
        self.export( oStreamString, 0, name_="strategy_statistics" )
        oStringXML = oStreamString.getvalue()
        oStreamString.close()
        return oStringXML

    def exportLiteral(self, outfile, level = 0, name_='strategy_statistics'):
        level += 1
        self.exportLiteralAttributes(outfile, level, name_)
        self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('r_merge = %e,\n' % self.getR_merge())
        showIndent(outfile, level)
        outfile.write('i_over_sigma = %e,\n' % self.getI_over_sigma())
        showIndent(outfile, level)
        outfile.write('overloads = %e,\n' % self.getOverloads())
        showIndent(outfile, level)
        outfile.write('max_overloads = %e,\n' % self.getMax_overloads())
        showIndent(outfile, level)
        outfile.write('multiplicity = %e,\n' % self.getMultiplicity())
        showIndent(outfile, level)
        outfile.write('completeness = %e,\n' % self.getCompleteness())
        showIndent(outfile, level)
        outfile.write('resolution = %e,\n' % self.getResolution())
        showIndent(outfile, level)
        outfile.write('ranking_resolution = %e,\n' % self.getRanking_resolution())
        showIndent(outfile, level)
        outfile.write('maximum_exposure = %s,\n' % quote_python(self.getMaximum_exposure()))
    def exportLiteralHtml(self, outfile, level = 0, name_='strategy_statistics'):
        level += 1
        self.exportLiteralAttributesHtml(outfile, level, name_)
        self.exportLiteralChildrenHtml(outfile, level, name_)
    def exportLiteralAttributesHtml(self, outfile, level, name_):
        pass
    def exportLiteralChildrenHtml(self, outfile, level, name_):
        showIndentHtml(outfile, level)
        outfile.write('r_merge = <a  href:"#">%e</a><br>\n' % self.getR_merge())
        showIndentHtml(outfile, level)
        outfile.write('i_over_sigma = <a  href:"#">%e</a><br>\n' % self.getI_over_sigma())
        showIndentHtml(outfile, level)
        outfile.write('overloads = <a  href:"#">%e</a><br>\n' % self.getOverloads())
        showIndentHtml(outfile, level)
        outfile.write('max_overloads = <a  href:"#">%e</a><br>\n' % self.getMax_overloads())
        showIndentHtml(outfile, level)
        outfile.write('multiplicity = <a  href:"#">%e</a><br>\n' % self.getMultiplicity())
        showIndentHtml(outfile, level)
        outfile.write('completeness = <a  href:"#">%e</a><br>\n' % self.getCompleteness())
        showIndentHtml(outfile, level)
        outfile.write('resolution = <a  href:"#">%e</a><br>\n' % self.getResolution())
        showIndentHtml(outfile, level)
        outfile.write('ranking_resolution = <a  href:"#">%e</a><br>\n' % self.getRanking_resolution())
        showIndentHtml(outfile, level)
        outfile.write('maximum_exposure = <a  href:"#">%s</a><br>\n' % quote_python(self.getMaximum_exposure()))
    def build(self, node_):
        attrs = node_.attributes
        self.buildAttributes(attrs)
        for child_ in node_.childNodes:
            nodeName_ = child_.nodeName.split(':')[-1]
            self.buildChildren(child_, nodeName_)
    def buildAttributes(self, attrs):
        pass
    def buildChildren(self, child_, nodeName_):
        if child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'r_merge':
            if child_.firstChild:
                sval_ = child_.firstChild.nodeValue
                try:
                    fval_ = float(sval_)
                except ValueError:
                    raise ValueError('requires float (or double) -- %s' % child_.toxml())
                self.r_merge = fval_
        elif child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'i_over_sigma':
            if child_.firstChild:
                sval_ = child_.firstChild.nodeValue
                try:
                    fval_ = float(sval_)
                except ValueError:
                    raise ValueError('requires float (or double) -- %s' % child_.toxml())
                self.i_over_sigma = fval_
        elif child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'overloads':
            if child_.firstChild:
                sval_ = child_.firstChild.nodeValue
                try:
                    fval_ = float(sval_)
                except ValueError:
                    raise ValueError('requires float (or double) -- %s' % child_.toxml())
                self.overloads = fval_
        elif child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'max_overloads':
            if child_.firstChild:
                sval_ = child_.firstChild.nodeValue
                try:
                    fval_ = float(sval_)
                except ValueError:
                    raise ValueError('requires float (or double) -- %s' % child_.toxml())
                self.max_overloads = fval_
        elif child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'multiplicity':
            if child_.firstChild:
                sval_ = child_.firstChild.nodeValue
                try:
                    fval_ = float(sval_)
                except ValueError:
                    raise ValueError('requires float (or double) -- %s' % child_.toxml())
                self.multiplicity = fval_
        elif child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'completeness':
            if child_.firstChild:
                sval_ = child_.firstChild.nodeValue
                try:
                    fval_ = float(sval_)
                except ValueError:
                    raise ValueError('requires float (or double) -- %s' % child_.toxml())
                self.completeness = fval_
        elif child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'resolution':
            if child_.firstChild:
                sval_ = child_.firstChild.nodeValue
                try:
                    fval_ = float(sval_)
                except ValueError:
                    raise ValueError('requires float (or double) -- %s' % child_.toxml())
                self.resolution = fval_
        elif child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'ranking_resolution':
            if child_.firstChild:
                sval_ = child_.firstChild.nodeValue
                try:
                    fval_ = float(sval_)
                except ValueError:
                    raise ValueError('requires float (or double) -- %s' % child_.toxml())
                self.ranking_resolution = fval_
        elif child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'maximum_exposure':
            maximum_exposure_ = ''
            for text__content_ in child_.childNodes:
                maximum_exposure_ += text__content_.nodeValue
            self.maximum_exposure = maximum_exposure_
# end class strategy_statistics




def parse(inFileName):
    doc = minidom.parse(inFileName)
    rootNode = doc.documentElement
    rootObj = kappa_alignment.factory()
    rootObj.build(rootNode)
    # Enable Python to collect the space used by the DOM.
    doc.unlink()
#    doc = None
    return rootObj


def parseString(inString):
    doc = minidom.parseString(inString)
    rootNode = doc.documentElement
    rootObj = kappa_alignment.factory()
    rootObj.build(rootNode)
    # Enable Python to collect the space used by the DOM.
    doc.unlink()
#    doc = None
#    sys.stdout.write('<?xml version="1.0" ?>\n')
#    rootObj.export(sys.stdout, 0, name_="kappa_alignment")
    return rootObj


# AAlib Modifications for marshalling and unmarshalling
# Creating program data constructs from XML
def unMarshalling( _inFileName ):
    return parse(  _inFileName )


# Serializing program data constructs to XML
def marshalling( _oObject, _inFileName ):
    oFile = open( _inFileName, "w" )
    oFile.write('<?xml version="1.0" ?>\n')
    _oObject.export( oFile, 0, name_="kappa_alignment" )
    oFile.close()

