#!/usr/bin/env python



#################################################################
#
#   Project:   Python-Jython Asynchronous Action Library Project
#              http://pyaalib.sourceforge.net/
#              http://jyaalib.sourceforge.net/
#
#   Author(s): Romeu A. Pieritz - romeu.pieritz@gmail.com
#
#   Code Generated in Date:      Mon Jun  1 23:18:37 2009
#
#   License:
#   ----------------------------------------------
#   Python-Jython Asynchronous Action Library Project
#   Copyright (c) 2005-2008, PyAALib-JyAALib developers
#   All rights reserved.
#
#   Redistribution and use in source and binary forms,
#   with or without modification, are permitted
#   provided that the following conditions are met:
#
#   Redistributions of source code must retain the
#   above copyright notice,this list of conditions
#   and the following disclaimer.
#
#   Redistributions in binary form must reproduce
#   the above copyright notice,this list of conditions
#   and the following disclaimer in the documentation
#   and/or other materials provided with the distribution.
#
#   Neither the names of PyAALib-JyAALib's copyright owner
#   nor the names of its contributors may be used to endorse
#   or promote products derived from this software without
#   specific prior written permission.
#
#   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS
#   AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED
#   WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
#   IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
#   FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO
#   EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS
#   BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
#   SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
#   (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
#   SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA,
#   OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
#   CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER
#   IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
#   NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT
#   OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
#   THE POSSIBILITY OF SUCH DAMAGE.
#
################################################################
#
#
# Generated by ALExternalPackGenerateDS.py.
#
# This file is generated by a modified version of the original file:
# generateDS.py, proposed by Dave Kuhlman:
#
## LICENSE
#
## Copyright (c) 2003 Dave Kuhlman
#
## Permission is hereby granted, free of charge, to any person obtaining
## a copy of this software and associated documentation files (the
## "Software"), to deal in the Software without restriction, including
## without limitation the rights to use, copy, modify, merge, publish,
## distribute, sublicense, and/or sell copies of the Software, and to
## permit persons to whom the Software is furnished to do so, subject to
## the following conditions:
#
## The above copyright notice and this permission notice shall be
## included in all copies or substantial portions of the Software.
#
## THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
## EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
## MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
## IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
## CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
## TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
## SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
#
##############################################################################

import sys
import getopt
from xml.dom import minidom
from xml.dom import Node


#
# Support/utility functions.
#

def showIndent(outfile, level):
    for idx in range(level):
        outfile.write('    ')


def showIndentHtml(outfile, level):
    for idx in range(level):
        outfile.write(' &nbsp; &nbsp; &nbsp; &nbsp;')


def quote_xml(inStr):
    s1 = inStr
    s1 = s1.replace('&', '&amp;')
    s1 = s1.replace('<', '&lt;')
    s1 = s1.replace('"', '&quot;')
    return s1

def quote_python(inStr):
    s1 = inStr
    if s1.find("'") == -1:
        if s1.find('\n') == -1:
            return "'%s'" % s1
        else:
            return "'''%s'''" % s1
    else:
        if s1.find('"') != -1:
            s1 = s1.replace('"', '\\"')
        if s1.find('\n') == -1:
            return '"%s"' % s1
        else:
            return '"""%s"""' % s1


class MixedContainer(object):
    # Constants for category:
    CategoryNone = 0
    CategoryText = 1
    CategorySimple = 2
    CategoryComplex = 3
    # Constants for content_type:
    TypeNone = 0
    TypeText = 1
    TypeString = 2
    TypeInteger = 3
    TypeFloat = 4
    TypeDecimal = 5
    TypeDouble = 6
    TypeBoolean = 7
    def __init__(self, category, content_type, name, value):
        self.category = category
        self.content_type = content_type
        self.name = name
        self.value = value
    def getCategory(self):
        return self.category
    def getContenttype(self, content_type):
        return self.content_type
    def getValue(self):
        return self.value
    def getName(self):
        return self.name
    def export(self, outfile, level, name):
        if self.category == MixedContainer.CategoryText:
            outfile.write(self.value)
        elif self.category == MixedContainer.CategorySimple:
            self.exportSimple(outfile, level, name)
        else:    # category == MixedContainer.CategoryComplex
            self.value.export(outfile, level, name)
    def exportSimple(self, outfile, level, name):
        if self.content_type == MixedContainer.TypeString:
            outfile.write('<%s>%s</%s>' % (self.name, self.value, self.name))
        elif self.content_type == MixedContainer.TypeInteger or \
                self.content_type == MixedContainer.TypeBoolean:
            outfile.write('<%s>%d</%s>' % (self.name, self.value, self.name))
        elif self.content_type == MixedContainer.TypeFloat or \
                self.content_type == MixedContainer.TypeDecimal:
            outfile.write('<%s>%f</%s>' % (self.name, self.value, self.name))
        elif self.content_type == MixedContainer.TypeDouble:
            outfile.write('<%s>%g</%s>' % (self.name, self.value, self.name))
    def exportLiteral(self, outfile, level, name):
        if self.category == MixedContainer.CategoryText:
            showIndent(outfile, level)
            outfile.write('MixedContainer(%d, %d, "%s", "%s"),\n' % \
                (self.category, self.content_type, self.name, self.value))
        elif self.category == MixedContainer.CategorySimple:
            showIndent(outfile, level)
            outfile.write('MixedContainer(%d, %d, "%s", "%s"),\n' % \
                (self.category, self.content_type, self.name, self.value))
        else:    # category == MixedContainer.CategoryComplex
            showIndent(outfile, level)
            outfile.write('MixedContainer(%d, %d, "%s",\n' % \
                (self.category, self.content_type, self.name,))
            self.value.exportLiteral(outfile, level + 1)
            showIndent(outfile, level)
            outfile.write(')\n')



TEMPLATE_PAGE_P1 = """
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN" "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en">
<head>
    <title>AALib Plugin Data Description</title>
    <meta http-equiv="content-type" content="text/html; charset=utf-8">
    <meta name="description" content="AALib Plugin generation from XSD files">
    <meta name="keywords" content="AALib, xsd, plugin">
    <meta name="author" content="Romeu Pieritz(romeu_pieritz@yahoo.fr)">
    <link href="style.css" rel="stylesheet" type="text/css">
    <base target="main">
</head>
<body>
    <div id="main">
        <div id="block">
          %s
    </div>
"""

TEMPLATE_PAGE_P2 = """
    </div>
</body>
</html>
"""



#
# Class definition
#

class system_defaults(object):
    subclass = None
    def __init__(self, server_data=None, local_info=None):
        self.server_data = server_data
        self.local_info = local_info
    def factory(*args_, **kwargs_):
        if system_defaults.subclass:
            return system_defaults.subclass(*args_, **kwargs_)
        else:
            return system_defaults(*args_, **kwargs_)
    factory = staticmethod(factory)
    def getServer_data(self): return self.server_data
    def setServer_data(self, server_data): self.server_data = server_data
    def getLocal_info(self): return self.local_info
    def setLocal_info(self, local_info): self.local_info = local_info
    def export(self, outfile, level = 0, name_='system_defaults'):
        showIndent(outfile, level)
        outfile.write('<%s>\n' % name_)
        self.exportChildren(outfile, level + 1, name_)
        showIndent(outfile, level)
        outfile.write('</%s>\n' % name_)
    def exportAttributes(self, outfile, level, name_='system_defaults'):
        pass
    def exportChildren(self, outfile, level, name_='system_defaults'):
        if self.server_data:
            self.server_data.export(outfile, level)
        if self.local_info:
            self.local_info.export(outfile, level)

    #Only to export the entire XML tree to a file stream on disk
    def outputFile( self, _outfileName ):
        outfile = open( _outfileName, "w" )
        outfile.write("<?xml version=\"1.0\" ?>\n")
        self.export( outfile, 0, name_='system_defaults' )
        outfile.close()


    #Only to export the entire XML tree to a Html Page in a file stream on disk
    def outputPageHtml( self, _outfileName ):
        odtStrTitle = "    <span class=\"title\">system_defaults:</span> <br> <br> <br>\n" 
        outfile = open( _outfileName, "w" )
        outfile.write( TEMPLATE_PAGE_P1 % ( odtStrTitle ) )
        self.exportLiteralHtml( outfile, 0, name_='system_defaults' )
        outfile.write( TEMPLATE_PAGE_P2  )
        outfile.close()


    def outputFileHtml( self, _outfileName ):
        self.outputPageHtml( _outfileName )



    #Static method for parsing a string
    def parseString( _inString ):
        doc = minidom.parseString(_inString)
        rootNode = doc.documentElement
        rootObj = system_defaults.factory()
        rootObj.build(rootNode)
        return rootObj
    parseString = staticmethod( parseString ) 


    #Method for marshalling an object
    def marshal( self ):
        oStreamString = StringIO.StringIO()
        oStreamString.write('<?xml version="1.0" ?>\n')
        self.export( oStreamString, 0, name_="system_defaults" )
        oStringXML = oStreamString.getvalue()
        oStreamString.close()
        return oStringXML

    def exportLiteral(self, outfile, level = 0, name_='system_defaults'):
        level += 1
        self.exportLiteralAttributes(outfile, level, name_)
        self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.server_data:
            showIndent(outfile, level)
            outfile.write('server_data = server_data(\n')
            self.server_data.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.local_info:
            showIndent(outfile, level)
            outfile.write('local_info = local_info(\n')
            self.local_info.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
    def exportLiteralHtml(self, outfile, level = 0, name_='system_defaults'):
        level += 1
        self.exportLiteralAttributesHtml(outfile, level, name_)
        self.exportLiteralChildrenHtml(outfile, level, name_)
    def exportLiteralAttributesHtml(self, outfile, level, name_):
        pass
    def exportLiteralChildrenHtml(self, outfile, level, name_):
        if self.server_data:
            showIndentHtml(outfile, level)
            outfile.write('server_data<br>\n')
            self.server_data.exportLiteralHtml(outfile, level)
            showIndentHtml(outfile, level)
            outfile.write('<br>\n')
        if self.local_info:
            showIndentHtml(outfile, level)
            outfile.write('local_info<br>\n')
            self.local_info.exportLiteralHtml(outfile, level)
            showIndentHtml(outfile, level)
            outfile.write('<br>\n')
    def build(self, node_):
        attrs = node_.attributes
        self.buildAttributes(attrs)
        for child_ in node_.childNodes:
            nodeName_ = child_.nodeName.split(':')[-1]
            self.buildChildren(child_, nodeName_)
    def buildAttributes(self, attrs):
        pass
    def buildChildren(self, child_, nodeName_):
        if child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'server_data':
            obj_ = server_data.factory()
            obj_.build(child_)
            self.setServer_data(obj_)
        elif child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'local_info':
            obj_ = local_info.factory()
            obj_.build(child_)
            self.setLocal_info(obj_)
# end class system_defaults


class user_defaults(object):
    subclass = None
    def __init__(self, default_values=None, index_parameters=None, integrate_parameters=None, strategy_parameters=None, rank_parameters=None, server_data=None):
        self.default_values = default_values
        self.index_parameters = index_parameters
        self.integrate_parameters = integrate_parameters
        self.strategy_parameters = strategy_parameters
        self.rank_parameters = rank_parameters
        self.server_data = server_data
    def factory(*args_, **kwargs_):
        if user_defaults.subclass:
            return user_defaults.subclass(*args_, **kwargs_)
        else:
            return user_defaults(*args_, **kwargs_)
    factory = staticmethod(factory)
    def getDefault_values(self): return self.default_values
    def setDefault_values(self, default_values): self.default_values = default_values
    def getIndex_parameters(self): return self.index_parameters
    def setIndex_parameters(self, index_parameters): self.index_parameters = index_parameters
    def getIntegrate_parameters(self): return self.integrate_parameters
    def setIntegrate_parameters(self, integrate_parameters): self.integrate_parameters = integrate_parameters
    def getStrategy_parameters(self): return self.strategy_parameters
    def setStrategy_parameters(self, strategy_parameters): self.strategy_parameters = strategy_parameters
    def getRank_parameters(self): return self.rank_parameters
    def setRank_parameters(self, rank_parameters): self.rank_parameters = rank_parameters
    def getServer_data(self): return self.server_data
    def setServer_data(self, server_data): self.server_data = server_data
    def export(self, outfile, level = 0, name_='user_defaults'):
        showIndent(outfile, level)
        outfile.write('<%s>\n' % name_)
        self.exportChildren(outfile, level + 1, name_)
        showIndent(outfile, level)
        outfile.write('</%s>\n' % name_)
    def exportAttributes(self, outfile, level, name_='user_defaults'):
        pass
    def exportChildren(self, outfile, level, name_='user_defaults'):
        if self.default_values:
            self.default_values.export(outfile, level)
        if self.index_parameters:
            self.index_parameters.export(outfile, level)
        if self.integrate_parameters:
            self.integrate_parameters.export(outfile, level)
        if self.strategy_parameters:
            self.strategy_parameters.export(outfile, level)
        if self.rank_parameters:
            self.rank_parameters.export(outfile, level)
        if self.server_data:
            self.server_data.export(outfile, level)

    #Only to export the entire XML tree to a file stream on disk
    def outputFile( self, _outfileName ):
        outfile = open( _outfileName, "w" )
        outfile.write("<?xml version=\"1.0\" ?>\n")
        self.export( outfile, 0, name_='user_defaults' )
        outfile.close()


    #Only to export the entire XML tree to a Html Page in a file stream on disk
    def outputPageHtml( self, _outfileName ):
        odtStrTitle = "    <span class=\"title\">user_defaults:</span> <br> <br> <br>\n" 
        outfile = open( _outfileName, "w" )
        outfile.write( TEMPLATE_PAGE_P1 % ( odtStrTitle ) )
        self.exportLiteralHtml( outfile, 0, name_='user_defaults' )
        outfile.write( TEMPLATE_PAGE_P2  )
        outfile.close()


    def outputFileHtml( self, _outfileName ):
        self.outputPageHtml( _outfileName )



    #Static method for parsing a string
    def parseString( _inString ):
        doc = minidom.parseString(_inString)
        rootNode = doc.documentElement
        rootObj = user_defaults.factory()
        rootObj.build(rootNode)
        return rootObj
    parseString = staticmethod( parseString ) 


    #Method for marshalling an object
    def marshal( self ):
        oStreamString = StringIO.StringIO()
        oStreamString.write('<?xml version="1.0" ?>\n')
        self.export( oStreamString, 0, name_="user_defaults" )
        oStringXML = oStreamString.getvalue()
        oStreamString.close()
        return oStringXML

    def exportLiteral(self, outfile, level = 0, name_='user_defaults'):
        level += 1
        self.exportLiteralAttributes(outfile, level, name_)
        self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.default_values:
            showIndent(outfile, level)
            outfile.write('default_values = default_values(\n')
            self.default_values.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.index_parameters:
            showIndent(outfile, level)
            outfile.write('index_parameters = index_parameters(\n')
            self.index_parameters.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.integrate_parameters:
            showIndent(outfile, level)
            outfile.write('integrate_parameters = integrate_parameters(\n')
            self.integrate_parameters.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.strategy_parameters:
            showIndent(outfile, level)
            outfile.write('strategy_parameters = strategy_parameters(\n')
            self.strategy_parameters.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.rank_parameters:
            showIndent(outfile, level)
            outfile.write('rank_parameters = rank_parameters(\n')
            self.rank_parameters.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.server_data:
            showIndent(outfile, level)
            outfile.write('server_data = server_data(\n')
            self.server_data.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
    def exportLiteralHtml(self, outfile, level = 0, name_='user_defaults'):
        level += 1
        self.exportLiteralAttributesHtml(outfile, level, name_)
        self.exportLiteralChildrenHtml(outfile, level, name_)
    def exportLiteralAttributesHtml(self, outfile, level, name_):
        pass
    def exportLiteralChildrenHtml(self, outfile, level, name_):
        if self.default_values:
            showIndentHtml(outfile, level)
            outfile.write('default_values<br>\n')
            self.default_values.exportLiteralHtml(outfile, level)
            showIndentHtml(outfile, level)
            outfile.write('<br>\n')
        if self.index_parameters:
            showIndentHtml(outfile, level)
            outfile.write('index_parameters<br>\n')
            self.index_parameters.exportLiteralHtml(outfile, level)
            showIndentHtml(outfile, level)
            outfile.write('<br>\n')
        if self.integrate_parameters:
            showIndentHtml(outfile, level)
            outfile.write('integrate_parameters<br>\n')
            self.integrate_parameters.exportLiteralHtml(outfile, level)
            showIndentHtml(outfile, level)
            outfile.write('<br>\n')
        if self.strategy_parameters:
            showIndentHtml(outfile, level)
            outfile.write('strategy_parameters<br>\n')
            self.strategy_parameters.exportLiteralHtml(outfile, level)
            showIndentHtml(outfile, level)
            outfile.write('<br>\n')
        if self.rank_parameters:
            showIndentHtml(outfile, level)
            outfile.write('rank_parameters<br>\n')
            self.rank_parameters.exportLiteralHtml(outfile, level)
            showIndentHtml(outfile, level)
            outfile.write('<br>\n')
        if self.server_data:
            showIndentHtml(outfile, level)
            outfile.write('server_data<br>\n')
            self.server_data.exportLiteralHtml(outfile, level)
            showIndentHtml(outfile, level)
            outfile.write('<br>\n')
    def build(self, node_):
        attrs = node_.attributes
        self.buildAttributes(attrs)
        for child_ in node_.childNodes:
            nodeName_ = child_.nodeName.split(':')[-1]
            self.buildChildren(child_, nodeName_)
    def buildAttributes(self, attrs):
        pass
    def buildChildren(self, child_, nodeName_):
        if child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'default_values':
            obj_ = default_values.factory()
            obj_.build(child_)
            self.setDefault_values(obj_)
        elif child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'index_parameters':
            obj_ = index_parameters.factory()
            obj_.build(child_)
            self.setIndex_parameters(obj_)
        elif child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'integrate_parameters':
            obj_ = integrate_parameters.factory()
            obj_.build(child_)
            self.setIntegrate_parameters(obj_)
        elif child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'strategy_parameters':
            obj_ = strategy_parameters.factory()
            obj_.build(child_)
            self.setStrategy_parameters(obj_)
        elif child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'rank_parameters':
            obj_ = rank_parameters.factory()
            obj_.build(child_)
            self.setRank_parameters(obj_)
        elif child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'server_data':
            obj_ = server_data.factory()
            obj_.build(child_)
            self.setServer_data(obj_)
# end class user_defaults


class dna_configuration(object):
    subclass = None
    def __init__(self, server_data=None, local_info=None, default_values=None, index_parameters=None):
        self.server_data = server_data
        self.local_info = local_info
        self.default_values = default_values
        self.index_parameters = index_parameters
    def factory(*args_, **kwargs_):
        if dna_configuration.subclass:
            return dna_configuration.subclass(*args_, **kwargs_)
        else:
            return dna_configuration(*args_, **kwargs_)
    factory = staticmethod(factory)
    def getServer_data(self): return self.server_data
    def setServer_data(self, server_data): self.server_data = server_data
    def getLocal_info(self): return self.local_info
    def setLocal_info(self, local_info): self.local_info = local_info
    def getDefault_values(self): return self.default_values
    def setDefault_values(self, default_values): self.default_values = default_values
    def getIndex_parameters(self): return self.index_parameters
    def setIndex_parameters(self, index_parameters): self.index_parameters = index_parameters
    def export(self, outfile, level = 0, name_='dna_configuration'):
        showIndent(outfile, level)
        outfile.write('<%s>\n' % name_)
        self.exportChildren(outfile, level + 1, name_)
        showIndent(outfile, level)
        outfile.write('</%s>\n' % name_)
    def exportAttributes(self, outfile, level, name_='dna_configuration'):
        pass
    def exportChildren(self, outfile, level, name_='dna_configuration'):
        if self.server_data:
            self.server_data.export(outfile, level)
        if self.local_info:
            self.local_info.export(outfile, level)
        if self.default_values:
            self.default_values.export(outfile, level)
        if self.index_parameters:
            self.index_parameters.export(outfile, level)

    #Only to export the entire XML tree to a file stream on disk
    def outputFile( self, _outfileName ):
        outfile = open( _outfileName, "w" )
        outfile.write("<?xml version=\"1.0\" ?>\n")
        self.export( outfile, 0, name_='dna_configuration' )
        outfile.close()


    #Only to export the entire XML tree to a Html Page in a file stream on disk
    def outputPageHtml( self, _outfileName ):
        odtStrTitle = "    <span class=\"title\">dna_configuration:</span> <br> <br> <br>\n" 
        outfile = open( _outfileName, "w" )
        outfile.write( TEMPLATE_PAGE_P1 % ( odtStrTitle ) )
        self.exportLiteralHtml( outfile, 0, name_='dna_configuration' )
        outfile.write( TEMPLATE_PAGE_P2  )
        outfile.close()


    def outputFileHtml( self, _outfileName ):
        self.outputPageHtml( _outfileName )



    #Static method for parsing a string
    def parseString( _inString ):
        doc = minidom.parseString(_inString)
        rootNode = doc.documentElement
        rootObj = dna_configuration.factory()
        rootObj.build(rootNode)
        return rootObj
    parseString = staticmethod( parseString ) 


    #Method for marshalling an object
    def marshal( self ):
        oStreamString = StringIO.StringIO()
        oStreamString.write('<?xml version="1.0" ?>\n')
        self.export( oStreamString, 0, name_="dna_configuration" )
        oStringXML = oStreamString.getvalue()
        oStreamString.close()
        return oStringXML

    def exportLiteral(self, outfile, level = 0, name_='dna_configuration'):
        level += 1
        self.exportLiteralAttributes(outfile, level, name_)
        self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.server_data:
            showIndent(outfile, level)
            outfile.write('server_data = server_data(\n')
            self.server_data.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.local_info:
            showIndent(outfile, level)
            outfile.write('local_info = local_info(\n')
            self.local_info.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.default_values:
            showIndent(outfile, level)
            outfile.write('default_values = default_values(\n')
            self.default_values.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.index_parameters:
            showIndent(outfile, level)
            outfile.write('index_parameters = index_parameters(\n')
            self.index_parameters.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
    def exportLiteralHtml(self, outfile, level = 0, name_='dna_configuration'):
        level += 1
        self.exportLiteralAttributesHtml(outfile, level, name_)
        self.exportLiteralChildrenHtml(outfile, level, name_)
    def exportLiteralAttributesHtml(self, outfile, level, name_):
        pass
    def exportLiteralChildrenHtml(self, outfile, level, name_):
        if self.server_data:
            showIndentHtml(outfile, level)
            outfile.write('server_data<br>\n')
            self.server_data.exportLiteralHtml(outfile, level)
            showIndentHtml(outfile, level)
            outfile.write('<br>\n')
        if self.local_info:
            showIndentHtml(outfile, level)
            outfile.write('local_info<br>\n')
            self.local_info.exportLiteralHtml(outfile, level)
            showIndentHtml(outfile, level)
            outfile.write('<br>\n')
        if self.default_values:
            showIndentHtml(outfile, level)
            outfile.write('default_values<br>\n')
            self.default_values.exportLiteralHtml(outfile, level)
            showIndentHtml(outfile, level)
            outfile.write('<br>\n')
        if self.index_parameters:
            showIndentHtml(outfile, level)
            outfile.write('index_parameters<br>\n')
            self.index_parameters.exportLiteralHtml(outfile, level)
            showIndentHtml(outfile, level)
            outfile.write('<br>\n')
    def build(self, node_):
        attrs = node_.attributes
        self.buildAttributes(attrs)
        for child_ in node_.childNodes:
            nodeName_ = child_.nodeName.split(':')[-1]
            self.buildChildren(child_, nodeName_)
    def buildAttributes(self, attrs):
        pass
    def buildChildren(self, child_, nodeName_):
        if child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'server_data':
            obj_ = server_data.factory()
            obj_.build(child_)
            self.setServer_data(obj_)
        elif child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'local_info':
            obj_ = local_info.factory()
            obj_.build(child_)
            self.setLocal_info(obj_)
        elif child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'default_values':
            obj_ = default_values.factory()
            obj_.build(child_)
            self.setDefault_values(obj_)
        elif child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'index_parameters':
            obj_ = index_parameters.factory()
            obj_.build(child_)
            self.setIndex_parameters(obj_)
# end class dna_configuration


class local_info(object):
    subclass = None
    def __init__(self, detector=None, bcm_name='', bcm_connection_timeout='', login_required=False, archive_directory='', dna_contact_email='', max_exposure_time_before_radiation_damage='', bcm_synchronise_archive_available=False, I_over_sigma=0.0):
        self.detector = detector
        self.bcm_name = bcm_name
        self.bcm_connection_timeout = bcm_connection_timeout
        self.login_required = login_required
        self.archive_directory = archive_directory
        self.dna_contact_email = dna_contact_email
        self.max_exposure_time_before_radiation_damage = max_exposure_time_before_radiation_damage
        self.bcm_synchronise_archive_available = bcm_synchronise_archive_available
        self.I_over_sigma = I_over_sigma
    def factory(*args_, **kwargs_):
        if local_info.subclass:
            return local_info.subclass(*args_, **kwargs_)
        else:
            return local_info(*args_, **kwargs_)
    factory = staticmethod(factory)
    def getDetector(self): return self.detector
    def setDetector(self, detector): self.detector = detector
    def getBcm_name(self): return self.bcm_name
    def setBcm_name(self, bcm_name): self.bcm_name = bcm_name
    def getBcm_connection_timeout(self): return self.bcm_connection_timeout
    def setBcm_connection_timeout(self, bcm_connection_timeout): self.bcm_connection_timeout = bcm_connection_timeout
    def getLogin_required(self): return self.login_required
    def setLogin_required(self, login_required): self.login_required = login_required
    def getArchive_directory(self): return self.archive_directory
    def setArchive_directory(self, archive_directory): self.archive_directory = archive_directory
    def getDna_contact_email(self): return self.dna_contact_email
    def setDna_contact_email(self, dna_contact_email): self.dna_contact_email = dna_contact_email
    def getMax_exposure_time_before_radiation_damage(self): return self.max_exposure_time_before_radiation_damage
    def setMax_exposure_time_before_radiation_damage(self, max_exposure_time_before_radiation_damage): self.max_exposure_time_before_radiation_damage = max_exposure_time_before_radiation_damage
    def getBcm_synchronise_archive_available(self): return self.bcm_synchronise_archive_available
    def setBcm_synchronise_archive_available(self, bcm_synchronise_archive_available): self.bcm_synchronise_archive_available = bcm_synchronise_archive_available
    def getI_over_sigma(self): return self.I_over_sigma
    def setI_over_sigma(self, I_over_sigma): self.I_over_sigma = I_over_sigma
    def export(self, outfile, level = 0, name_='local_info'):
        showIndent(outfile, level)
        outfile.write('<%s>\n' % name_)
        self.exportChildren(outfile, level + 1, name_)
        showIndent(outfile, level)
        outfile.write('</%s>\n' % name_)
    def exportAttributes(self, outfile, level, name_='local_info'):
        pass
    def exportChildren(self, outfile, level, name_='local_info'):
        if self.detector:
            self.detector.export(outfile, level)
        showIndent(outfile, level)
        outfile.write('<bcm_name>%s</bcm_name>\n' % quote_xml(self.getBcm_name()))
        showIndent(outfile, level)
        outfile.write('<bcm_connection_timeout>%s</bcm_connection_timeout>\n' % quote_xml(self.getBcm_connection_timeout()))
        showIndent(outfile, level)
        outfile.write('<login_required>%s</login_required>\n' % self.getLogin_required())
        showIndent(outfile, level)
        outfile.write('<archive_directory>%s</archive_directory>\n' % quote_xml(self.getArchive_directory()))
        showIndent(outfile, level)
        outfile.write('<dna_contact_email>%s</dna_contact_email>\n' % quote_xml(self.getDna_contact_email()))
        showIndent(outfile, level)
        outfile.write('<max_exposure_time_before_radiation_damage>%s</max_exposure_time_before_radiation_damage>\n' % quote_xml(self.getMax_exposure_time_before_radiation_damage()))
        showIndent(outfile, level)
        outfile.write('<bcm_synchronise_archive_available>%s</bcm_synchronise_archive_available>\n' % self.getBcm_synchronise_archive_available())
        showIndent(outfile, level)
        outfile.write('<I_over_sigma>%e</I_over_sigma>\n' % self.getI_over_sigma())

    #Only to export the entire XML tree to a file stream on disk
    def outputFile( self, _outfileName ):
        outfile = open( _outfileName, "w" )
        outfile.write("<?xml version=\"1.0\" ?>\n")
        self.export( outfile, 0, name_='local_info' )
        outfile.close()


    #Only to export the entire XML tree to a Html Page in a file stream on disk
    def outputPageHtml( self, _outfileName ):
        odtStrTitle = "    <span class=\"title\">local_info:</span> <br> <br> <br>\n" 
        outfile = open( _outfileName, "w" )
        outfile.write( TEMPLATE_PAGE_P1 % ( odtStrTitle ) )
        self.exportLiteralHtml( outfile, 0, name_='local_info' )
        outfile.write( TEMPLATE_PAGE_P2  )
        outfile.close()


    def outputFileHtml( self, _outfileName ):
        self.outputPageHtml( _outfileName )



    #Static method for parsing a string
    def parseString( _inString ):
        doc = minidom.parseString(_inString)
        rootNode = doc.documentElement
        rootObj = local_info.factory()
        rootObj.build(rootNode)
        return rootObj
    parseString = staticmethod( parseString ) 


    #Method for marshalling an object
    def marshal( self ):
        oStreamString = StringIO.StringIO()
        oStreamString.write('<?xml version="1.0" ?>\n')
        self.export( oStreamString, 0, name_="local_info" )
        oStringXML = oStreamString.getvalue()
        oStreamString.close()
        return oStringXML

    def exportLiteral(self, outfile, level = 0, name_='local_info'):
        level += 1
        self.exportLiteralAttributes(outfile, level, name_)
        self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.detector:
            showIndent(outfile, level)
            outfile.write('detector = detector(\n')
            self.detector.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        showIndent(outfile, level)
        outfile.write('bcm_name = %s,\n' % quote_python(self.getBcm_name()))
        showIndent(outfile, level)
        outfile.write('bcm_connection_timeout = %s,\n' % quote_python(self.getBcm_connection_timeout()))
        showIndent(outfile, level)
        outfile.write('login_required = %s,\n' % self.getLogin_required())
        showIndent(outfile, level)
        outfile.write('archive_directory = %s,\n' % quote_python(self.getArchive_directory()))
        showIndent(outfile, level)
        outfile.write('dna_contact_email = %s,\n' % quote_python(self.getDna_contact_email()))
        showIndent(outfile, level)
        outfile.write('max_exposure_time_before_radiation_damage = %s,\n' % quote_python(self.getMax_exposure_time_before_radiation_damage()))
        showIndent(outfile, level)
        outfile.write('bcm_synchronise_archive_available = %s,\n' % self.getBcm_synchronise_archive_available())
        showIndent(outfile, level)
        outfile.write('I_over_sigma = %e,\n' % self.getI_over_sigma())
    def exportLiteralHtml(self, outfile, level = 0, name_='local_info'):
        level += 1
        self.exportLiteralAttributesHtml(outfile, level, name_)
        self.exportLiteralChildrenHtml(outfile, level, name_)
    def exportLiteralAttributesHtml(self, outfile, level, name_):
        pass
    def exportLiteralChildrenHtml(self, outfile, level, name_):
        if self.detector:
            showIndentHtml(outfile, level)
            outfile.write('detector<br>\n')
            self.detector.exportLiteralHtml(outfile, level)
            showIndentHtml(outfile, level)
            outfile.write('<br>\n')
        showIndentHtml(outfile, level)
        outfile.write('bcm_name = <a  href:"#">%s</a><br>\n' % quote_python(self.getBcm_name()))
        showIndentHtml(outfile, level)
        outfile.write('bcm_connection_timeout = <a  href:"#">%s</a><br>\n' % quote_python(self.getBcm_connection_timeout()))
        showIndentHtml(outfile, level)
        outfile.write('login_required = <a  href:"#">%s</a><br>\n' % self.getLogin_required())
        showIndentHtml(outfile, level)
        outfile.write('archive_directory = <a  href:"#">%s</a><br>\n' % quote_python(self.getArchive_directory()))
        showIndentHtml(outfile, level)
        outfile.write('dna_contact_email = <a  href:"#">%s</a><br>\n' % quote_python(self.getDna_contact_email()))
        showIndentHtml(outfile, level)
        outfile.write('max_exposure_time_before_radiation_damage = <a  href:"#">%s</a><br>\n' % quote_python(self.getMax_exposure_time_before_radiation_damage()))
        showIndentHtml(outfile, level)
        outfile.write('bcm_synchronise_archive_available = <a  href:"#">%s</a><br>\n' % self.getBcm_synchronise_archive_available())
        showIndentHtml(outfile, level)
        outfile.write('I_over_sigma = <a  href:"#">%e</a><br>\n' % self.getI_over_sigma())
    def build(self, node_):
        attrs = node_.attributes
        self.buildAttributes(attrs)
        for child_ in node_.childNodes:
            nodeName_ = child_.nodeName.split(':')[-1]
            self.buildChildren(child_, nodeName_)
    def buildAttributes(self, attrs):
        pass
    def buildChildren(self, child_, nodeName_):
        if child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'detector':
            obj_ = detector.factory()
            obj_.build(child_)
            self.setDetector(obj_)
        elif child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'bcm_name':
            bcm_name_ = ''
            for text__content_ in child_.childNodes:
                bcm_name_ += text__content_.nodeValue
            self.bcm_name = bcm_name_
        elif child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'bcm_connection_timeout':
            bcm_connection_timeout_ = ''
            for text__content_ in child_.childNodes:
                bcm_connection_timeout_ += text__content_.nodeValue
            self.bcm_connection_timeout = bcm_connection_timeout_
        elif child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'login_required':
            if child_.firstChild:
                sval_ = child_.firstChild.nodeValue
                if sval_ in ('true', 'True', '1'):
                    ival_ = True
                elif sval_ in ('false', 'False', '0'):
                    ival_ = False
                else:
                    raise ValueError('requires boolean -- %s' % child_.toxml())
                self.login_required = ival_
        elif child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'archive_directory':
            archive_directory_ = ''
            for text__content_ in child_.childNodes:
                archive_directory_ += text__content_.nodeValue
            self.archive_directory = archive_directory_
        elif child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'dna_contact_email':
            dna_contact_email_ = ''
            for text__content_ in child_.childNodes:
                dna_contact_email_ += text__content_.nodeValue
            self.dna_contact_email = dna_contact_email_
        elif child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'max_exposure_time_before_radiation_damage':
            max_exposure_time_before_radiation_damage_ = ''
            for text__content_ in child_.childNodes:
                max_exposure_time_before_radiation_damage_ += text__content_.nodeValue
            self.max_exposure_time_before_radiation_damage = max_exposure_time_before_radiation_damage_
        elif child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'bcm_synchronise_archive_available':
            if child_.firstChild:
                sval_ = child_.firstChild.nodeValue
                if sval_ in ('true', 'True', '1'):
                    ival_ = True
                elif sval_ in ('false', 'False', '0'):
                    ival_ = False
                else:
                    raise ValueError('requires boolean -- %s' % child_.toxml())
                self.bcm_synchronise_archive_available = ival_
        elif child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'I_over_sigma':
            if child_.firstChild:
                sval_ = child_.firstChild.nodeValue
                try:
                    fval_ = float(sval_)
                except ValueError:
                    raise ValueError('requires float (or double) -- %s' % child_.toxml())
                self.I_over_sigma = fval_
# end class local_info


class index_parameters(object):
    subclass = None
    def __init__(self, extra_index_commands=None, warning_index_spot_rms_error=0.0, max_index_spot_rms_error=0.0, warning_beam_shift=0.0, max_beam_shift=0.0, warning_index_spot_frac_rejected=0.0, max_index_spot_frac_rejected=0.0, min_threshold_I_sigma=0.0):
        self.extra_index_commands = extra_index_commands
        self.warning_index_spot_rms_error = warning_index_spot_rms_error
        self.max_index_spot_rms_error = max_index_spot_rms_error
        self.warning_beam_shift = warning_beam_shift
        self.max_beam_shift = max_beam_shift
        self.warning_index_spot_frac_rejected = warning_index_spot_frac_rejected
        self.max_index_spot_frac_rejected = max_index_spot_frac_rejected
        self.min_threshold_I_sigma = min_threshold_I_sigma
    def factory(*args_, **kwargs_):
        if index_parameters.subclass:
            return index_parameters.subclass(*args_, **kwargs_)
        else:
            return index_parameters(*args_, **kwargs_)
    factory = staticmethod(factory)
    def getExtra_index_commands(self): return self.extra_index_commands
    def setExtra_index_commands(self, extra_index_commands): self.extra_index_commands = extra_index_commands
    def getWarning_index_spot_rms_error(self): return self.warning_index_spot_rms_error
    def setWarning_index_spot_rms_error(self, warning_index_spot_rms_error): self.warning_index_spot_rms_error = warning_index_spot_rms_error
    def getMax_index_spot_rms_error(self): return self.max_index_spot_rms_error
    def setMax_index_spot_rms_error(self, max_index_spot_rms_error): self.max_index_spot_rms_error = max_index_spot_rms_error
    def getWarning_beam_shift(self): return self.warning_beam_shift
    def setWarning_beam_shift(self, warning_beam_shift): self.warning_beam_shift = warning_beam_shift
    def getMax_beam_shift(self): return self.max_beam_shift
    def setMax_beam_shift(self, max_beam_shift): self.max_beam_shift = max_beam_shift
    def getWarning_index_spot_frac_rejected(self): return self.warning_index_spot_frac_rejected
    def setWarning_index_spot_frac_rejected(self, warning_index_spot_frac_rejected): self.warning_index_spot_frac_rejected = warning_index_spot_frac_rejected
    def getMax_index_spot_frac_rejected(self): return self.max_index_spot_frac_rejected
    def setMax_index_spot_frac_rejected(self, max_index_spot_frac_rejected): self.max_index_spot_frac_rejected = max_index_spot_frac_rejected
    def getMin_threshold_I_sigma(self): return self.min_threshold_I_sigma
    def setMin_threshold_I_sigma(self, min_threshold_I_sigma): self.min_threshold_I_sigma = min_threshold_I_sigma
    def export(self, outfile, level = 0, name_='index_parameters'):
        showIndent(outfile, level)
        outfile.write('<%s>\n' % name_)
        self.exportChildren(outfile, level + 1, name_)
        showIndent(outfile, level)
        outfile.write('</%s>\n' % name_)
    def exportAttributes(self, outfile, level, name_='index_parameters'):
        pass
    def exportChildren(self, outfile, level, name_='index_parameters'):
        if self.extra_index_commands:
            self.extra_index_commands.export(outfile, level, name_='extra_index_commands')
        showIndent(outfile, level)
        outfile.write('<warning_index_spot_rms_error>%e</warning_index_spot_rms_error>\n' % self.getWarning_index_spot_rms_error())
        showIndent(outfile, level)
        outfile.write('<max_index_spot_rms_error>%e</max_index_spot_rms_error>\n' % self.getMax_index_spot_rms_error())
        showIndent(outfile, level)
        outfile.write('<warning_beam_shift>%e</warning_beam_shift>\n' % self.getWarning_beam_shift())
        showIndent(outfile, level)
        outfile.write('<max_beam_shift>%e</max_beam_shift>\n' % self.getMax_beam_shift())
        showIndent(outfile, level)
        outfile.write('<warning_index_spot_frac_rejected>%e</warning_index_spot_frac_rejected>\n' % self.getWarning_index_spot_frac_rejected())
        showIndent(outfile, level)
        outfile.write('<max_index_spot_frac_rejected>%e</max_index_spot_frac_rejected>\n' % self.getMax_index_spot_frac_rejected())
        showIndent(outfile, level)
        outfile.write('<min_threshold_I_sigma>%e</min_threshold_I_sigma>\n' % self.getMin_threshold_I_sigma())

    #Only to export the entire XML tree to a file stream on disk
    def outputFile( self, _outfileName ):
        outfile = open( _outfileName, "w" )
        outfile.write("<?xml version=\"1.0\" ?>\n")
        self.export( outfile, 0, name_='index_parameters' )
        outfile.close()


    #Only to export the entire XML tree to a Html Page in a file stream on disk
    def outputPageHtml( self, _outfileName ):
        odtStrTitle = "    <span class=\"title\">index_parameters:</span> <br> <br> <br>\n" 
        outfile = open( _outfileName, "w" )
        outfile.write( TEMPLATE_PAGE_P1 % ( odtStrTitle ) )
        self.exportLiteralHtml( outfile, 0, name_='index_parameters' )
        outfile.write( TEMPLATE_PAGE_P2  )
        outfile.close()


    def outputFileHtml( self, _outfileName ):
        self.outputPageHtml( _outfileName )



    #Static method for parsing a string
    def parseString( _inString ):
        doc = minidom.parseString(_inString)
        rootNode = doc.documentElement
        rootObj = index_parameters.factory()
        rootObj.build(rootNode)
        return rootObj
    parseString = staticmethod( parseString ) 


    #Method for marshalling an object
    def marshal( self ):
        oStreamString = StringIO.StringIO()
        oStreamString.write('<?xml version="1.0" ?>\n')
        self.export( oStreamString, 0, name_="index_parameters" )
        oStringXML = oStreamString.getvalue()
        oStreamString.close()
        return oStringXML

    def exportLiteral(self, outfile, level = 0, name_='index_parameters'):
        level += 1
        self.exportLiteralAttributes(outfile, level, name_)
        self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.extra_index_commands:
            showIndent(outfile, level)
            outfile.write('extra_index_commands = extra_commands(\n')
            self.extra_index_commands.exportLiteral(outfile, level, name_='extra_index_commands')
            showIndent(outfile, level)
            outfile.write('),\n')
        showIndent(outfile, level)
        outfile.write('warning_index_spot_rms_error = %e,\n' % self.getWarning_index_spot_rms_error())
        showIndent(outfile, level)
        outfile.write('max_index_spot_rms_error = %e,\n' % self.getMax_index_spot_rms_error())
        showIndent(outfile, level)
        outfile.write('warning_beam_shift = %e,\n' % self.getWarning_beam_shift())
        showIndent(outfile, level)
        outfile.write('max_beam_shift = %e,\n' % self.getMax_beam_shift())
        showIndent(outfile, level)
        outfile.write('warning_index_spot_frac_rejected = %e,\n' % self.getWarning_index_spot_frac_rejected())
        showIndent(outfile, level)
        outfile.write('max_index_spot_frac_rejected = %e,\n' % self.getMax_index_spot_frac_rejected())
        showIndent(outfile, level)
        outfile.write('min_threshold_I_sigma = %e,\n' % self.getMin_threshold_I_sigma())
    def exportLiteralHtml(self, outfile, level = 0, name_='index_parameters'):
        level += 1
        self.exportLiteralAttributesHtml(outfile, level, name_)
        self.exportLiteralChildrenHtml(outfile, level, name_)
    def exportLiteralAttributesHtml(self, outfile, level, name_):
        pass
    def exportLiteralChildrenHtml(self, outfile, level, name_):
        if self.extra_index_commands:
            showIndentHtml(outfile, level)
            outfile.write('extra_index_commands<br>\n')
            self.extra_index_commands.exportLiteralHtml(outfile, level, name_='extra_index_commands')
            showIndentHtml(outfile, level)
            outfile.write('<br>\n')
        showIndentHtml(outfile, level)
        outfile.write('warning_index_spot_rms_error = <a  href:"#">%e</a><br>\n' % self.getWarning_index_spot_rms_error())
        showIndentHtml(outfile, level)
        outfile.write('max_index_spot_rms_error = <a  href:"#">%e</a><br>\n' % self.getMax_index_spot_rms_error())
        showIndentHtml(outfile, level)
        outfile.write('warning_beam_shift = <a  href:"#">%e</a><br>\n' % self.getWarning_beam_shift())
        showIndentHtml(outfile, level)
        outfile.write('max_beam_shift = <a  href:"#">%e</a><br>\n' % self.getMax_beam_shift())
        showIndentHtml(outfile, level)
        outfile.write('warning_index_spot_frac_rejected = <a  href:"#">%e</a><br>\n' % self.getWarning_index_spot_frac_rejected())
        showIndentHtml(outfile, level)
        outfile.write('max_index_spot_frac_rejected = <a  href:"#">%e</a><br>\n' % self.getMax_index_spot_frac_rejected())
        showIndentHtml(outfile, level)
        outfile.write('min_threshold_I_sigma = <a  href:"#">%e</a><br>\n' % self.getMin_threshold_I_sigma())
    def build(self, node_):
        attrs = node_.attributes
        self.buildAttributes(attrs)
        for child_ in node_.childNodes:
            nodeName_ = child_.nodeName.split(':')[-1]
            self.buildChildren(child_, nodeName_)
    def buildAttributes(self, attrs):
        pass
    def buildChildren(self, child_, nodeName_):
        if child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'extra_index_commands':
            obj_ = extra_commands.factory()
            obj_.build(child_)
            self.setExtra_index_commands(obj_)
        elif child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'warning_index_spot_rms_error':
            if child_.firstChild:
                sval_ = child_.firstChild.nodeValue
                try:
                    fval_ = float(sval_)
                except ValueError:
                    raise ValueError('requires float (or double) -- %s' % child_.toxml())
                self.warning_index_spot_rms_error = fval_
        elif child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'max_index_spot_rms_error':
            if child_.firstChild:
                sval_ = child_.firstChild.nodeValue
                try:
                    fval_ = float(sval_)
                except ValueError:
                    raise ValueError('requires float (or double) -- %s' % child_.toxml())
                self.max_index_spot_rms_error = fval_
        elif child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'warning_beam_shift':
            if child_.firstChild:
                sval_ = child_.firstChild.nodeValue
                try:
                    fval_ = float(sval_)
                except ValueError:
                    raise ValueError('requires float (or double) -- %s' % child_.toxml())
                self.warning_beam_shift = fval_
        elif child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'max_beam_shift':
            if child_.firstChild:
                sval_ = child_.firstChild.nodeValue
                try:
                    fval_ = float(sval_)
                except ValueError:
                    raise ValueError('requires float (or double) -- %s' % child_.toxml())
                self.max_beam_shift = fval_
        elif child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'warning_index_spot_frac_rejected':
            if child_.firstChild:
                sval_ = child_.firstChild.nodeValue
                try:
                    fval_ = float(sval_)
                except ValueError:
                    raise ValueError('requires float (or double) -- %s' % child_.toxml())
                self.warning_index_spot_frac_rejected = fval_
        elif child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'max_index_spot_frac_rejected':
            if child_.firstChild:
                sval_ = child_.firstChild.nodeValue
                try:
                    fval_ = float(sval_)
                except ValueError:
                    raise ValueError('requires float (or double) -- %s' % child_.toxml())
                self.max_index_spot_frac_rejected = fval_
        elif child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'min_threshold_I_sigma':
            if child_.firstChild:
                sval_ = child_.firstChild.nodeValue
                try:
                    fval_ = float(sval_)
                except ValueError:
                    raise ValueError('requires float (or double) -- %s' % child_.toxml())
                self.min_threshold_I_sigma = fval_
# end class index_parameters


class integrate_parameters(object):
    subclass = None
    def __init__(self, extra_integrate_commands=None):
        self.extra_integrate_commands = extra_integrate_commands
    def factory(*args_, **kwargs_):
        if integrate_parameters.subclass:
            return integrate_parameters.subclass(*args_, **kwargs_)
        else:
            return integrate_parameters(*args_, **kwargs_)
    factory = staticmethod(factory)
    def getExtra_integrate_commands(self): return self.extra_integrate_commands
    def setExtra_integrate_commands(self, extra_integrate_commands): self.extra_integrate_commands = extra_integrate_commands
    def export(self, outfile, level = 0, name_='integrate_parameters'):
        showIndent(outfile, level)
        outfile.write('<%s>\n' % name_)
        self.exportChildren(outfile, level + 1, name_)
        showIndent(outfile, level)
        outfile.write('</%s>\n' % name_)
    def exportAttributes(self, outfile, level, name_='integrate_parameters'):
        pass
    def exportChildren(self, outfile, level, name_='integrate_parameters'):
        if self.extra_integrate_commands:
            self.extra_integrate_commands.export(outfile, level, name_='extra_integrate_commands')

    #Only to export the entire XML tree to a file stream on disk
    def outputFile( self, _outfileName ):
        outfile = open( _outfileName, "w" )
        outfile.write("<?xml version=\"1.0\" ?>\n")
        self.export( outfile, 0, name_='integrate_parameters' )
        outfile.close()


    #Only to export the entire XML tree to a Html Page in a file stream on disk
    def outputPageHtml( self, _outfileName ):
        odtStrTitle = "    <span class=\"title\">integrate_parameters:</span> <br> <br> <br>\n" 
        outfile = open( _outfileName, "w" )
        outfile.write( TEMPLATE_PAGE_P1 % ( odtStrTitle ) )
        self.exportLiteralHtml( outfile, 0, name_='integrate_parameters' )
        outfile.write( TEMPLATE_PAGE_P2  )
        outfile.close()


    def outputFileHtml( self, _outfileName ):
        self.outputPageHtml( _outfileName )



    #Static method for parsing a string
    def parseString( _inString ):
        doc = minidom.parseString(_inString)
        rootNode = doc.documentElement
        rootObj = integrate_parameters.factory()
        rootObj.build(rootNode)
        return rootObj
    parseString = staticmethod( parseString ) 


    #Method for marshalling an object
    def marshal( self ):
        oStreamString = StringIO.StringIO()
        oStreamString.write('<?xml version="1.0" ?>\n')
        self.export( oStreamString, 0, name_="integrate_parameters" )
        oStringXML = oStreamString.getvalue()
        oStreamString.close()
        return oStringXML

    def exportLiteral(self, outfile, level = 0, name_='integrate_parameters'):
        level += 1
        self.exportLiteralAttributes(outfile, level, name_)
        self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.extra_integrate_commands:
            showIndent(outfile, level)
            outfile.write('extra_integrate_commands = extra_commands(\n')
            self.extra_integrate_commands.exportLiteral(outfile, level, name_='extra_integrate_commands')
            showIndent(outfile, level)
            outfile.write('),\n')
    def exportLiteralHtml(self, outfile, level = 0, name_='integrate_parameters'):
        level += 1
        self.exportLiteralAttributesHtml(outfile, level, name_)
        self.exportLiteralChildrenHtml(outfile, level, name_)
    def exportLiteralAttributesHtml(self, outfile, level, name_):
        pass
    def exportLiteralChildrenHtml(self, outfile, level, name_):
        if self.extra_integrate_commands:
            showIndentHtml(outfile, level)
            outfile.write('extra_integrate_commands<br>\n')
            self.extra_integrate_commands.exportLiteralHtml(outfile, level, name_='extra_integrate_commands')
            showIndentHtml(outfile, level)
            outfile.write('<br>\n')
    def build(self, node_):
        attrs = node_.attributes
        self.buildAttributes(attrs)
        for child_ in node_.childNodes:
            nodeName_ = child_.nodeName.split(':')[-1]
            self.buildChildren(child_, nodeName_)
    def buildAttributes(self, attrs):
        pass
    def buildChildren(self, child_, nodeName_):
        if child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'extra_integrate_commands':
            obj_ = extra_commands.factory()
            obj_.build(child_)
            self.setExtra_integrate_commands(obj_)
# end class integrate_parameters


class strategy_parameters(object):
    subclass = None
    def __init__(self, extra_strategy_commands=None, overlap_limit=0.0):
        self.extra_strategy_commands = extra_strategy_commands
        self.overlap_limit = overlap_limit
    def factory(*args_, **kwargs_):
        if strategy_parameters.subclass:
            return strategy_parameters.subclass(*args_, **kwargs_)
        else:
            return strategy_parameters(*args_, **kwargs_)
    factory = staticmethod(factory)
    def getExtra_strategy_commands(self): return self.extra_strategy_commands
    def setExtra_strategy_commands(self, extra_strategy_commands): self.extra_strategy_commands = extra_strategy_commands
    def getOverlap_limit(self): return self.overlap_limit
    def setOverlap_limit(self, overlap_limit): self.overlap_limit = overlap_limit
    def export(self, outfile, level = 0, name_='strategy_parameters'):
        showIndent(outfile, level)
        outfile.write('<%s>\n' % name_)
        self.exportChildren(outfile, level + 1, name_)
        showIndent(outfile, level)
        outfile.write('</%s>\n' % name_)
    def exportAttributes(self, outfile, level, name_='strategy_parameters'):
        pass
    def exportChildren(self, outfile, level, name_='strategy_parameters'):
        if self.extra_strategy_commands:
            self.extra_strategy_commands.export(outfile, level, name_='extra_strategy_commands')
        showIndent(outfile, level)
        outfile.write('<overlap_limit>%e</overlap_limit>\n' % self.getOverlap_limit())

    #Only to export the entire XML tree to a file stream on disk
    def outputFile( self, _outfileName ):
        outfile = open( _outfileName, "w" )
        outfile.write("<?xml version=\"1.0\" ?>\n")
        self.export( outfile, 0, name_='strategy_parameters' )
        outfile.close()


    #Only to export the entire XML tree to a Html Page in a file stream on disk
    def outputPageHtml( self, _outfileName ):
        odtStrTitle = "    <span class=\"title\">strategy_parameters:</span> <br> <br> <br>\n" 
        outfile = open( _outfileName, "w" )
        outfile.write( TEMPLATE_PAGE_P1 % ( odtStrTitle ) )
        self.exportLiteralHtml( outfile, 0, name_='strategy_parameters' )
        outfile.write( TEMPLATE_PAGE_P2  )
        outfile.close()


    def outputFileHtml( self, _outfileName ):
        self.outputPageHtml( _outfileName )



    #Static method for parsing a string
    def parseString( _inString ):
        doc = minidom.parseString(_inString)
        rootNode = doc.documentElement
        rootObj = strategy_parameters.factory()
        rootObj.build(rootNode)
        return rootObj
    parseString = staticmethod( parseString ) 


    #Method for marshalling an object
    def marshal( self ):
        oStreamString = StringIO.StringIO()
        oStreamString.write('<?xml version="1.0" ?>\n')
        self.export( oStreamString, 0, name_="strategy_parameters" )
        oStringXML = oStreamString.getvalue()
        oStreamString.close()
        return oStringXML

    def exportLiteral(self, outfile, level = 0, name_='strategy_parameters'):
        level += 1
        self.exportLiteralAttributes(outfile, level, name_)
        self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.extra_strategy_commands:
            showIndent(outfile, level)
            outfile.write('extra_strategy_commands = extra_commands(\n')
            self.extra_strategy_commands.exportLiteral(outfile, level, name_='extra_strategy_commands')
            showIndent(outfile, level)
            outfile.write('),\n')
        showIndent(outfile, level)
        outfile.write('overlap_limit = %e,\n' % self.getOverlap_limit())
    def exportLiteralHtml(self, outfile, level = 0, name_='strategy_parameters'):
        level += 1
        self.exportLiteralAttributesHtml(outfile, level, name_)
        self.exportLiteralChildrenHtml(outfile, level, name_)
    def exportLiteralAttributesHtml(self, outfile, level, name_):
        pass
    def exportLiteralChildrenHtml(self, outfile, level, name_):
        if self.extra_strategy_commands:
            showIndentHtml(outfile, level)
            outfile.write('extra_strategy_commands<br>\n')
            self.extra_strategy_commands.exportLiteralHtml(outfile, level, name_='extra_strategy_commands')
            showIndentHtml(outfile, level)
            outfile.write('<br>\n')
        showIndentHtml(outfile, level)
        outfile.write('overlap_limit = <a  href:"#">%e</a><br>\n' % self.getOverlap_limit())
    def build(self, node_):
        attrs = node_.attributes
        self.buildAttributes(attrs)
        for child_ in node_.childNodes:
            nodeName_ = child_.nodeName.split(':')[-1]
            self.buildChildren(child_, nodeName_)
    def buildAttributes(self, attrs):
        pass
    def buildChildren(self, child_, nodeName_):
        if child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'extra_strategy_commands':
            obj_ = extra_commands.factory()
            obj_.build(child_)
            self.setExtra_strategy_commands(obj_)
        elif child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'overlap_limit':
            if child_.firstChild:
                sval_ = child_.firstChild.nodeValue
                try:
                    fval_ = float(sval_)
                except ValueError:
                    raise ValueError('requires float (or double) -- %s' % child_.toxml())
                self.overlap_limit = fval_
# end class strategy_parameters


class rank_parameters(object):
    subclass = None
    def __init__(self, rankEngine='', rankProjectFile=''):
        self.rankEngine = rankEngine
        self.rankProjectFile = rankProjectFile
    def factory(*args_, **kwargs_):
        if rank_parameters.subclass:
            return rank_parameters.subclass(*args_, **kwargs_)
        else:
            return rank_parameters(*args_, **kwargs_)
    factory = staticmethod(factory)
    def getRankEngine(self): return self.rankEngine
    def setRankEngine(self, rankEngine): self.rankEngine = rankEngine
    def getRankProjectFile(self): return self.rankProjectFile
    def setRankProjectFile(self, rankProjectFile): self.rankProjectFile = rankProjectFile
    def export(self, outfile, level = 0, name_='rank_parameters'):
        showIndent(outfile, level)
        outfile.write('<%s>\n' % name_)
        self.exportChildren(outfile, level + 1, name_)
        showIndent(outfile, level)
        outfile.write('</%s>\n' % name_)
    def exportAttributes(self, outfile, level, name_='rank_parameters'):
        pass
    def exportChildren(self, outfile, level, name_='rank_parameters'):
        showIndent(outfile, level)
        outfile.write('<rankEngine>%s</rankEngine>\n' % quote_xml(self.getRankEngine()))
        showIndent(outfile, level)
        outfile.write('<rankProjectFile>%s</rankProjectFile>\n' % quote_xml(self.getRankProjectFile()))

    #Only to export the entire XML tree to a file stream on disk
    def outputFile( self, _outfileName ):
        outfile = open( _outfileName, "w" )
        outfile.write("<?xml version=\"1.0\" ?>\n")
        self.export( outfile, 0, name_='rank_parameters' )
        outfile.close()


    #Only to export the entire XML tree to a Html Page in a file stream on disk
    def outputPageHtml( self, _outfileName ):
        odtStrTitle = "    <span class=\"title\">rank_parameters:</span> <br> <br> <br>\n" 
        outfile = open( _outfileName, "w" )
        outfile.write( TEMPLATE_PAGE_P1 % ( odtStrTitle ) )
        self.exportLiteralHtml( outfile, 0, name_='rank_parameters' )
        outfile.write( TEMPLATE_PAGE_P2  )
        outfile.close()


    def outputFileHtml( self, _outfileName ):
        self.outputPageHtml( _outfileName )



    #Static method for parsing a string
    def parseString( _inString ):
        doc = minidom.parseString(_inString)
        rootNode = doc.documentElement
        rootObj = rank_parameters.factory()
        rootObj.build(rootNode)
        return rootObj
    parseString = staticmethod( parseString ) 


    #Method for marshalling an object
    def marshal( self ):
        oStreamString = StringIO.StringIO()
        oStreamString.write('<?xml version="1.0" ?>\n')
        self.export( oStreamString, 0, name_="rank_parameters" )
        oStringXML = oStreamString.getvalue()
        oStreamString.close()
        return oStringXML

    def exportLiteral(self, outfile, level = 0, name_='rank_parameters'):
        level += 1
        self.exportLiteralAttributes(outfile, level, name_)
        self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('rankEngine = %s,\n' % quote_python(self.getRankEngine()))
        showIndent(outfile, level)
        outfile.write('rankProjectFile = %s,\n' % quote_python(self.getRankProjectFile()))
    def exportLiteralHtml(self, outfile, level = 0, name_='rank_parameters'):
        level += 1
        self.exportLiteralAttributesHtml(outfile, level, name_)
        self.exportLiteralChildrenHtml(outfile, level, name_)
    def exportLiteralAttributesHtml(self, outfile, level, name_):
        pass
    def exportLiteralChildrenHtml(self, outfile, level, name_):
        showIndentHtml(outfile, level)
        outfile.write('rankEngine = <a  href:"#">%s</a><br>\n' % quote_python(self.getRankEngine()))
        showIndentHtml(outfile, level)
        outfile.write('rankProjectFile = <a  href:"#">%s</a><br>\n' % quote_python(self.getRankProjectFile()))
    def build(self, node_):
        attrs = node_.attributes
        self.buildAttributes(attrs)
        for child_ in node_.childNodes:
            nodeName_ = child_.nodeName.split(':')[-1]
            self.buildChildren(child_, nodeName_)
    def buildAttributes(self, attrs):
        pass
    def buildChildren(self, child_, nodeName_):
        if child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'rankEngine':
            rankEngine_ = ''
            for text__content_ in child_.childNodes:
                rankEngine_ += text__content_.nodeValue
            self.rankEngine = rankEngine_
        elif child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'rankProjectFile':
            rankProjectFile_ = ''
            for text__content_ in child_.childNodes:
                rankProjectFile_ += text__content_.nodeValue
            self.rankProjectFile = rankProjectFile_
# end class rank_parameters


class server_data(object):
    subclass = None
    def __init__(self, expert_system_host_name='', expert_system_port_number='', dpm_host_name='', dpm_log_file='', mosflm_executable='', bcm_host_name='', bcm_port_number='', bcm_kappa_in_use=False, db_host_name='', db_port_number='', gui_host_name='', gui_port_number='', timeout_length=''):
        self.expert_system_host_name = expert_system_host_name
        self.expert_system_port_number = expert_system_port_number
        self.dpm_host_name = dpm_host_name
        self.dpm_log_file = dpm_log_file
        self.mosflm_executable = mosflm_executable
        self.bcm_host_name = bcm_host_name
        self.bcm_port_number = bcm_port_number
        self.bcm_kappa_in_use = bcm_kappa_in_use
        self.db_host_name = db_host_name
        self.db_port_number = db_port_number
        self.gui_host_name = gui_host_name
        self.gui_port_number = gui_port_number
        self.timeout_length = timeout_length
    def factory(*args_, **kwargs_):
        if server_data.subclass:
            return server_data.subclass(*args_, **kwargs_)
        else:
            return server_data(*args_, **kwargs_)
    factory = staticmethod(factory)
    def getExpert_system_host_name(self): return self.expert_system_host_name
    def setExpert_system_host_name(self, expert_system_host_name): self.expert_system_host_name = expert_system_host_name
    def getExpert_system_port_number(self): return self.expert_system_port_number
    def setExpert_system_port_number(self, expert_system_port_number): self.expert_system_port_number = expert_system_port_number
    def getDpm_host_name(self): return self.dpm_host_name
    def setDpm_host_name(self, dpm_host_name): self.dpm_host_name = dpm_host_name
    def getDpm_log_file(self): return self.dpm_log_file
    def setDpm_log_file(self, dpm_log_file): self.dpm_log_file = dpm_log_file
    def getMosflm_executable(self): return self.mosflm_executable
    def setMosflm_executable(self, mosflm_executable): self.mosflm_executable = mosflm_executable
    def getBcm_host_name(self): return self.bcm_host_name
    def setBcm_host_name(self, bcm_host_name): self.bcm_host_name = bcm_host_name
    def getBcm_port_number(self): return self.bcm_port_number
    def setBcm_port_number(self, bcm_port_number): self.bcm_port_number = bcm_port_number
    def getBcm_kappa_in_use(self): return self.bcm_kappa_in_use
    def setBcm_kappa_in_use(self, bcm_kappa_in_use): self.bcm_kappa_in_use = bcm_kappa_in_use
    def getDb_host_name(self): return self.db_host_name
    def setDb_host_name(self, db_host_name): self.db_host_name = db_host_name
    def getDb_port_number(self): return self.db_port_number
    def setDb_port_number(self, db_port_number): self.db_port_number = db_port_number
    def getGui_host_name(self): return self.gui_host_name
    def setGui_host_name(self, gui_host_name): self.gui_host_name = gui_host_name
    def getGui_port_number(self): return self.gui_port_number
    def setGui_port_number(self, gui_port_number): self.gui_port_number = gui_port_number
    def getTimeout_length(self): return self.timeout_length
    def setTimeout_length(self, timeout_length): self.timeout_length = timeout_length
    def export(self, outfile, level = 0, name_='server_data'):
        showIndent(outfile, level)
        outfile.write('<%s>\n' % name_)
        self.exportChildren(outfile, level + 1, name_)
        showIndent(outfile, level)
        outfile.write('</%s>\n' % name_)
    def exportAttributes(self, outfile, level, name_='server_data'):
        pass
    def exportChildren(self, outfile, level, name_='server_data'):
        showIndent(outfile, level)
        outfile.write('<expert_system_host_name>%s</expert_system_host_name>\n' % quote_xml(self.getExpert_system_host_name()))
        showIndent(outfile, level)
        outfile.write('<expert_system_port_number>%s</expert_system_port_number>\n' % quote_xml(self.getExpert_system_port_number()))
        showIndent(outfile, level)
        outfile.write('<dpm_host_name>%s</dpm_host_name>\n' % quote_xml(self.getDpm_host_name()))
        showIndent(outfile, level)
        outfile.write('<dpm_log_file>%s</dpm_log_file>\n' % quote_xml(self.getDpm_log_file()))
        showIndent(outfile, level)
        outfile.write('<mosflm_executable>%s</mosflm_executable>\n' % quote_xml(self.getMosflm_executable()))
        showIndent(outfile, level)
        outfile.write('<bcm_host_name>%s</bcm_host_name>\n' % quote_xml(self.getBcm_host_name()))
        showIndent(outfile, level)
        outfile.write('<bcm_port_number>%s</bcm_port_number>\n' % quote_xml(self.getBcm_port_number()))
        showIndent(outfile, level)
        outfile.write('<bcm_kappa_in_use>%s</bcm_kappa_in_use>\n' % self.getBcm_kappa_in_use())
        showIndent(outfile, level)
        outfile.write('<db_host_name>%s</db_host_name>\n' % quote_xml(self.getDb_host_name()))
        showIndent(outfile, level)
        outfile.write('<db_port_number>%s</db_port_number>\n' % quote_xml(self.getDb_port_number()))
        showIndent(outfile, level)
        outfile.write('<gui_host_name>%s</gui_host_name>\n' % quote_xml(self.getGui_host_name()))
        showIndent(outfile, level)
        outfile.write('<gui_port_number>%s</gui_port_number>\n' % quote_xml(self.getGui_port_number()))
        showIndent(outfile, level)
        outfile.write('<timeout_length>%s</timeout_length>\n' % quote_xml(self.getTimeout_length()))

    #Only to export the entire XML tree to a file stream on disk
    def outputFile( self, _outfileName ):
        outfile = open( _outfileName, "w" )
        outfile.write("<?xml version=\"1.0\" ?>\n")
        self.export( outfile, 0, name_='server_data' )
        outfile.close()


    #Only to export the entire XML tree to a Html Page in a file stream on disk
    def outputPageHtml( self, _outfileName ):
        odtStrTitle = "    <span class=\"title\">server_data:</span> <br> <br> <br>\n" 
        outfile = open( _outfileName, "w" )
        outfile.write( TEMPLATE_PAGE_P1 % ( odtStrTitle ) )
        self.exportLiteralHtml( outfile, 0, name_='server_data' )
        outfile.write( TEMPLATE_PAGE_P2  )
        outfile.close()


    def outputFileHtml( self, _outfileName ):
        self.outputPageHtml( _outfileName )



    #Static method for parsing a string
    def parseString( _inString ):
        doc = minidom.parseString(_inString)
        rootNode = doc.documentElement
        rootObj = server_data.factory()
        rootObj.build(rootNode)
        return rootObj
    parseString = staticmethod( parseString ) 


    #Method for marshalling an object
    def marshal( self ):
        oStreamString = StringIO.StringIO()
        oStreamString.write('<?xml version="1.0" ?>\n')
        self.export( oStreamString, 0, name_="server_data" )
        oStringXML = oStreamString.getvalue()
        oStreamString.close()
        return oStringXML

    def exportLiteral(self, outfile, level = 0, name_='server_data'):
        level += 1
        self.exportLiteralAttributes(outfile, level, name_)
        self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('expert_system_host_name = %s,\n' % quote_python(self.getExpert_system_host_name()))
        showIndent(outfile, level)
        outfile.write('expert_system_port_number = %s,\n' % quote_python(self.getExpert_system_port_number()))
        showIndent(outfile, level)
        outfile.write('dpm_host_name = %s,\n' % quote_python(self.getDpm_host_name()))
        showIndent(outfile, level)
        outfile.write('dpm_log_file = %s,\n' % quote_python(self.getDpm_log_file()))
        showIndent(outfile, level)
        outfile.write('mosflm_executable = %s,\n' % quote_python(self.getMosflm_executable()))
        showIndent(outfile, level)
        outfile.write('bcm_host_name = %s,\n' % quote_python(self.getBcm_host_name()))
        showIndent(outfile, level)
        outfile.write('bcm_port_number = %s,\n' % quote_python(self.getBcm_port_number()))
        showIndent(outfile, level)
        outfile.write('bcm_kappa_in_use = %s,\n' % self.getBcm_kappa_in_use())
        showIndent(outfile, level)
        outfile.write('db_host_name = %s,\n' % quote_python(self.getDb_host_name()))
        showIndent(outfile, level)
        outfile.write('db_port_number = %s,\n' % quote_python(self.getDb_port_number()))
        showIndent(outfile, level)
        outfile.write('gui_host_name = %s,\n' % quote_python(self.getGui_host_name()))
        showIndent(outfile, level)
        outfile.write('gui_port_number = %s,\n' % quote_python(self.getGui_port_number()))
        showIndent(outfile, level)
        outfile.write('timeout_length = %s,\n' % quote_python(self.getTimeout_length()))
    def exportLiteralHtml(self, outfile, level = 0, name_='server_data'):
        level += 1
        self.exportLiteralAttributesHtml(outfile, level, name_)
        self.exportLiteralChildrenHtml(outfile, level, name_)
    def exportLiteralAttributesHtml(self, outfile, level, name_):
        pass
    def exportLiteralChildrenHtml(self, outfile, level, name_):
        showIndentHtml(outfile, level)
        outfile.write('expert_system_host_name = <a  href:"#">%s</a><br>\n' % quote_python(self.getExpert_system_host_name()))
        showIndentHtml(outfile, level)
        outfile.write('expert_system_port_number = <a  href:"#">%s</a><br>\n' % quote_python(self.getExpert_system_port_number()))
        showIndentHtml(outfile, level)
        outfile.write('dpm_host_name = <a  href:"#">%s</a><br>\n' % quote_python(self.getDpm_host_name()))
        showIndentHtml(outfile, level)
        outfile.write('dpm_log_file = <a  href:"#">%s</a><br>\n' % quote_python(self.getDpm_log_file()))
        showIndentHtml(outfile, level)
        outfile.write('mosflm_executable = <a  href:"#">%s</a><br>\n' % quote_python(self.getMosflm_executable()))
        showIndentHtml(outfile, level)
        outfile.write('bcm_host_name = <a  href:"#">%s</a><br>\n' % quote_python(self.getBcm_host_name()))
        showIndentHtml(outfile, level)
        outfile.write('bcm_port_number = <a  href:"#">%s</a><br>\n' % quote_python(self.getBcm_port_number()))
        showIndentHtml(outfile, level)
        outfile.write('bcm_kappa_in_use = <a  href:"#">%s</a><br>\n' % self.getBcm_kappa_in_use())
        showIndentHtml(outfile, level)
        outfile.write('db_host_name = <a  href:"#">%s</a><br>\n' % quote_python(self.getDb_host_name()))
        showIndentHtml(outfile, level)
        outfile.write('db_port_number = <a  href:"#">%s</a><br>\n' % quote_python(self.getDb_port_number()))
        showIndentHtml(outfile, level)
        outfile.write('gui_host_name = <a  href:"#">%s</a><br>\n' % quote_python(self.getGui_host_name()))
        showIndentHtml(outfile, level)
        outfile.write('gui_port_number = <a  href:"#">%s</a><br>\n' % quote_python(self.getGui_port_number()))
        showIndentHtml(outfile, level)
        outfile.write('timeout_length = <a  href:"#">%s</a><br>\n' % quote_python(self.getTimeout_length()))
    def build(self, node_):
        attrs = node_.attributes
        self.buildAttributes(attrs)
        for child_ in node_.childNodes:
            nodeName_ = child_.nodeName.split(':')[-1]
            self.buildChildren(child_, nodeName_)
    def buildAttributes(self, attrs):
        pass
    def buildChildren(self, child_, nodeName_):
        if child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'expert_system_host_name':
            expert_system_host_name_ = ''
            for text__content_ in child_.childNodes:
                expert_system_host_name_ += text__content_.nodeValue
            self.expert_system_host_name = expert_system_host_name_
        elif child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'expert_system_port_number':
            expert_system_port_number_ = ''
            for text__content_ in child_.childNodes:
                expert_system_port_number_ += text__content_.nodeValue
            self.expert_system_port_number = expert_system_port_number_
        elif child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'dpm_host_name':
            dpm_host_name_ = ''
            for text__content_ in child_.childNodes:
                dpm_host_name_ += text__content_.nodeValue
            self.dpm_host_name = dpm_host_name_
        elif child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'dpm_log_file':
            dpm_log_file_ = ''
            for text__content_ in child_.childNodes:
                dpm_log_file_ += text__content_.nodeValue
            self.dpm_log_file = dpm_log_file_
        elif child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'mosflm_executable':
            mosflm_executable_ = ''
            for text__content_ in child_.childNodes:
                mosflm_executable_ += text__content_.nodeValue
            self.mosflm_executable = mosflm_executable_
        elif child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'bcm_host_name':
            bcm_host_name_ = ''
            for text__content_ in child_.childNodes:
                bcm_host_name_ += text__content_.nodeValue
            self.bcm_host_name = bcm_host_name_
        elif child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'bcm_port_number':
            bcm_port_number_ = ''
            for text__content_ in child_.childNodes:
                bcm_port_number_ += text__content_.nodeValue
            self.bcm_port_number = bcm_port_number_
        elif child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'bcm_kappa_in_use':
            if child_.firstChild:
                sval_ = child_.firstChild.nodeValue
                if sval_ in ('true', 'True', '1'):
                    ival_ = True
                elif sval_ in ('false', 'False', '0'):
                    ival_ = False
                else:
                    raise ValueError('requires boolean -- %s' % child_.toxml())
                self.bcm_kappa_in_use = ival_
        elif child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'db_host_name':
            db_host_name_ = ''
            for text__content_ in child_.childNodes:
                db_host_name_ += text__content_.nodeValue
            self.db_host_name = db_host_name_
        elif child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'db_port_number':
            db_port_number_ = ''
            for text__content_ in child_.childNodes:
                db_port_number_ += text__content_.nodeValue
            self.db_port_number = db_port_number_
        elif child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'gui_host_name':
            gui_host_name_ = ''
            for text__content_ in child_.childNodes:
                gui_host_name_ += text__content_.nodeValue
            self.gui_host_name = gui_host_name_
        elif child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'gui_port_number':
            gui_port_number_ = ''
            for text__content_ in child_.childNodes:
                gui_port_number_ += text__content_.nodeValue
            self.gui_port_number = gui_port_number_
        elif child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'timeout_length':
            timeout_length_ = ''
            for text__content_ in child_.childNodes:
                timeout_length_ += text__content_.nodeValue
            self.timeout_length = timeout_length_
# end class server_data


class default_values(object):
    subclass = None
    def __init__(self, sample_identifier='', fileinfo=None, oscillation_sequence=None, detector=None, beam=None, resolution=0.0, comment=''):
        self.sample_identifier = sample_identifier
        self.fileinfo = fileinfo
        self.oscillation_sequence = oscillation_sequence
        self.detector = detector
        self.beam = beam
        self.resolution = resolution
        self.comment = comment
    def factory(*args_, **kwargs_):
        if default_values.subclass:
            return default_values.subclass(*args_, **kwargs_)
        else:
            return default_values(*args_, **kwargs_)
    factory = staticmethod(factory)
    def getSample_identifier(self): return self.sample_identifier
    def setSample_identifier(self, sample_identifier): self.sample_identifier = sample_identifier
    def getFileinfo(self): return self.fileinfo
    def setFileinfo(self, fileinfo): self.fileinfo = fileinfo
    def getOscillation_sequence(self): return self.oscillation_sequence
    def setOscillation_sequence(self, oscillation_sequence): self.oscillation_sequence = oscillation_sequence
    def getDetector(self): return self.detector
    def setDetector(self, detector): self.detector = detector
    def getBeam(self): return self.beam
    def setBeam(self, beam): self.beam = beam
    def getResolution(self): return self.resolution
    def setResolution(self, resolution): self.resolution = resolution
    def getComment(self): return self.comment
    def setComment(self, comment): self.comment = comment
    def export(self, outfile, level = 0, name_='default_values'):
        showIndent(outfile, level)
        outfile.write('<%s>\n' % name_)
        self.exportChildren(outfile, level + 1, name_)
        showIndent(outfile, level)
        outfile.write('</%s>\n' % name_)
    def exportAttributes(self, outfile, level, name_='default_values'):
        pass
    def exportChildren(self, outfile, level, name_='default_values'):
        showIndent(outfile, level)
        outfile.write('<sample_identifier>%s</sample_identifier>\n' % quote_xml(self.getSample_identifier()))
        if self.fileinfo:
            self.fileinfo.export(outfile, level)
        if self.oscillation_sequence:
            self.oscillation_sequence.export(outfile, level)
        if self.detector:
            self.detector.export(outfile, level)
        if self.beam:
            self.beam.export(outfile, level)
        showIndent(outfile, level)
        outfile.write('<resolution>%e</resolution>\n' % self.getResolution())
        showIndent(outfile, level)
        outfile.write('<comment>%s</comment>\n' % quote_xml(self.getComment()))

    #Only to export the entire XML tree to a file stream on disk
    def outputFile( self, _outfileName ):
        outfile = open( _outfileName, "w" )
        outfile.write("<?xml version=\"1.0\" ?>\n")
        self.export( outfile, 0, name_='default_values' )
        outfile.close()


    #Only to export the entire XML tree to a Html Page in a file stream on disk
    def outputPageHtml( self, _outfileName ):
        odtStrTitle = "    <span class=\"title\">default_values:</span> <br> <br> <br>\n" 
        outfile = open( _outfileName, "w" )
        outfile.write( TEMPLATE_PAGE_P1 % ( odtStrTitle ) )
        self.exportLiteralHtml( outfile, 0, name_='default_values' )
        outfile.write( TEMPLATE_PAGE_P2  )
        outfile.close()


    def outputFileHtml( self, _outfileName ):
        self.outputPageHtml( _outfileName )



    #Static method for parsing a string
    def parseString( _inString ):
        doc = minidom.parseString(_inString)
        rootNode = doc.documentElement
        rootObj = default_values.factory()
        rootObj.build(rootNode)
        return rootObj
    parseString = staticmethod( parseString ) 


    #Method for marshalling an object
    def marshal( self ):
        oStreamString = StringIO.StringIO()
        oStreamString.write('<?xml version="1.0" ?>\n')
        self.export( oStreamString, 0, name_="default_values" )
        oStringXML = oStreamString.getvalue()
        oStreamString.close()
        return oStringXML

    def exportLiteral(self, outfile, level = 0, name_='default_values'):
        level += 1
        self.exportLiteralAttributes(outfile, level, name_)
        self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('sample_identifier = %s,\n' % quote_python(self.getSample_identifier()))
        if self.fileinfo:
            showIndent(outfile, level)
            outfile.write('fileinfo = fileinfo(\n')
            self.fileinfo.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.oscillation_sequence:
            showIndent(outfile, level)
            outfile.write('oscillation_sequence = oscillation_sequence(\n')
            self.oscillation_sequence.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.detector:
            showIndent(outfile, level)
            outfile.write('detector = detector(\n')
            self.detector.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.beam:
            showIndent(outfile, level)
            outfile.write('beam = beam(\n')
            self.beam.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        showIndent(outfile, level)
        outfile.write('resolution = %e,\n' % self.getResolution())
        showIndent(outfile, level)
        outfile.write('comment = %s,\n' % quote_python(self.getComment()))
    def exportLiteralHtml(self, outfile, level = 0, name_='default_values'):
        level += 1
        self.exportLiteralAttributesHtml(outfile, level, name_)
        self.exportLiteralChildrenHtml(outfile, level, name_)
    def exportLiteralAttributesHtml(self, outfile, level, name_):
        pass
    def exportLiteralChildrenHtml(self, outfile, level, name_):
        showIndentHtml(outfile, level)
        outfile.write('sample_identifier = <a  href:"#">%s</a><br>\n' % quote_python(self.getSample_identifier()))
        if self.fileinfo:
            showIndentHtml(outfile, level)
            outfile.write('fileinfo<br>\n')
            self.fileinfo.exportLiteralHtml(outfile, level)
            showIndentHtml(outfile, level)
            outfile.write('<br>\n')
        if self.oscillation_sequence:
            showIndentHtml(outfile, level)
            outfile.write('oscillation_sequence<br>\n')
            self.oscillation_sequence.exportLiteralHtml(outfile, level)
            showIndentHtml(outfile, level)
            outfile.write('<br>\n')
        if self.detector:
            showIndentHtml(outfile, level)
            outfile.write('detector<br>\n')
            self.detector.exportLiteralHtml(outfile, level)
            showIndentHtml(outfile, level)
            outfile.write('<br>\n')
        if self.beam:
            showIndentHtml(outfile, level)
            outfile.write('beam<br>\n')
            self.beam.exportLiteralHtml(outfile, level)
            showIndentHtml(outfile, level)
            outfile.write('<br>\n')
        showIndentHtml(outfile, level)
        outfile.write('resolution = <a  href:"#">%e</a><br>\n' % self.getResolution())
        showIndentHtml(outfile, level)
        outfile.write('comment = <a  href:"#">%s</a><br>\n' % quote_python(self.getComment()))
    def build(self, node_):
        attrs = node_.attributes
        self.buildAttributes(attrs)
        for child_ in node_.childNodes:
            nodeName_ = child_.nodeName.split(':')[-1]
            self.buildChildren(child_, nodeName_)
    def buildAttributes(self, attrs):
        pass
    def buildChildren(self, child_, nodeName_):
        if child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'sample_identifier':
            sample_identifier_ = ''
            for text__content_ in child_.childNodes:
                sample_identifier_ += text__content_.nodeValue
            self.sample_identifier = sample_identifier_
        elif child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'fileinfo':
            obj_ = fileinfo.factory()
            obj_.build(child_)
            self.setFileinfo(obj_)
        elif child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'oscillation_sequence':
            obj_ = oscillation_sequence.factory()
            obj_.build(child_)
            self.setOscillation_sequence(obj_)
        elif child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'detector':
            obj_ = detector.factory()
            obj_.build(child_)
            self.setDetector(obj_)
        elif child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'beam':
            obj_ = beam.factory()
            obj_.build(child_)
            self.setBeam(obj_)
        elif child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'resolution':
            if child_.firstChild:
                sval_ = child_.firstChild.nodeValue
                try:
                    fval_ = float(sval_)
                except ValueError:
                    raise ValueError('requires float (or double) -- %s' % child_.toxml())
                self.resolution = fval_
        elif child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'comment':
            comment_ = ''
            for text__content_ in child_.childNodes:
                comment_ += text__content_.nodeValue
            self.comment = comment_
# end class default_values


class dna_configuration_request(object):
    subclass = None
    def __init__(self, system_defaults=None, user_defaults=None):
        self.system_defaults = system_defaults
        self.user_defaults = user_defaults
    def factory(*args_, **kwargs_):
        if dna_configuration_request.subclass:
            return dna_configuration_request.subclass(*args_, **kwargs_)
        else:
            return dna_configuration_request(*args_, **kwargs_)
    factory = staticmethod(factory)
    def getSystem_defaults(self): return self.system_defaults
    def setSystem_defaults(self, system_defaults): self.system_defaults = system_defaults
    def getUser_defaults(self): return self.user_defaults
    def setUser_defaults(self, user_defaults): self.user_defaults = user_defaults
    def export(self, outfile, level = 0, name_='dna_configuration_request'):
        showIndent(outfile, level)
        outfile.write('<%s>\n' % name_)
        self.exportChildren(outfile, level + 1, name_)
        showIndent(outfile, level)
        outfile.write('</%s>\n' % name_)
    def exportAttributes(self, outfile, level, name_='dna_configuration_request'):
        pass
    def exportChildren(self, outfile, level, name_='dna_configuration_request'):
        if self.system_defaults:
            self.system_defaults.export(outfile, level)
        if self.user_defaults:
            self.user_defaults.export(outfile, level)

    #Only to export the entire XML tree to a file stream on disk
    def outputFile( self, _outfileName ):
        outfile = open( _outfileName, "w" )
        outfile.write("<?xml version=\"1.0\" ?>\n")
        self.export( outfile, 0, name_='dna_configuration_request' )
        outfile.close()


    #Only to export the entire XML tree to a Html Page in a file stream on disk
    def outputPageHtml( self, _outfileName ):
        odtStrTitle = "    <span class=\"title\">dna_configuration_request:</span> <br> <br> <br>\n" 
        outfile = open( _outfileName, "w" )
        outfile.write( TEMPLATE_PAGE_P1 % ( odtStrTitle ) )
        self.exportLiteralHtml( outfile, 0, name_='dna_configuration_request' )
        outfile.write( TEMPLATE_PAGE_P2  )
        outfile.close()


    def outputFileHtml( self, _outfileName ):
        self.outputPageHtml( _outfileName )



    #Static method for parsing a string
    def parseString( _inString ):
        doc = minidom.parseString(_inString)
        rootNode = doc.documentElement
        rootObj = dna_configuration_request.factory()
        rootObj.build(rootNode)
        return rootObj
    parseString = staticmethod( parseString ) 


    #Method for marshalling an object
    def marshal( self ):
        oStreamString = StringIO.StringIO()
        oStreamString.write('<?xml version="1.0" ?>\n')
        self.export( oStreamString, 0, name_="dna_configuration_request" )
        oStringXML = oStreamString.getvalue()
        oStreamString.close()
        return oStringXML

    def exportLiteral(self, outfile, level = 0, name_='dna_configuration_request'):
        level += 1
        self.exportLiteralAttributes(outfile, level, name_)
        self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.system_defaults:
            showIndent(outfile, level)
            outfile.write('system_defaults = system_defaults(\n')
            self.system_defaults.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.user_defaults:
            showIndent(outfile, level)
            outfile.write('user_defaults = user_defaults(\n')
            self.user_defaults.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
    def exportLiteralHtml(self, outfile, level = 0, name_='dna_configuration_request'):
        level += 1
        self.exportLiteralAttributesHtml(outfile, level, name_)
        self.exportLiteralChildrenHtml(outfile, level, name_)
    def exportLiteralAttributesHtml(self, outfile, level, name_):
        pass
    def exportLiteralChildrenHtml(self, outfile, level, name_):
        if self.system_defaults:
            showIndentHtml(outfile, level)
            outfile.write('system_defaults<br>\n')
            self.system_defaults.exportLiteralHtml(outfile, level)
            showIndentHtml(outfile, level)
            outfile.write('<br>\n')
        if self.user_defaults:
            showIndentHtml(outfile, level)
            outfile.write('user_defaults<br>\n')
            self.user_defaults.exportLiteralHtml(outfile, level)
            showIndentHtml(outfile, level)
            outfile.write('<br>\n')
    def build(self, node_):
        attrs = node_.attributes
        self.buildAttributes(attrs)
        for child_ in node_.childNodes:
            nodeName_ = child_.nodeName.split(':')[-1]
            self.buildChildren(child_, nodeName_)
    def buildAttributes(self, attrs):
        pass
    def buildChildren(self, child_, nodeName_):
        if child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'system_defaults':
            obj_ = system_defaults.factory()
            obj_.build(child_)
            self.setSystem_defaults(obj_)
        elif child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'user_defaults':
            obj_ = user_defaults.factory()
            obj_.build(child_)
            self.setUser_defaults(obj_)
# end class dna_configuration_request


class dna_configuration_response(object):
    subclass = None
    def __init__(self, system_defaults=None, user_defaults=None, status=None):
        self.system_defaults = system_defaults
        self.user_defaults = user_defaults
        self.status = status
    def factory(*args_, **kwargs_):
        if dna_configuration_response.subclass:
            return dna_configuration_response.subclass(*args_, **kwargs_)
        else:
            return dna_configuration_response(*args_, **kwargs_)
    factory = staticmethod(factory)
    def getSystem_defaults(self): return self.system_defaults
    def setSystem_defaults(self, system_defaults): self.system_defaults = system_defaults
    def getUser_defaults(self): return self.user_defaults
    def setUser_defaults(self, user_defaults): self.user_defaults = user_defaults
    def getStatus(self): return self.status
    def setStatus(self, status): self.status = status
    def export(self, outfile, level = 0, name_='dna_configuration_response'):
        showIndent(outfile, level)
        outfile.write('<%s>\n' % name_)
        self.exportChildren(outfile, level + 1, name_)
        showIndent(outfile, level)
        outfile.write('</%s>\n' % name_)
    def exportAttributes(self, outfile, level, name_='dna_configuration_response'):
        pass
    def exportChildren(self, outfile, level, name_='dna_configuration_response'):
        if self.system_defaults:
            self.system_defaults.export(outfile, level)
        if self.user_defaults:
            self.user_defaults.export(outfile, level)
        if self.status:
            self.status.export(outfile, level)

    #Only to export the entire XML tree to a file stream on disk
    def outputFile( self, _outfileName ):
        outfile = open( _outfileName, "w" )
        outfile.write("<?xml version=\"1.0\" ?>\n")
        self.export( outfile, 0, name_='dna_configuration_response' )
        outfile.close()


    #Only to export the entire XML tree to a Html Page in a file stream on disk
    def outputPageHtml( self, _outfileName ):
        odtStrTitle = "    <span class=\"title\">dna_configuration_response:</span> <br> <br> <br>\n" 
        outfile = open( _outfileName, "w" )
        outfile.write( TEMPLATE_PAGE_P1 % ( odtStrTitle ) )
        self.exportLiteralHtml( outfile, 0, name_='dna_configuration_response' )
        outfile.write( TEMPLATE_PAGE_P2  )
        outfile.close()


    def outputFileHtml( self, _outfileName ):
        self.outputPageHtml( _outfileName )



    #Static method for parsing a string
    def parseString( _inString ):
        doc = minidom.parseString(_inString)
        rootNode = doc.documentElement
        rootObj = dna_configuration_response.factory()
        rootObj.build(rootNode)
        return rootObj
    parseString = staticmethod( parseString ) 


    #Method for marshalling an object
    def marshal( self ):
        oStreamString = StringIO.StringIO()
        oStreamString.write('<?xml version="1.0" ?>\n')
        self.export( oStreamString, 0, name_="dna_configuration_response" )
        oStringXML = oStreamString.getvalue()
        oStreamString.close()
        return oStringXML

    def exportLiteral(self, outfile, level = 0, name_='dna_configuration_response'):
        level += 1
        self.exportLiteralAttributes(outfile, level, name_)
        self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.system_defaults:
            showIndent(outfile, level)
            outfile.write('system_defaults = system_defaults(\n')
            self.system_defaults.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.user_defaults:
            showIndent(outfile, level)
            outfile.write('user_defaults = user_defaults(\n')
            self.user_defaults.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.status:
            showIndent(outfile, level)
            outfile.write('status = status(\n')
            self.status.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
    def exportLiteralHtml(self, outfile, level = 0, name_='dna_configuration_response'):
        level += 1
        self.exportLiteralAttributesHtml(outfile, level, name_)
        self.exportLiteralChildrenHtml(outfile, level, name_)
    def exportLiteralAttributesHtml(self, outfile, level, name_):
        pass
    def exportLiteralChildrenHtml(self, outfile, level, name_):
        if self.system_defaults:
            showIndentHtml(outfile, level)
            outfile.write('system_defaults<br>\n')
            self.system_defaults.exportLiteralHtml(outfile, level)
            showIndentHtml(outfile, level)
            outfile.write('<br>\n')
        if self.user_defaults:
            showIndentHtml(outfile, level)
            outfile.write('user_defaults<br>\n')
            self.user_defaults.exportLiteralHtml(outfile, level)
            showIndentHtml(outfile, level)
            outfile.write('<br>\n')
        if self.status:
            showIndentHtml(outfile, level)
            outfile.write('status<br>\n')
            self.status.exportLiteralHtml(outfile, level)
            showIndentHtml(outfile, level)
            outfile.write('<br>\n')
    def build(self, node_):
        attrs = node_.attributes
        self.buildAttributes(attrs)
        for child_ in node_.childNodes:
            nodeName_ = child_.nodeName.split(':')[-1]
            self.buildChildren(child_, nodeName_)
    def buildAttributes(self, attrs):
        pass
    def buildChildren(self, child_, nodeName_):
        if child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'system_defaults':
            obj_ = system_defaults.factory()
            obj_.build(child_)
            self.setSystem_defaults(obj_)
        elif child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'user_defaults':
            obj_ = user_defaults.factory()
            obj_.build(child_)
            self.setUser_defaults(obj_)
        elif child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'status':
            obj_ = status.factory()
            obj_.build(child_)
            self.setStatus(obj_)
# end class dna_configuration_response


class dna_context(object):
    subclass = None
    def __init__(self, online=False, current_fileinfo=None, current_oscillation_sequence=None, current_detector=None, current_experiment=None, current_beam=None, current_collect_resolution=None, current_calculated_resolution=None, current_log_dir='', current_archive_reference_images='', current_database_comment=''):
        self.online = online
        self.current_fileinfo = current_fileinfo
        self.current_oscillation_sequence = current_oscillation_sequence
        self.current_detector = current_detector
        self.current_experiment = current_experiment
        self.current_beam = current_beam
        self.current_collect_resolution = current_collect_resolution
        self.current_calculated_resolution = current_calculated_resolution
        self.current_log_dir = current_log_dir
        self.current_archive_reference_images = current_archive_reference_images
        self.current_database_comment = current_database_comment
    def factory(*args_, **kwargs_):
        if dna_context.subclass:
            return dna_context.subclass(*args_, **kwargs_)
        else:
            return dna_context(*args_, **kwargs_)
    factory = staticmethod(factory)
    def getOnline(self): return self.online
    def setOnline(self, online): self.online = online
    def getCurrent_fileinfo(self): return self.current_fileinfo
    def setCurrent_fileinfo(self, current_fileinfo): self.current_fileinfo = current_fileinfo
    def getCurrent_oscillation_sequence(self): return self.current_oscillation_sequence
    def setCurrent_oscillation_sequence(self, current_oscillation_sequence): self.current_oscillation_sequence = current_oscillation_sequence
    def getCurrent_detector(self): return self.current_detector
    def setCurrent_detector(self, current_detector): self.current_detector = current_detector
    def getCurrent_experiment(self): return self.current_experiment
    def setCurrent_experiment(self, current_experiment): self.current_experiment = current_experiment
    def getCurrent_beam(self): return self.current_beam
    def setCurrent_beam(self, current_beam): self.current_beam = current_beam
    def getCurrent_collect_resolution(self): return self.current_collect_resolution
    def setCurrent_collect_resolution(self, current_collect_resolution): self.current_collect_resolution = current_collect_resolution
    def getCurrent_calculated_resolution(self): return self.current_calculated_resolution
    def setCurrent_calculated_resolution(self, current_calculated_resolution): self.current_calculated_resolution = current_calculated_resolution
    def getCurrent_log_dir(self): return self.current_log_dir
    def setCurrent_log_dir(self, current_log_dir): self.current_log_dir = current_log_dir
    def getCurrent_archive_reference_images(self): return self.current_archive_reference_images
    def setCurrent_archive_reference_images(self, current_archive_reference_images): self.current_archive_reference_images = current_archive_reference_images
    def getCurrent_database_comment(self): return self.current_database_comment
    def setCurrent_database_comment(self, current_database_comment): self.current_database_comment = current_database_comment
    def export(self, outfile, level = 0, name_='dna_context'):
        showIndent(outfile, level)
        outfile.write('<%s>\n' % name_)
        self.exportChildren(outfile, level + 1, name_)
        showIndent(outfile, level)
        outfile.write('</%s>\n' % name_)
    def exportAttributes(self, outfile, level, name_='dna_context'):
        pass
    def exportChildren(self, outfile, level, name_='dna_context'):
        showIndent(outfile, level)
        outfile.write('<online>%s</online>\n' % self.getOnline())
        if self.current_fileinfo:
            self.current_fileinfo.export(outfile, level, name_='current_fileinfo')
        if self.current_oscillation_sequence:
            self.current_oscillation_sequence.export(outfile, level, name_='current_oscillation_sequence')
        if self.current_detector:
            self.current_detector.export(outfile, level, name_='current_detector')
        if self.current_experiment:
            self.current_experiment.export(outfile, level, name_='current_experiment')
        if self.current_beam:
            self.current_beam.export(outfile, level, name_='current_beam')
        if self.current_collect_resolution:
            self.current_collect_resolution.export(outfile, level, name_='current_collect_resolution')
        if self.current_calculated_resolution:
            self.current_calculated_resolution.export(outfile, level, name_='current_calculated_resolution')
        showIndent(outfile, level)
        outfile.write('<current_log_dir>%s</current_log_dir>\n' % quote_xml(self.getCurrent_log_dir()))
        showIndent(outfile, level)
        outfile.write('<current_archive_reference_images>%s</current_archive_reference_images>\n' % quote_xml(self.getCurrent_archive_reference_images()))
        showIndent(outfile, level)
        outfile.write('<current_database_comment>%s</current_database_comment>\n' % quote_xml(self.getCurrent_database_comment()))

    #Only to export the entire XML tree to a file stream on disk
    def outputFile( self, _outfileName ):
        outfile = open( _outfileName, "w" )
        outfile.write("<?xml version=\"1.0\" ?>\n")
        self.export( outfile, 0, name_='dna_context' )
        outfile.close()


    #Only to export the entire XML tree to a Html Page in a file stream on disk
    def outputPageHtml( self, _outfileName ):
        odtStrTitle = "    <span class=\"title\">dna_context:</span> <br> <br> <br>\n" 
        outfile = open( _outfileName, "w" )
        outfile.write( TEMPLATE_PAGE_P1 % ( odtStrTitle ) )
        self.exportLiteralHtml( outfile, 0, name_='dna_context' )
        outfile.write( TEMPLATE_PAGE_P2  )
        outfile.close()


    def outputFileHtml( self, _outfileName ):
        self.outputPageHtml( _outfileName )



    #Static method for parsing a string
    def parseString( _inString ):
        doc = minidom.parseString(_inString)
        rootNode = doc.documentElement
        rootObj = dna_context.factory()
        rootObj.build(rootNode)
        return rootObj
    parseString = staticmethod( parseString ) 


    #Method for marshalling an object
    def marshal( self ):
        oStreamString = StringIO.StringIO()
        oStreamString.write('<?xml version="1.0" ?>\n')
        self.export( oStreamString, 0, name_="dna_context" )
        oStringXML = oStreamString.getvalue()
        oStreamString.close()
        return oStringXML

    def exportLiteral(self, outfile, level = 0, name_='dna_context'):
        level += 1
        self.exportLiteralAttributes(outfile, level, name_)
        self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('online = %s,\n' % self.getOnline())
        if self.current_fileinfo:
            showIndent(outfile, level)
            outfile.write('current_fileinfo = fileinfo(\n')
            self.current_fileinfo.exportLiteral(outfile, level, name_='current_fileinfo')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.current_oscillation_sequence:
            showIndent(outfile, level)
            outfile.write('current_oscillation_sequence = oscillation_sequence(\n')
            self.current_oscillation_sequence.exportLiteral(outfile, level, name_='current_oscillation_sequence')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.current_detector:
            showIndent(outfile, level)
            outfile.write('current_detector = detector(\n')
            self.current_detector.exportLiteral(outfile, level, name_='current_detector')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.current_experiment:
            showIndent(outfile, level)
            outfile.write('current_experiment = experiment(\n')
            self.current_experiment.exportLiteral(outfile, level, name_='current_experiment')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.current_beam:
            showIndent(outfile, level)
            outfile.write('current_beam = beam(\n')
            self.current_beam.exportLiteral(outfile, level, name_='current_beam')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.current_collect_resolution:
            showIndent(outfile, level)
            outfile.write('current_collect_resolution = resolution(\n')
            self.current_collect_resolution.exportLiteral(outfile, level, name_='current_collect_resolution')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.current_calculated_resolution:
            showIndent(outfile, level)
            outfile.write('current_calculated_resolution = resolution(\n')
            self.current_calculated_resolution.exportLiteral(outfile, level, name_='current_calculated_resolution')
            showIndent(outfile, level)
            outfile.write('),\n')
        showIndent(outfile, level)
        outfile.write('current_log_dir = %s,\n' % quote_python(self.getCurrent_log_dir()))
        showIndent(outfile, level)
        outfile.write('current_archive_reference_images = %s,\n' % quote_python(self.getCurrent_archive_reference_images()))
        showIndent(outfile, level)
        outfile.write('current_database_comment = %s,\n' % quote_python(self.getCurrent_database_comment()))
    def exportLiteralHtml(self, outfile, level = 0, name_='dna_context'):
        level += 1
        self.exportLiteralAttributesHtml(outfile, level, name_)
        self.exportLiteralChildrenHtml(outfile, level, name_)
    def exportLiteralAttributesHtml(self, outfile, level, name_):
        pass
    def exportLiteralChildrenHtml(self, outfile, level, name_):
        showIndentHtml(outfile, level)
        outfile.write('online = <a  href:"#">%s</a><br>\n' % self.getOnline())
        if self.current_fileinfo:
            showIndentHtml(outfile, level)
            outfile.write('current_fileinfo<br>\n')
            self.current_fileinfo.exportLiteralHtml(outfile, level, name_='current_fileinfo')
            showIndentHtml(outfile, level)
            outfile.write('<br>\n')
        if self.current_oscillation_sequence:
            showIndentHtml(outfile, level)
            outfile.write('current_oscillation_sequence<br>\n')
            self.current_oscillation_sequence.exportLiteralHtml(outfile, level, name_='current_oscillation_sequence')
            showIndentHtml(outfile, level)
            outfile.write('<br>\n')
        if self.current_detector:
            showIndentHtml(outfile, level)
            outfile.write('current_detector<br>\n')
            self.current_detector.exportLiteralHtml(outfile, level, name_='current_detector')
            showIndentHtml(outfile, level)
            outfile.write('<br>\n')
        if self.current_experiment:
            showIndentHtml(outfile, level)
            outfile.write('current_experiment<br>\n')
            self.current_experiment.exportLiteralHtml(outfile, level, name_='current_experiment')
            showIndentHtml(outfile, level)
            outfile.write('<br>\n')
        if self.current_beam:
            showIndentHtml(outfile, level)
            outfile.write('current_beam<br>\n')
            self.current_beam.exportLiteralHtml(outfile, level, name_='current_beam')
            showIndentHtml(outfile, level)
            outfile.write('<br>\n')
        if self.current_collect_resolution:
            showIndentHtml(outfile, level)
            outfile.write('current_collect_resolution<br>\n')
            self.current_collect_resolution.exportLiteralHtml(outfile, level, name_='current_collect_resolution')
            showIndentHtml(outfile, level)
            outfile.write('<br>\n')
        if self.current_calculated_resolution:
            showIndentHtml(outfile, level)
            outfile.write('current_calculated_resolution<br>\n')
            self.current_calculated_resolution.exportLiteralHtml(outfile, level, name_='current_calculated_resolution')
            showIndentHtml(outfile, level)
            outfile.write('<br>\n')
        showIndentHtml(outfile, level)
        outfile.write('current_log_dir = <a  href:"#">%s</a><br>\n' % quote_python(self.getCurrent_log_dir()))
        showIndentHtml(outfile, level)
        outfile.write('current_archive_reference_images = <a  href:"#">%s</a><br>\n' % quote_python(self.getCurrent_archive_reference_images()))
        showIndentHtml(outfile, level)
        outfile.write('current_database_comment = <a  href:"#">%s</a><br>\n' % quote_python(self.getCurrent_database_comment()))
    def build(self, node_):
        attrs = node_.attributes
        self.buildAttributes(attrs)
        for child_ in node_.childNodes:
            nodeName_ = child_.nodeName.split(':')[-1]
            self.buildChildren(child_, nodeName_)
    def buildAttributes(self, attrs):
        pass
    def buildChildren(self, child_, nodeName_):
        if child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'online':
            if child_.firstChild:
                sval_ = child_.firstChild.nodeValue
                if sval_ in ('true', 'True', '1'):
                    ival_ = True
                elif sval_ in ('false', 'False', '0'):
                    ival_ = False
                else:
                    raise ValueError('requires boolean -- %s' % child_.toxml())
                self.online = ival_
        elif child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'current_fileinfo':
            obj_ = fileinfo.factory()
            obj_.build(child_)
            self.setCurrent_fileinfo(obj_)
        elif child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'current_oscillation_sequence':
            obj_ = oscillation_sequence.factory()
            obj_.build(child_)
            self.setCurrent_oscillation_sequence(obj_)
        elif child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'current_detector':
            obj_ = detector.factory()
            obj_.build(child_)
            self.setCurrent_detector(obj_)
        elif child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'current_experiment':
            obj_ = experiment.factory()
            obj_.build(child_)
            self.setCurrent_experiment(obj_)
        elif child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'current_beam':
            obj_ = beam.factory()
            obj_.build(child_)
            self.setCurrent_beam(obj_)
        elif child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'current_collect_resolution':
            obj_ = resolution.factory()
            obj_.build(child_)
            self.setCurrent_collect_resolution(obj_)
        elif child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'current_calculated_resolution':
            obj_ = resolution.factory()
            obj_.build(child_)
            self.setCurrent_calculated_resolution(obj_)
        elif child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'current_log_dir':
            current_log_dir_ = ''
            for text__content_ in child_.childNodes:
                current_log_dir_ += text__content_.nodeValue
            self.current_log_dir = current_log_dir_
        elif child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'current_archive_reference_images':
            current_archive_reference_images_ = ''
            for text__content_ in child_.childNodes:
                current_archive_reference_images_ += text__content_.nodeValue
            self.current_archive_reference_images = current_archive_reference_images_
        elif child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'current_database_comment':
            current_database_comment_ = ''
            for text__content_ in child_.childNodes:
                current_database_comment_ += text__content_.nodeValue
            self.current_database_comment = current_database_comment_
# end class dna_context


class dna_context_request(object):
    subclass = None
    def __init__(self, dna_context=None):
        self.dna_context = dna_context
    def factory(*args_, **kwargs_):
        if dna_context_request.subclass:
            return dna_context_request.subclass(*args_, **kwargs_)
        else:
            return dna_context_request(*args_, **kwargs_)
    factory = staticmethod(factory)
    def getDna_context(self): return self.dna_context
    def setDna_context(self, dna_context): self.dna_context = dna_context
    def export(self, outfile, level = 0, name_='dna_context_request'):
        showIndent(outfile, level)
        outfile.write('<%s>\n' % name_)
        self.exportChildren(outfile, level + 1, name_)
        showIndent(outfile, level)
        outfile.write('</%s>\n' % name_)
    def exportAttributes(self, outfile, level, name_='dna_context_request'):
        pass
    def exportChildren(self, outfile, level, name_='dna_context_request'):
        if self.dna_context:
            self.dna_context.export(outfile, level)

    #Only to export the entire XML tree to a file stream on disk
    def outputFile( self, _outfileName ):
        outfile = open( _outfileName, "w" )
        outfile.write("<?xml version=\"1.0\" ?>\n")
        self.export( outfile, 0, name_='dna_context_request' )
        outfile.close()


    #Only to export the entire XML tree to a Html Page in a file stream on disk
    def outputPageHtml( self, _outfileName ):
        odtStrTitle = "    <span class=\"title\">dna_context_request:</span> <br> <br> <br>\n" 
        outfile = open( _outfileName, "w" )
        outfile.write( TEMPLATE_PAGE_P1 % ( odtStrTitle ) )
        self.exportLiteralHtml( outfile, 0, name_='dna_context_request' )
        outfile.write( TEMPLATE_PAGE_P2  )
        outfile.close()


    def outputFileHtml( self, _outfileName ):
        self.outputPageHtml( _outfileName )



    #Static method for parsing a string
    def parseString( _inString ):
        doc = minidom.parseString(_inString)
        rootNode = doc.documentElement
        rootObj = dna_context_request.factory()
        rootObj.build(rootNode)
        return rootObj
    parseString = staticmethod( parseString ) 


    #Method for marshalling an object
    def marshal( self ):
        oStreamString = StringIO.StringIO()
        oStreamString.write('<?xml version="1.0" ?>\n')
        self.export( oStreamString, 0, name_="dna_context_request" )
        oStringXML = oStreamString.getvalue()
        oStreamString.close()
        return oStringXML

    def exportLiteral(self, outfile, level = 0, name_='dna_context_request'):
        level += 1
        self.exportLiteralAttributes(outfile, level, name_)
        self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.dna_context:
            showIndent(outfile, level)
            outfile.write('dna_context = dna_context(\n')
            self.dna_context.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
    def exportLiteralHtml(self, outfile, level = 0, name_='dna_context_request'):
        level += 1
        self.exportLiteralAttributesHtml(outfile, level, name_)
        self.exportLiteralChildrenHtml(outfile, level, name_)
    def exportLiteralAttributesHtml(self, outfile, level, name_):
        pass
    def exportLiteralChildrenHtml(self, outfile, level, name_):
        if self.dna_context:
            showIndentHtml(outfile, level)
            outfile.write('dna_context<br>\n')
            self.dna_context.exportLiteralHtml(outfile, level)
            showIndentHtml(outfile, level)
            outfile.write('<br>\n')
    def build(self, node_):
        attrs = node_.attributes
        self.buildAttributes(attrs)
        for child_ in node_.childNodes:
            nodeName_ = child_.nodeName.split(':')[-1]
            self.buildChildren(child_, nodeName_)
    def buildAttributes(self, attrs):
        pass
    def buildChildren(self, child_, nodeName_):
        if child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'dna_context':
            obj_ = dna_context.factory()
            obj_.build(child_)
            self.setDna_context(obj_)
# end class dna_context_request


class dna_context_response(object):
    subclass = None
    def __init__(self, dna_context=None, status=None):
        self.dna_context = dna_context
        self.status = status
    def factory(*args_, **kwargs_):
        if dna_context_response.subclass:
            return dna_context_response.subclass(*args_, **kwargs_)
        else:
            return dna_context_response(*args_, **kwargs_)
    factory = staticmethod(factory)
    def getDna_context(self): return self.dna_context
    def setDna_context(self, dna_context): self.dna_context = dna_context
    def getStatus(self): return self.status
    def setStatus(self, status): self.status = status
    def export(self, outfile, level = 0, name_='dna_context_response'):
        showIndent(outfile, level)
        outfile.write('<%s>\n' % name_)
        self.exportChildren(outfile, level + 1, name_)
        showIndent(outfile, level)
        outfile.write('</%s>\n' % name_)
    def exportAttributes(self, outfile, level, name_='dna_context_response'):
        pass
    def exportChildren(self, outfile, level, name_='dna_context_response'):
        if self.dna_context:
            self.dna_context.export(outfile, level)
        if self.status:
            self.status.export(outfile, level)

    #Only to export the entire XML tree to a file stream on disk
    def outputFile( self, _outfileName ):
        outfile = open( _outfileName, "w" )
        outfile.write("<?xml version=\"1.0\" ?>\n")
        self.export( outfile, 0, name_='dna_context_response' )
        outfile.close()


    #Only to export the entire XML tree to a Html Page in a file stream on disk
    def outputPageHtml( self, _outfileName ):
        odtStrTitle = "    <span class=\"title\">dna_context_response:</span> <br> <br> <br>\n" 
        outfile = open( _outfileName, "w" )
        outfile.write( TEMPLATE_PAGE_P1 % ( odtStrTitle ) )
        self.exportLiteralHtml( outfile, 0, name_='dna_context_response' )
        outfile.write( TEMPLATE_PAGE_P2  )
        outfile.close()


    def outputFileHtml( self, _outfileName ):
        self.outputPageHtml( _outfileName )



    #Static method for parsing a string
    def parseString( _inString ):
        doc = minidom.parseString(_inString)
        rootNode = doc.documentElement
        rootObj = dna_context_response.factory()
        rootObj.build(rootNode)
        return rootObj
    parseString = staticmethod( parseString ) 


    #Method for marshalling an object
    def marshal( self ):
        oStreamString = StringIO.StringIO()
        oStreamString.write('<?xml version="1.0" ?>\n')
        self.export( oStreamString, 0, name_="dna_context_response" )
        oStringXML = oStreamString.getvalue()
        oStreamString.close()
        return oStringXML

    def exportLiteral(self, outfile, level = 0, name_='dna_context_response'):
        level += 1
        self.exportLiteralAttributes(outfile, level, name_)
        self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.dna_context:
            showIndent(outfile, level)
            outfile.write('dna_context = dna_context(\n')
            self.dna_context.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.status:
            showIndent(outfile, level)
            outfile.write('status = status(\n')
            self.status.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
    def exportLiteralHtml(self, outfile, level = 0, name_='dna_context_response'):
        level += 1
        self.exportLiteralAttributesHtml(outfile, level, name_)
        self.exportLiteralChildrenHtml(outfile, level, name_)
    def exportLiteralAttributesHtml(self, outfile, level, name_):
        pass
    def exportLiteralChildrenHtml(self, outfile, level, name_):
        if self.dna_context:
            showIndentHtml(outfile, level)
            outfile.write('dna_context<br>\n')
            self.dna_context.exportLiteralHtml(outfile, level)
            showIndentHtml(outfile, level)
            outfile.write('<br>\n')
        if self.status:
            showIndentHtml(outfile, level)
            outfile.write('status<br>\n')
            self.status.exportLiteralHtml(outfile, level)
            showIndentHtml(outfile, level)
            outfile.write('<br>\n')
    def build(self, node_):
        attrs = node_.attributes
        self.buildAttributes(attrs)
        for child_ in node_.childNodes:
            nodeName_ = child_.nodeName.split(':')[-1]
            self.buildChildren(child_, nodeName_)
    def buildAttributes(self, attrs):
        pass
    def buildChildren(self, child_, nodeName_):
        if child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'dna_context':
            obj_ = dna_context.factory()
            obj_.build(child_)
            self.setDna_context(obj_)
        elif child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'status':
            obj_ = status.factory()
            obj_.build(child_)
            self.setStatus(obj_)
# end class dna_context_response


class mosflm_commands(object):
    subclass = None
    def __init__(self, command=None):
        if command is None:
            self.command = []
        else:
            self.command = command
    def factory(*args_, **kwargs_):
        if mosflm_commands.subclass:
            return mosflm_commands.subclass(*args_, **kwargs_)
        else:
            return mosflm_commands(*args_, **kwargs_)
    factory = staticmethod(factory)
    def getCommand(self): return self.command
    def setCommand(self, command): self.command = command
    def addCommand(self, value): self.command.append(value)
    def insertCommand(self, index, value): self.command[index] = value
    def export(self, outfile, level = 0, name_='mosflm_commands'):
        showIndent(outfile, level)
        outfile.write('<%s>\n' % name_)
        self.exportChildren(outfile, level + 1, name_)
        showIndent(outfile, level)
        outfile.write('</%s>\n' % name_)
    def exportAttributes(self, outfile, level, name_='mosflm_commands'):
        pass
    def exportChildren(self, outfile, level, name_='mosflm_commands'):
        for command_ in self.getCommand():
            showIndent(outfile, level)
            outfile.write('<command>%s</command>\n' % quote_xml(command_))

    #Only to export the entire XML tree to a file stream on disk
    def outputFile( self, _outfileName ):
        outfile = open( _outfileName, "w" )
        outfile.write("<?xml version=\"1.0\" ?>\n")
        self.export( outfile, 0, name_='mosflm_commands' )
        outfile.close()


    #Only to export the entire XML tree to a Html Page in a file stream on disk
    def outputPageHtml( self, _outfileName ):
        odtStrTitle = "    <span class=\"title\">mosflm_commands:</span> <br> <br> <br>\n" 
        outfile = open( _outfileName, "w" )
        outfile.write( TEMPLATE_PAGE_P1 % ( odtStrTitle ) )
        self.exportLiteralHtml( outfile, 0, name_='mosflm_commands' )
        outfile.write( TEMPLATE_PAGE_P2  )
        outfile.close()


    def outputFileHtml( self, _outfileName ):
        self.outputPageHtml( _outfileName )



    #Static method for parsing a string
    def parseString( _inString ):
        doc = minidom.parseString(_inString)
        rootNode = doc.documentElement
        rootObj = mosflm_commands.factory()
        rootObj.build(rootNode)
        return rootObj
    parseString = staticmethod( parseString ) 


    #Method for marshalling an object
    def marshal( self ):
        oStreamString = StringIO.StringIO()
        oStreamString.write('<?xml version="1.0" ?>\n')
        self.export( oStreamString, 0, name_="mosflm_commands" )
        oStringXML = oStreamString.getvalue()
        oStreamString.close()
        return oStringXML

    def exportLiteral(self, outfile, level = 0, name_='mosflm_commands'):
        level += 1
        self.exportLiteralAttributes(outfile, level, name_)
        self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('command=[\n')
        level += 1
        for command in self.command:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(command))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def exportLiteralHtml(self, outfile, level = 0, name_='mosflm_commands'):
        level += 1
        self.exportLiteralAttributesHtml(outfile, level, name_)
        self.exportLiteralChildrenHtml(outfile, level, name_)
    def exportLiteralAttributesHtml(self, outfile, level, name_):
        pass
    def exportLiteralChildrenHtml(self, outfile, level, name_):
        showIndentHtml(outfile, level)
        outfile.write('command<br>\n')
        level += 1
        for command in self.command:
            showIndentHtml(outfile, level)
            outfile.write('<a  href:"#">%s</a><br>\n' % quote_python(command))
        level -= 1
        showIndentHtml(outfile, level)
        outfile.write('<br>\n')
    def build(self, node_):
        attrs = node_.attributes
        self.buildAttributes(attrs)
        for child_ in node_.childNodes:
            nodeName_ = child_.nodeName.split(':')[-1]
            self.buildChildren(child_, nodeName_)
    def buildAttributes(self, attrs):
        pass
    def buildChildren(self, child_, nodeName_):
        if child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'command':
            command_ = ''
            for text__content_ in child_.childNodes:
                command_ += text__content_.nodeValue
            self.command.append(command_)
# end class mosflm_commands


class scala_commands(object):
    subclass = None
    def __init__(self, command=None):
        if command is None:
            self.command = []
        else:
            self.command = command
    def factory(*args_, **kwargs_):
        if scala_commands.subclass:
            return scala_commands.subclass(*args_, **kwargs_)
        else:
            return scala_commands(*args_, **kwargs_)
    factory = staticmethod(factory)
    def getCommand(self): return self.command
    def setCommand(self, command): self.command = command
    def addCommand(self, value): self.command.append(value)
    def insertCommand(self, index, value): self.command[index] = value
    def export(self, outfile, level = 0, name_='scala_commands'):
        showIndent(outfile, level)
        outfile.write('<%s>\n' % name_)
        self.exportChildren(outfile, level + 1, name_)
        showIndent(outfile, level)
        outfile.write('</%s>\n' % name_)
    def exportAttributes(self, outfile, level, name_='scala_commands'):
        pass
    def exportChildren(self, outfile, level, name_='scala_commands'):
        for command_ in self.getCommand():
            showIndent(outfile, level)
            outfile.write('<command>%s</command>\n' % quote_xml(command_))

    #Only to export the entire XML tree to a file stream on disk
    def outputFile( self, _outfileName ):
        outfile = open( _outfileName, "w" )
        outfile.write("<?xml version=\"1.0\" ?>\n")
        self.export( outfile, 0, name_='scala_commands' )
        outfile.close()


    #Only to export the entire XML tree to a Html Page in a file stream on disk
    def outputPageHtml( self, _outfileName ):
        odtStrTitle = "    <span class=\"title\">scala_commands:</span> <br> <br> <br>\n" 
        outfile = open( _outfileName, "w" )
        outfile.write( TEMPLATE_PAGE_P1 % ( odtStrTitle ) )
        self.exportLiteralHtml( outfile, 0, name_='scala_commands' )
        outfile.write( TEMPLATE_PAGE_P2  )
        outfile.close()


    def outputFileHtml( self, _outfileName ):
        self.outputPageHtml( _outfileName )



    #Static method for parsing a string
    def parseString( _inString ):
        doc = minidom.parseString(_inString)
        rootNode = doc.documentElement
        rootObj = scala_commands.factory()
        rootObj.build(rootNode)
        return rootObj
    parseString = staticmethod( parseString ) 


    #Method for marshalling an object
    def marshal( self ):
        oStreamString = StringIO.StringIO()
        oStreamString.write('<?xml version="1.0" ?>\n')
        self.export( oStreamString, 0, name_="scala_commands" )
        oStringXML = oStreamString.getvalue()
        oStreamString.close()
        return oStringXML

    def exportLiteral(self, outfile, level = 0, name_='scala_commands'):
        level += 1
        self.exportLiteralAttributes(outfile, level, name_)
        self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('command=[\n')
        level += 1
        for command in self.command:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(command))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def exportLiteralHtml(self, outfile, level = 0, name_='scala_commands'):
        level += 1
        self.exportLiteralAttributesHtml(outfile, level, name_)
        self.exportLiteralChildrenHtml(outfile, level, name_)
    def exportLiteralAttributesHtml(self, outfile, level, name_):
        pass
    def exportLiteralChildrenHtml(self, outfile, level, name_):
        showIndentHtml(outfile, level)
        outfile.write('command<br>\n')
        level += 1
        for command in self.command:
            showIndentHtml(outfile, level)
            outfile.write('<a  href:"#">%s</a><br>\n' % quote_python(command))
        level -= 1
        showIndentHtml(outfile, level)
        outfile.write('<br>\n')
    def build(self, node_):
        attrs = node_.attributes
        self.buildAttributes(attrs)
        for child_ in node_.childNodes:
            nodeName_ = child_.nodeName.split(':')[-1]
            self.buildChildren(child_, nodeName_)
    def buildAttributes(self, attrs):
        pass
    def buildChildren(self, child_, nodeName_):
        if child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'command':
            command_ = ''
            for text__content_ in child_.childNodes:
                command_ += text__content_.nodeValue
            self.command.append(command_)
# end class scala_commands


class xds_commands(object):
    subclass = None
    def __init__(self, command=None):
        if command is None:
            self.command = []
        else:
            self.command = command
    def factory(*args_, **kwargs_):
        if xds_commands.subclass:
            return xds_commands.subclass(*args_, **kwargs_)
        else:
            return xds_commands(*args_, **kwargs_)
    factory = staticmethod(factory)
    def getCommand(self): return self.command
    def setCommand(self, command): self.command = command
    def addCommand(self, value): self.command.append(value)
    def insertCommand(self, index, value): self.command[index] = value
    def export(self, outfile, level = 0, name_='xds_commands'):
        showIndent(outfile, level)
        outfile.write('<%s>\n' % name_)
        self.exportChildren(outfile, level + 1, name_)
        showIndent(outfile, level)
        outfile.write('</%s>\n' % name_)
    def exportAttributes(self, outfile, level, name_='xds_commands'):
        pass
    def exportChildren(self, outfile, level, name_='xds_commands'):
        for command_ in self.getCommand():
            showIndent(outfile, level)
            outfile.write('<command>%s</command>\n' % quote_xml(command_))

    #Only to export the entire XML tree to a file stream on disk
    def outputFile( self, _outfileName ):
        outfile = open( _outfileName, "w" )
        outfile.write("<?xml version=\"1.0\" ?>\n")
        self.export( outfile, 0, name_='xds_commands' )
        outfile.close()


    #Only to export the entire XML tree to a Html Page in a file stream on disk
    def outputPageHtml( self, _outfileName ):
        odtStrTitle = "    <span class=\"title\">xds_commands:</span> <br> <br> <br>\n" 
        outfile = open( _outfileName, "w" )
        outfile.write( TEMPLATE_PAGE_P1 % ( odtStrTitle ) )
        self.exportLiteralHtml( outfile, 0, name_='xds_commands' )
        outfile.write( TEMPLATE_PAGE_P2  )
        outfile.close()


    def outputFileHtml( self, _outfileName ):
        self.outputPageHtml( _outfileName )



    #Static method for parsing a string
    def parseString( _inString ):
        doc = minidom.parseString(_inString)
        rootNode = doc.documentElement
        rootObj = xds_commands.factory()
        rootObj.build(rootNode)
        return rootObj
    parseString = staticmethod( parseString ) 


    #Method for marshalling an object
    def marshal( self ):
        oStreamString = StringIO.StringIO()
        oStreamString.write('<?xml version="1.0" ?>\n')
        self.export( oStreamString, 0, name_="xds_commands" )
        oStringXML = oStreamString.getvalue()
        oStreamString.close()
        return oStringXML

    def exportLiteral(self, outfile, level = 0, name_='xds_commands'):
        level += 1
        self.exportLiteralAttributes(outfile, level, name_)
        self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('command=[\n')
        level += 1
        for command in self.command:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(command))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def exportLiteralHtml(self, outfile, level = 0, name_='xds_commands'):
        level += 1
        self.exportLiteralAttributesHtml(outfile, level, name_)
        self.exportLiteralChildrenHtml(outfile, level, name_)
    def exportLiteralAttributesHtml(self, outfile, level, name_):
        pass
    def exportLiteralChildrenHtml(self, outfile, level, name_):
        showIndentHtml(outfile, level)
        outfile.write('command<br>\n')
        level += 1
        for command in self.command:
            showIndentHtml(outfile, level)
            outfile.write('<a  href:"#">%s</a><br>\n' % quote_python(command))
        level -= 1
        showIndentHtml(outfile, level)
        outfile.write('<br>\n')
    def build(self, node_):
        attrs = node_.attributes
        self.buildAttributes(attrs)
        for child_ in node_.childNodes:
            nodeName_ = child_.nodeName.split(':')[-1]
            self.buildChildren(child_, nodeName_)
    def buildAttributes(self, attrs):
        pass
    def buildChildren(self, child_, nodeName_):
        if child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'command':
            command_ = ''
            for text__content_ in child_.childNodes:
                command_ += text__content_.nodeValue
            self.command.append(command_)
# end class xds_commands


class extra_commands(object):
    subclass = None
    def __init__(self, mosflm_commands=None, scala_commands=None, xds_commands=None):
        self.mosflm_commands = mosflm_commands
        self.scala_commands = scala_commands
        self.xds_commands = xds_commands
    def factory(*args_, **kwargs_):
        if extra_commands.subclass:
            return extra_commands.subclass(*args_, **kwargs_)
        else:
            return extra_commands(*args_, **kwargs_)
    factory = staticmethod(factory)
    def getMosflm_commands(self): return self.mosflm_commands
    def setMosflm_commands(self, mosflm_commands): self.mosflm_commands = mosflm_commands
    def getScala_commands(self): return self.scala_commands
    def setScala_commands(self, scala_commands): self.scala_commands = scala_commands
    def getXds_commands(self): return self.xds_commands
    def setXds_commands(self, xds_commands): self.xds_commands = xds_commands
    def export(self, outfile, level = 0, name_='extra_commands'):
        showIndent(outfile, level)
        outfile.write('<%s>\n' % name_)
        self.exportChildren(outfile, level + 1, name_)
        showIndent(outfile, level)
        outfile.write('</%s>\n' % name_)
    def exportAttributes(self, outfile, level, name_='extra_commands'):
        pass
    def exportChildren(self, outfile, level, name_='extra_commands'):
        if self.mosflm_commands:
            self.mosflm_commands.export(outfile, level)
        if self.scala_commands:
            self.scala_commands.export(outfile, level)
        if self.xds_commands:
            self.xds_commands.export(outfile, level)

    #Only to export the entire XML tree to a file stream on disk
    def outputFile( self, _outfileName ):
        outfile = open( _outfileName, "w" )
        outfile.write("<?xml version=\"1.0\" ?>\n")
        self.export( outfile, 0, name_='extra_commands' )
        outfile.close()


    #Only to export the entire XML tree to a Html Page in a file stream on disk
    def outputPageHtml( self, _outfileName ):
        odtStrTitle = "    <span class=\"title\">extra_commands:</span> <br> <br> <br>\n" 
        outfile = open( _outfileName, "w" )
        outfile.write( TEMPLATE_PAGE_P1 % ( odtStrTitle ) )
        self.exportLiteralHtml( outfile, 0, name_='extra_commands' )
        outfile.write( TEMPLATE_PAGE_P2  )
        outfile.close()


    def outputFileHtml( self, _outfileName ):
        self.outputPageHtml( _outfileName )



    #Static method for parsing a string
    def parseString( _inString ):
        doc = minidom.parseString(_inString)
        rootNode = doc.documentElement
        rootObj = extra_commands.factory()
        rootObj.build(rootNode)
        return rootObj
    parseString = staticmethod( parseString ) 


    #Method for marshalling an object
    def marshal( self ):
        oStreamString = StringIO.StringIO()
        oStreamString.write('<?xml version="1.0" ?>\n')
        self.export( oStreamString, 0, name_="extra_commands" )
        oStringXML = oStreamString.getvalue()
        oStreamString.close()
        return oStringXML

    def exportLiteral(self, outfile, level = 0, name_='extra_commands'):
        level += 1
        self.exportLiteralAttributes(outfile, level, name_)
        self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.mosflm_commands:
            showIndent(outfile, level)
            outfile.write('mosflm_commands = mosflm_commands(\n')
            self.mosflm_commands.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.scala_commands:
            showIndent(outfile, level)
            outfile.write('scala_commands = scala_commands(\n')
            self.scala_commands.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.xds_commands:
            showIndent(outfile, level)
            outfile.write('xds_commands = xds_commands(\n')
            self.xds_commands.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
    def exportLiteralHtml(self, outfile, level = 0, name_='extra_commands'):
        level += 1
        self.exportLiteralAttributesHtml(outfile, level, name_)
        self.exportLiteralChildrenHtml(outfile, level, name_)
    def exportLiteralAttributesHtml(self, outfile, level, name_):
        pass
    def exportLiteralChildrenHtml(self, outfile, level, name_):
        if self.mosflm_commands:
            showIndentHtml(outfile, level)
            outfile.write('mosflm_commands<br>\n')
            self.mosflm_commands.exportLiteralHtml(outfile, level)
            showIndentHtml(outfile, level)
            outfile.write('<br>\n')
        if self.scala_commands:
            showIndentHtml(outfile, level)
            outfile.write('scala_commands<br>\n')
            self.scala_commands.exportLiteralHtml(outfile, level)
            showIndentHtml(outfile, level)
            outfile.write('<br>\n')
        if self.xds_commands:
            showIndentHtml(outfile, level)
            outfile.write('xds_commands<br>\n')
            self.xds_commands.exportLiteralHtml(outfile, level)
            showIndentHtml(outfile, level)
            outfile.write('<br>\n')
    def build(self, node_):
        attrs = node_.attributes
        self.buildAttributes(attrs)
        for child_ in node_.childNodes:
            nodeName_ = child_.nodeName.split(':')[-1]
            self.buildChildren(child_, nodeName_)
    def buildAttributes(self, attrs):
        pass
    def buildChildren(self, child_, nodeName_):
        if child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'mosflm_commands':
            obj_ = mosflm_commands.factory()
            obj_.build(child_)
            self.setMosflm_commands(obj_)
        elif child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'scala_commands':
            obj_ = scala_commands.factory()
            obj_.build(child_)
            self.setScala_commands(obj_)
        elif child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'xds_commands':
            obj_ = xds_commands.factory()
            obj_.build(child_)
            self.setXds_commands(obj_)
# end class extra_commands


class status(object):
    subclass = None
    def __init__(self, code='', message=''):
        self.code = code
        self.message = message
    def factory(*args_, **kwargs_):
        if status.subclass:
            return status.subclass(*args_, **kwargs_)
        else:
            return status(*args_, **kwargs_)
    factory = staticmethod(factory)
    def getCode(self): return self.code
    def setCode(self, code): self.code = code
    def getMessage(self): return self.message
    def setMessage(self, message): self.message = message
    def export(self, outfile, level = 0, name_='status'):
        showIndent(outfile, level)
        outfile.write('<%s>\n' % name_)
        self.exportChildren(outfile, level + 1, name_)
        showIndent(outfile, level)
        outfile.write('</%s>\n' % name_)
    def exportAttributes(self, outfile, level, name_='status'):
        pass
    def exportChildren(self, outfile, level, name_='status'):
        showIndent(outfile, level)
        outfile.write('<code>%s</code>\n' % quote_xml(self.getCode()))
        showIndent(outfile, level)
        outfile.write('<message>%s</message>\n' % quote_xml(self.getMessage()))

    #Only to export the entire XML tree to a file stream on disk
    def outputFile( self, _outfileName ):
        outfile = open( _outfileName, "w" )
        outfile.write("<?xml version=\"1.0\" ?>\n")
        self.export( outfile, 0, name_='status' )
        outfile.close()


    #Only to export the entire XML tree to a Html Page in a file stream on disk
    def outputPageHtml( self, _outfileName ):
        odtStrTitle = "    <span class=\"title\">status:</span> <br> <br> <br>\n" 
        outfile = open( _outfileName, "w" )
        outfile.write( TEMPLATE_PAGE_P1 % ( odtStrTitle ) )
        self.exportLiteralHtml( outfile, 0, name_='status' )
        outfile.write( TEMPLATE_PAGE_P2  )
        outfile.close()


    def outputFileHtml( self, _outfileName ):
        self.outputPageHtml( _outfileName )



    #Static method for parsing a string
    def parseString( _inString ):
        doc = minidom.parseString(_inString)
        rootNode = doc.documentElement
        rootObj = status.factory()
        rootObj.build(rootNode)
        return rootObj
    parseString = staticmethod( parseString ) 


    #Method for marshalling an object
    def marshal( self ):
        oStreamString = StringIO.StringIO()
        oStreamString.write('<?xml version="1.0" ?>\n')
        self.export( oStreamString, 0, name_="status" )
        oStringXML = oStreamString.getvalue()
        oStreamString.close()
        return oStringXML

    def exportLiteral(self, outfile, level = 0, name_='status'):
        level += 1
        self.exportLiteralAttributes(outfile, level, name_)
        self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('code = %s,\n' % quote_python(self.getCode()))
        showIndent(outfile, level)
        outfile.write('message = %s,\n' % quote_python(self.getMessage()))
    def exportLiteralHtml(self, outfile, level = 0, name_='status'):
        level += 1
        self.exportLiteralAttributesHtml(outfile, level, name_)
        self.exportLiteralChildrenHtml(outfile, level, name_)
    def exportLiteralAttributesHtml(self, outfile, level, name_):
        pass
    def exportLiteralChildrenHtml(self, outfile, level, name_):
        showIndentHtml(outfile, level)
        outfile.write('code = <a  href:"#">%s</a><br>\n' % quote_python(self.getCode()))
        showIndentHtml(outfile, level)
        outfile.write('message = <a  href:"#">%s</a><br>\n' % quote_python(self.getMessage()))
    def build(self, node_):
        attrs = node_.attributes
        self.buildAttributes(attrs)
        for child_ in node_.childNodes:
            nodeName_ = child_.nodeName.split(':')[-1]
            self.buildChildren(child_, nodeName_)
    def buildAttributes(self, attrs):
        pass
    def buildChildren(self, child_, nodeName_):
        if child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'code':
            code_ = ''
            for text__content_ in child_.childNodes:
                code_ += text__content_.nodeValue
            self.code = code_
        elif child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'message':
            message_ = ''
            for text__content_ in child_.childNodes:
                message_ += text__content_.nodeValue
            self.message = message_
# end class status


class fileinfo(object):
    subclass = None
    def __init__(self, directory='', prefix='', suffix='', template='', run_number=''):
        self.directory = directory
        self.prefix = prefix
        self.suffix = suffix
        self.template = template
        self.run_number = run_number
    def factory(*args_, **kwargs_):
        if fileinfo.subclass:
            return fileinfo.subclass(*args_, **kwargs_)
        else:
            return fileinfo(*args_, **kwargs_)
    factory = staticmethod(factory)
    def getDirectory(self): return self.directory
    def setDirectory(self, directory): self.directory = directory
    def getPrefix(self): return self.prefix
    def setPrefix(self, prefix): self.prefix = prefix
    def getSuffix(self): return self.suffix
    def setSuffix(self, suffix): self.suffix = suffix
    def getTemplate(self): return self.template
    def setTemplate(self, template): self.template = template
    def getRun_number(self): return self.run_number
    def setRun_number(self, run_number): self.run_number = run_number
    def export(self, outfile, level = 0, name_='fileinfo'):
        showIndent(outfile, level)
        outfile.write('<%s>\n' % name_)
        self.exportChildren(outfile, level + 1, name_)
        showIndent(outfile, level)
        outfile.write('</%s>\n' % name_)
    def exportAttributes(self, outfile, level, name_='fileinfo'):
        pass
    def exportChildren(self, outfile, level, name_='fileinfo'):
        showIndent(outfile, level)
        outfile.write('<directory>%s</directory>\n' % quote_xml(self.getDirectory()))
        showIndent(outfile, level)
        outfile.write('<prefix>%s</prefix>\n' % quote_xml(self.getPrefix()))
        showIndent(outfile, level)
        outfile.write('<suffix>%s</suffix>\n' % quote_xml(self.getSuffix()))
        showIndent(outfile, level)
        outfile.write('<template>%s</template>\n' % quote_xml(self.getTemplate()))
        showIndent(outfile, level)
        outfile.write('<run_number>%s</run_number>\n' % quote_xml(self.getRun_number()))

    #Only to export the entire XML tree to a file stream on disk
    def outputFile( self, _outfileName ):
        outfile = open( _outfileName, "w" )
        outfile.write("<?xml version=\"1.0\" ?>\n")
        self.export( outfile, 0, name_='fileinfo' )
        outfile.close()


    #Only to export the entire XML tree to a Html Page in a file stream on disk
    def outputPageHtml( self, _outfileName ):
        odtStrTitle = "    <span class=\"title\">fileinfo:</span> <br> <br> <br>\n" 
        outfile = open( _outfileName, "w" )
        outfile.write( TEMPLATE_PAGE_P1 % ( odtStrTitle ) )
        self.exportLiteralHtml( outfile, 0, name_='fileinfo' )
        outfile.write( TEMPLATE_PAGE_P2  )
        outfile.close()


    def outputFileHtml( self, _outfileName ):
        self.outputPageHtml( _outfileName )



    #Static method for parsing a string
    def parseString( _inString ):
        doc = minidom.parseString(_inString)
        rootNode = doc.documentElement
        rootObj = fileinfo.factory()
        rootObj.build(rootNode)
        return rootObj
    parseString = staticmethod( parseString ) 


    #Method for marshalling an object
    def marshal( self ):
        oStreamString = StringIO.StringIO()
        oStreamString.write('<?xml version="1.0" ?>\n')
        self.export( oStreamString, 0, name_="fileinfo" )
        oStringXML = oStreamString.getvalue()
        oStreamString.close()
        return oStringXML

    def exportLiteral(self, outfile, level = 0, name_='fileinfo'):
        level += 1
        self.exportLiteralAttributes(outfile, level, name_)
        self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('directory = %s,\n' % quote_python(self.getDirectory()))
        showIndent(outfile, level)
        outfile.write('prefix = %s,\n' % quote_python(self.getPrefix()))
        showIndent(outfile, level)
        outfile.write('suffix = %s,\n' % quote_python(self.getSuffix()))
        showIndent(outfile, level)
        outfile.write('template = %s,\n' % quote_python(self.getTemplate()))
        showIndent(outfile, level)
        outfile.write('run_number = %s,\n' % quote_python(self.getRun_number()))
    def exportLiteralHtml(self, outfile, level = 0, name_='fileinfo'):
        level += 1
        self.exportLiteralAttributesHtml(outfile, level, name_)
        self.exportLiteralChildrenHtml(outfile, level, name_)
    def exportLiteralAttributesHtml(self, outfile, level, name_):
        pass
    def exportLiteralChildrenHtml(self, outfile, level, name_):
        showIndentHtml(outfile, level)
        outfile.write('directory = <a  href:"#">%s</a><br>\n' % quote_python(self.getDirectory()))
        showIndentHtml(outfile, level)
        outfile.write('prefix = <a  href:"#">%s</a><br>\n' % quote_python(self.getPrefix()))
        showIndentHtml(outfile, level)
        outfile.write('suffix = <a  href:"#">%s</a><br>\n' % quote_python(self.getSuffix()))
        showIndentHtml(outfile, level)
        outfile.write('template = <a  href:"#">%s</a><br>\n' % quote_python(self.getTemplate()))
        showIndentHtml(outfile, level)
        outfile.write('run_number = <a  href:"#">%s</a><br>\n' % quote_python(self.getRun_number()))
    def build(self, node_):
        attrs = node_.attributes
        self.buildAttributes(attrs)
        for child_ in node_.childNodes:
            nodeName_ = child_.nodeName.split(':')[-1]
            self.buildChildren(child_, nodeName_)
    def buildAttributes(self, attrs):
        pass
    def buildChildren(self, child_, nodeName_):
        if child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'directory':
            directory_ = ''
            for text__content_ in child_.childNodes:
                directory_ += text__content_.nodeValue
            self.directory = directory_
        elif child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'prefix':
            prefix_ = ''
            for text__content_ in child_.childNodes:
                prefix_ += text__content_.nodeValue
            self.prefix = prefix_
        elif child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'suffix':
            suffix_ = ''
            for text__content_ in child_.childNodes:
                suffix_ += text__content_.nodeValue
            self.suffix = suffix_
        elif child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'template':
            template_ = ''
            for text__content_ in child_.childNodes:
                template_ += text__content_.nodeValue
            self.template = template_
        elif child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'run_number':
            run_number_ = ''
            for text__content_ in child_.childNodes:
                run_number_ += text__content_.nodeValue
            self.run_number = run_number_
# end class fileinfo


class oscillation_sequence(object):
    subclass = None
    def __init__(self, start=0.0, end=0.0, range=0.0, number_of_images='', overlap=0.0, exposure_time=0.0, start_image_number='', number_of_passes=''):
        self.start = start
        self.end = end
        self.range = range
        self.number_of_images = number_of_images
        self.overlap = overlap
        self.exposure_time = exposure_time
        self.start_image_number = start_image_number
        self.number_of_passes = number_of_passes
    def factory(*args_, **kwargs_):
        if oscillation_sequence.subclass:
            return oscillation_sequence.subclass(*args_, **kwargs_)
        else:
            return oscillation_sequence(*args_, **kwargs_)
    factory = staticmethod(factory)
    def getStart(self): return self.start
    def setStart(self, start): self.start = start
    def getEnd(self): return self.end
    def setEnd(self, end): self.end = end
    def getRange(self): return self.range
    def setRange(self, range): self.range = range
    def getNumber_of_images(self): return self.number_of_images
    def setNumber_of_images(self, number_of_images): self.number_of_images = number_of_images
    def getOverlap(self): return self.overlap
    def setOverlap(self, overlap): self.overlap = overlap
    def getExposure_time(self): return self.exposure_time
    def setExposure_time(self, exposure_time): self.exposure_time = exposure_time
    def getStart_image_number(self): return self.start_image_number
    def setStart_image_number(self, start_image_number): self.start_image_number = start_image_number
    def getNumber_of_passes(self): return self.number_of_passes
    def setNumber_of_passes(self, number_of_passes): self.number_of_passes = number_of_passes
    def export(self, outfile, level = 0, name_='oscillation_sequence'):
        showIndent(outfile, level)
        outfile.write('<%s>\n' % name_)
        self.exportChildren(outfile, level + 1, name_)
        showIndent(outfile, level)
        outfile.write('</%s>\n' % name_)
    def exportAttributes(self, outfile, level, name_='oscillation_sequence'):
        pass
    def exportChildren(self, outfile, level, name_='oscillation_sequence'):
        showIndent(outfile, level)
        outfile.write('<start>%e</start>\n' % self.getStart())
        showIndent(outfile, level)
        outfile.write('<end>%e</end>\n' % self.getEnd())
        showIndent(outfile, level)
        outfile.write('<range>%e</range>\n' % self.getRange())
        showIndent(outfile, level)
        outfile.write('<number_of_images>%s</number_of_images>\n' % quote_xml(self.getNumber_of_images()))
        showIndent(outfile, level)
        outfile.write('<overlap>%e</overlap>\n' % self.getOverlap())
        showIndent(outfile, level)
        outfile.write('<exposure_time>%e</exposure_time>\n' % self.getExposure_time())
        showIndent(outfile, level)
        outfile.write('<start_image_number>%s</start_image_number>\n' % quote_xml(self.getStart_image_number()))
        showIndent(outfile, level)
        outfile.write('<number_of_passes>%s</number_of_passes>\n' % quote_xml(self.getNumber_of_passes()))

    #Only to export the entire XML tree to a file stream on disk
    def outputFile( self, _outfileName ):
        outfile = open( _outfileName, "w" )
        outfile.write("<?xml version=\"1.0\" ?>\n")
        self.export( outfile, 0, name_='oscillation_sequence' )
        outfile.close()


    #Only to export the entire XML tree to a Html Page in a file stream on disk
    def outputPageHtml( self, _outfileName ):
        odtStrTitle = "    <span class=\"title\">oscillation_sequence:</span> <br> <br> <br>\n" 
        outfile = open( _outfileName, "w" )
        outfile.write( TEMPLATE_PAGE_P1 % ( odtStrTitle ) )
        self.exportLiteralHtml( outfile, 0, name_='oscillation_sequence' )
        outfile.write( TEMPLATE_PAGE_P2  )
        outfile.close()


    def outputFileHtml( self, _outfileName ):
        self.outputPageHtml( _outfileName )



    #Static method for parsing a string
    def parseString( _inString ):
        doc = minidom.parseString(_inString)
        rootNode = doc.documentElement
        rootObj = oscillation_sequence.factory()
        rootObj.build(rootNode)
        return rootObj
    parseString = staticmethod( parseString ) 


    #Method for marshalling an object
    def marshal( self ):
        oStreamString = StringIO.StringIO()
        oStreamString.write('<?xml version="1.0" ?>\n')
        self.export( oStreamString, 0, name_="oscillation_sequence" )
        oStringXML = oStreamString.getvalue()
        oStreamString.close()
        return oStringXML

    def exportLiteral(self, outfile, level = 0, name_='oscillation_sequence'):
        level += 1
        self.exportLiteralAttributes(outfile, level, name_)
        self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('start = %e,\n' % self.getStart())
        showIndent(outfile, level)
        outfile.write('end = %e,\n' % self.getEnd())
        showIndent(outfile, level)
        outfile.write('range = %e,\n' % self.getRange())
        showIndent(outfile, level)
        outfile.write('number_of_images = %s,\n' % quote_python(self.getNumber_of_images()))
        showIndent(outfile, level)
        outfile.write('overlap = %e,\n' % self.getOverlap())
        showIndent(outfile, level)
        outfile.write('exposure_time = %e,\n' % self.getExposure_time())
        showIndent(outfile, level)
        outfile.write('start_image_number = %s,\n' % quote_python(self.getStart_image_number()))
        showIndent(outfile, level)
        outfile.write('number_of_passes = %s,\n' % quote_python(self.getNumber_of_passes()))
    def exportLiteralHtml(self, outfile, level = 0, name_='oscillation_sequence'):
        level += 1
        self.exportLiteralAttributesHtml(outfile, level, name_)
        self.exportLiteralChildrenHtml(outfile, level, name_)
    def exportLiteralAttributesHtml(self, outfile, level, name_):
        pass
    def exportLiteralChildrenHtml(self, outfile, level, name_):
        showIndentHtml(outfile, level)
        outfile.write('start = <a  href:"#">%e</a><br>\n' % self.getStart())
        showIndentHtml(outfile, level)
        outfile.write('end = <a  href:"#">%e</a><br>\n' % self.getEnd())
        showIndentHtml(outfile, level)
        outfile.write('range = <a  href:"#">%e</a><br>\n' % self.getRange())
        showIndentHtml(outfile, level)
        outfile.write('number_of_images = <a  href:"#">%s</a><br>\n' % quote_python(self.getNumber_of_images()))
        showIndentHtml(outfile, level)
        outfile.write('overlap = <a  href:"#">%e</a><br>\n' % self.getOverlap())
        showIndentHtml(outfile, level)
        outfile.write('exposure_time = <a  href:"#">%e</a><br>\n' % self.getExposure_time())
        showIndentHtml(outfile, level)
        outfile.write('start_image_number = <a  href:"#">%s</a><br>\n' % quote_python(self.getStart_image_number()))
        showIndentHtml(outfile, level)
        outfile.write('number_of_passes = <a  href:"#">%s</a><br>\n' % quote_python(self.getNumber_of_passes()))
    def build(self, node_):
        attrs = node_.attributes
        self.buildAttributes(attrs)
        for child_ in node_.childNodes:
            nodeName_ = child_.nodeName.split(':')[-1]
            self.buildChildren(child_, nodeName_)
    def buildAttributes(self, attrs):
        pass
    def buildChildren(self, child_, nodeName_):
        if child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'start':
            if child_.firstChild:
                sval_ = child_.firstChild.nodeValue
                try:
                    fval_ = float(sval_)
                except ValueError:
                    raise ValueError('requires float (or double) -- %s' % child_.toxml())
                self.start = fval_
        elif child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'end':
            if child_.firstChild:
                sval_ = child_.firstChild.nodeValue
                try:
                    fval_ = float(sval_)
                except ValueError:
                    raise ValueError('requires float (or double) -- %s' % child_.toxml())
                self.end = fval_
        elif child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'range':
            if child_.firstChild:
                sval_ = child_.firstChild.nodeValue
                try:
                    fval_ = float(sval_)
                except ValueError:
                    raise ValueError('requires float (or double) -- %s' % child_.toxml())
                self.range = fval_
        elif child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'number_of_images':
            number_of_images_ = ''
            for text__content_ in child_.childNodes:
                number_of_images_ += text__content_.nodeValue
            self.number_of_images = number_of_images_
        elif child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'overlap':
            if child_.firstChild:
                sval_ = child_.firstChild.nodeValue
                try:
                    fval_ = float(sval_)
                except ValueError:
                    raise ValueError('requires float (or double) -- %s' % child_.toxml())
                self.overlap = fval_
        elif child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'exposure_time':
            if child_.firstChild:
                sval_ = child_.firstChild.nodeValue
                try:
                    fval_ = float(sval_)
                except ValueError:
                    raise ValueError('requires float (or double) -- %s' % child_.toxml())
                self.exposure_time = fval_
        elif child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'start_image_number':
            start_image_number_ = ''
            for text__content_ in child_.childNodes:
                start_image_number_ += text__content_.nodeValue
            self.start_image_number = start_image_number_
        elif child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'number_of_passes':
            number_of_passes_ = ''
            for text__content_ in child_.childNodes:
                number_of_passes_ += text__content_.nodeValue
            self.number_of_passes = number_of_passes_
# end class oscillation_sequence


class detector(object):
    subclass = None
    def __init__(self, ttype='', suffix=''):
        self.ttype = ttype
        self.suffix = suffix
    def factory(*args_, **kwargs_):
        if detector.subclass:
            return detector.subclass(*args_, **kwargs_)
        else:
            return detector(*args_, **kwargs_)
    factory = staticmethod(factory)
    def getType(self): return self.ttype
    def setType(self, ttype): self.ttype = ttype
    def getSuffix(self): return self.suffix
    def setSuffix(self, suffix): self.suffix = suffix
    def export(self, outfile, level = 0, name_='detector'):
        showIndent(outfile, level)
        outfile.write('<%s>\n' % name_)
        self.exportChildren(outfile, level + 1, name_)
        showIndent(outfile, level)
        outfile.write('</%s>\n' % name_)
    def exportAttributes(self, outfile, level, name_='detector'):
        pass
    def exportChildren(self, outfile, level, name_='detector'):
        showIndent(outfile, level)
        outfile.write('<type>%s</type>\n' % quote_xml(self.getType()))
        showIndent(outfile, level)
        outfile.write('<suffix>%s</suffix>\n' % quote_xml(self.getSuffix()))

    #Only to export the entire XML tree to a file stream on disk
    def outputFile( self, _outfileName ):
        outfile = open( _outfileName, "w" )
        outfile.write("<?xml version=\"1.0\" ?>\n")
        self.export( outfile, 0, name_='detector' )
        outfile.close()


    #Only to export the entire XML tree to a Html Page in a file stream on disk
    def outputPageHtml( self, _outfileName ):
        odtStrTitle = "    <span class=\"title\">detector:</span> <br> <br> <br>\n" 
        outfile = open( _outfileName, "w" )
        outfile.write( TEMPLATE_PAGE_P1 % ( odtStrTitle ) )
        self.exportLiteralHtml( outfile, 0, name_='detector' )
        outfile.write( TEMPLATE_PAGE_P2  )
        outfile.close()


    def outputFileHtml( self, _outfileName ):
        self.outputPageHtml( _outfileName )



    #Static method for parsing a string
    def parseString( _inString ):
        doc = minidom.parseString(_inString)
        rootNode = doc.documentElement
        rootObj = detector.factory()
        rootObj.build(rootNode)
        return rootObj
    parseString = staticmethod( parseString ) 


    #Method for marshalling an object
    def marshal( self ):
        oStreamString = StringIO.StringIO()
        oStreamString.write('<?xml version="1.0" ?>\n')
        self.export( oStreamString, 0, name_="detector" )
        oStringXML = oStreamString.getvalue()
        oStreamString.close()
        return oStringXML

    def exportLiteral(self, outfile, level = 0, name_='detector'):
        level += 1
        self.exportLiteralAttributes(outfile, level, name_)
        self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('ttype = %s,\n' % quote_python(self.getType()))
        showIndent(outfile, level)
        outfile.write('suffix = %s,\n' % quote_python(self.getSuffix()))
    def exportLiteralHtml(self, outfile, level = 0, name_='detector'):
        level += 1
        self.exportLiteralAttributesHtml(outfile, level, name_)
        self.exportLiteralChildrenHtml(outfile, level, name_)
    def exportLiteralAttributesHtml(self, outfile, level, name_):
        pass
    def exportLiteralChildrenHtml(self, outfile, level, name_):
        showIndentHtml(outfile, level)
        outfile.write('ttype = <a  href:"#">%s</a><br>\n' % quote_python(self.getType()))
        showIndentHtml(outfile, level)
        outfile.write('suffix = <a  href:"#">%s</a><br>\n' % quote_python(self.getSuffix()))
    def build(self, node_):
        attrs = node_.attributes
        self.buildAttributes(attrs)
        for child_ in node_.childNodes:
            nodeName_ = child_.nodeName.split(':')[-1]
            self.buildChildren(child_, nodeName_)
    def buildAttributes(self, attrs):
        pass
    def buildChildren(self, child_, nodeName_):
        if child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'type':
            type_ = ''
            for text__content_ in child_.childNodes:
                type_ += text__content_.nodeValue
            self.ttype = type_
        elif child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'suffix':
            suffix_ = ''
            for text__content_ in child_.childNodes:
                suffix_ += text__content_.nodeValue
            self.suffix = suffix_
# end class detector


class beam(object):
    subclass = None
    def __init__(self, x=0.0, y=0.0):
        self.x = x
        self.y = y
    def factory(*args_, **kwargs_):
        if beam.subclass:
            return beam.subclass(*args_, **kwargs_)
        else:
            return beam(*args_, **kwargs_)
    factory = staticmethod(factory)
    def getX(self): return self.x
    def setX(self, x): self.x = x
    def getY(self): return self.y
    def setY(self, y): self.y = y
    def export(self, outfile, level = 0, name_='beam'):
        showIndent(outfile, level)
        outfile.write('<%s>\n' % name_)
        self.exportChildren(outfile, level + 1, name_)
        showIndent(outfile, level)
        outfile.write('</%s>\n' % name_)
    def exportAttributes(self, outfile, level, name_='beam'):
        pass
    def exportChildren(self, outfile, level, name_='beam'):
        showIndent(outfile, level)
        outfile.write('<x>%e</x>\n' % self.getX())
        showIndent(outfile, level)
        outfile.write('<y>%e</y>\n' % self.getY())

    #Only to export the entire XML tree to a file stream on disk
    def outputFile( self, _outfileName ):
        outfile = open( _outfileName, "w" )
        outfile.write("<?xml version=\"1.0\" ?>\n")
        self.export( outfile, 0, name_='beam' )
        outfile.close()


    #Only to export the entire XML tree to a Html Page in a file stream on disk
    def outputPageHtml( self, _outfileName ):
        odtStrTitle = "    <span class=\"title\">beam:</span> <br> <br> <br>\n" 
        outfile = open( _outfileName, "w" )
        outfile.write( TEMPLATE_PAGE_P1 % ( odtStrTitle ) )
        self.exportLiteralHtml( outfile, 0, name_='beam' )
        outfile.write( TEMPLATE_PAGE_P2  )
        outfile.close()


    def outputFileHtml( self, _outfileName ):
        self.outputPageHtml( _outfileName )



    #Static method for parsing a string
    def parseString( _inString ):
        doc = minidom.parseString(_inString)
        rootNode = doc.documentElement
        rootObj = beam.factory()
        rootObj.build(rootNode)
        return rootObj
    parseString = staticmethod( parseString ) 


    #Method for marshalling an object
    def marshal( self ):
        oStreamString = StringIO.StringIO()
        oStreamString.write('<?xml version="1.0" ?>\n')
        self.export( oStreamString, 0, name_="beam" )
        oStringXML = oStreamString.getvalue()
        oStreamString.close()
        return oStringXML

    def exportLiteral(self, outfile, level = 0, name_='beam'):
        level += 1
        self.exportLiteralAttributes(outfile, level, name_)
        self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('x = %e,\n' % self.getX())
        showIndent(outfile, level)
        outfile.write('y = %e,\n' % self.getY())
    def exportLiteralHtml(self, outfile, level = 0, name_='beam'):
        level += 1
        self.exportLiteralAttributesHtml(outfile, level, name_)
        self.exportLiteralChildrenHtml(outfile, level, name_)
    def exportLiteralAttributesHtml(self, outfile, level, name_):
        pass
    def exportLiteralChildrenHtml(self, outfile, level, name_):
        showIndentHtml(outfile, level)
        outfile.write('x = <a  href:"#">%e</a><br>\n' % self.getX())
        showIndentHtml(outfile, level)
        outfile.write('y = <a  href:"#">%e</a><br>\n' % self.getY())
    def build(self, node_):
        attrs = node_.attributes
        self.buildAttributes(attrs)
        for child_ in node_.childNodes:
            nodeName_ = child_.nodeName.split(':')[-1]
            self.buildChildren(child_, nodeName_)
    def buildAttributes(self, attrs):
        pass
    def buildChildren(self, child_, nodeName_):
        if child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'x':
            if child_.firstChild:
                sval_ = child_.firstChild.nodeValue
                try:
                    fval_ = float(sval_)
                except ValueError:
                    raise ValueError('requires float (or double) -- %s' % child_.toxml())
                self.x = fval_
        elif child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'y':
            if child_.firstChild:
                sval_ = child_.firstChild.nodeValue
                try:
                    fval_ = float(sval_)
                except ValueError:
                    raise ValueError('requires float (or double) -- %s' % child_.toxml())
                self.y = fval_
# end class beam


class cell(object):
    subclass = None
    def __init__(self, a=0.0, b=0.0, c=0.0, alpha=0.0, beta=0.0, gamma=0.0):
        self.a = a
        self.b = b
        self.c = c
        self.alpha = alpha
        self.beta = beta
        self.gamma = gamma
    def factory(*args_, **kwargs_):
        if cell.subclass:
            return cell.subclass(*args_, **kwargs_)
        else:
            return cell(*args_, **kwargs_)
    factory = staticmethod(factory)
    def getA(self): return self.a
    def setA(self, a): self.a = a
    def getB(self): return self.b
    def setB(self, b): self.b = b
    def getC(self): return self.c
    def setC(self, c): self.c = c
    def getAlpha(self): return self.alpha
    def setAlpha(self, alpha): self.alpha = alpha
    def getBeta(self): return self.beta
    def setBeta(self, beta): self.beta = beta
    def getGamma(self): return self.gamma
    def setGamma(self, gamma): self.gamma = gamma
    def export(self, outfile, level = 0, name_='cell'):
        showIndent(outfile, level)
        outfile.write('<%s>\n' % name_)
        self.exportChildren(outfile, level + 1, name_)
        showIndent(outfile, level)
        outfile.write('</%s>\n' % name_)
    def exportAttributes(self, outfile, level, name_='cell'):
        pass
    def exportChildren(self, outfile, level, name_='cell'):
        showIndent(outfile, level)
        outfile.write('<a>%e</a>\n' % self.getA())
        showIndent(outfile, level)
        outfile.write('<b>%e</b>\n' % self.getB())
        showIndent(outfile, level)
        outfile.write('<c>%e</c>\n' % self.getC())
        showIndent(outfile, level)
        outfile.write('<alpha>%e</alpha>\n' % self.getAlpha())
        showIndent(outfile, level)
        outfile.write('<beta>%e</beta>\n' % self.getBeta())
        showIndent(outfile, level)
        outfile.write('<gamma>%e</gamma>\n' % self.getGamma())

    #Only to export the entire XML tree to a file stream on disk
    def outputFile( self, _outfileName ):
        outfile = open( _outfileName, "w" )
        outfile.write("<?xml version=\"1.0\" ?>\n")
        self.export( outfile, 0, name_='cell' )
        outfile.close()


    #Only to export the entire XML tree to a Html Page in a file stream on disk
    def outputPageHtml( self, _outfileName ):
        odtStrTitle = "    <span class=\"title\">cell:</span> <br> <br> <br>\n" 
        outfile = open( _outfileName, "w" )
        outfile.write( TEMPLATE_PAGE_P1 % ( odtStrTitle ) )
        self.exportLiteralHtml( outfile, 0, name_='cell' )
        outfile.write( TEMPLATE_PAGE_P2  )
        outfile.close()


    def outputFileHtml( self, _outfileName ):
        self.outputPageHtml( _outfileName )



    #Static method for parsing a string
    def parseString( _inString ):
        doc = minidom.parseString(_inString)
        rootNode = doc.documentElement
        rootObj = cell.factory()
        rootObj.build(rootNode)
        return rootObj
    parseString = staticmethod( parseString ) 


    #Method for marshalling an object
    def marshal( self ):
        oStreamString = StringIO.StringIO()
        oStreamString.write('<?xml version="1.0" ?>\n')
        self.export( oStreamString, 0, name_="cell" )
        oStringXML = oStreamString.getvalue()
        oStreamString.close()
        return oStringXML

    def exportLiteral(self, outfile, level = 0, name_='cell'):
        level += 1
        self.exportLiteralAttributes(outfile, level, name_)
        self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('a = %e,\n' % self.getA())
        showIndent(outfile, level)
        outfile.write('b = %e,\n' % self.getB())
        showIndent(outfile, level)
        outfile.write('c = %e,\n' % self.getC())
        showIndent(outfile, level)
        outfile.write('alpha = %e,\n' % self.getAlpha())
        showIndent(outfile, level)
        outfile.write('beta = %e,\n' % self.getBeta())
        showIndent(outfile, level)
        outfile.write('gamma = %e,\n' % self.getGamma())
    def exportLiteralHtml(self, outfile, level = 0, name_='cell'):
        level += 1
        self.exportLiteralAttributesHtml(outfile, level, name_)
        self.exportLiteralChildrenHtml(outfile, level, name_)
    def exportLiteralAttributesHtml(self, outfile, level, name_):
        pass
    def exportLiteralChildrenHtml(self, outfile, level, name_):
        showIndentHtml(outfile, level)
        outfile.write('a = <a  href:"#">%e</a><br>\n' % self.getA())
        showIndentHtml(outfile, level)
        outfile.write('b = <a  href:"#">%e</a><br>\n' % self.getB())
        showIndentHtml(outfile, level)
        outfile.write('c = <a  href:"#">%e</a><br>\n' % self.getC())
        showIndentHtml(outfile, level)
        outfile.write('alpha = <a  href:"#">%e</a><br>\n' % self.getAlpha())
        showIndentHtml(outfile, level)
        outfile.write('beta = <a  href:"#">%e</a><br>\n' % self.getBeta())
        showIndentHtml(outfile, level)
        outfile.write('gamma = <a  href:"#">%e</a><br>\n' % self.getGamma())
    def build(self, node_):
        attrs = node_.attributes
        self.buildAttributes(attrs)
        for child_ in node_.childNodes:
            nodeName_ = child_.nodeName.split(':')[-1]
            self.buildChildren(child_, nodeName_)
    def buildAttributes(self, attrs):
        pass
    def buildChildren(self, child_, nodeName_):
        if child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'a':
            if child_.firstChild:
                sval_ = child_.firstChild.nodeValue
                try:
                    fval_ = float(sval_)
                except ValueError:
                    raise ValueError('requires float (or double) -- %s' % child_.toxml())
                self.a = fval_
        elif child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'b':
            if child_.firstChild:
                sval_ = child_.firstChild.nodeValue
                try:
                    fval_ = float(sval_)
                except ValueError:
                    raise ValueError('requires float (or double) -- %s' % child_.toxml())
                self.b = fval_
        elif child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'c':
            if child_.firstChild:
                sval_ = child_.firstChild.nodeValue
                try:
                    fval_ = float(sval_)
                except ValueError:
                    raise ValueError('requires float (or double) -- %s' % child_.toxml())
                self.c = fval_
        elif child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'alpha':
            if child_.firstChild:
                sval_ = child_.firstChild.nodeValue
                try:
                    fval_ = float(sval_)
                except ValueError:
                    raise ValueError('requires float (or double) -- %s' % child_.toxml())
                self.alpha = fval_
        elif child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'beta':
            if child_.firstChild:
                sval_ = child_.firstChild.nodeValue
                try:
                    fval_ = float(sval_)
                except ValueError:
                    raise ValueError('requires float (or double) -- %s' % child_.toxml())
                self.beta = fval_
        elif child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'gamma':
            if child_.firstChild:
                sval_ = child_.firstChild.nodeValue
                try:
                    fval_ = float(sval_)
                except ValueError:
                    raise ValueError('requires float (or double) -- %s' % child_.toxml())
                self.gamma = fval_
# end class cell


class experiment(object):
    subclass = None
    def __init__(self, wavelength=0.0, distance=0.0, resolution=None):
        self.wavelength = wavelength
        self.distance = distance
        self.resolution = resolution
    def factory(*args_, **kwargs_):
        if experiment.subclass:
            return experiment.subclass(*args_, **kwargs_)
        else:
            return experiment(*args_, **kwargs_)
    factory = staticmethod(factory)
    def getWavelength(self): return self.wavelength
    def setWavelength(self, wavelength): self.wavelength = wavelength
    def getDistance(self): return self.distance
    def setDistance(self, distance): self.distance = distance
    def getResolution(self): return self.resolution
    def setResolution(self, resolution): self.resolution = resolution
    def export(self, outfile, level = 0, name_='experiment'):
        showIndent(outfile, level)
        outfile.write('<%s>\n' % name_)
        self.exportChildren(outfile, level + 1, name_)
        showIndent(outfile, level)
        outfile.write('</%s>\n' % name_)
    def exportAttributes(self, outfile, level, name_='experiment'):
        pass
    def exportChildren(self, outfile, level, name_='experiment'):
        showIndent(outfile, level)
        outfile.write('<wavelength>%e</wavelength>\n' % self.getWavelength())
        showIndent(outfile, level)
        outfile.write('<distance>%e</distance>\n' % self.getDistance())
        if self.resolution:
            self.resolution.export(outfile, level)

    #Only to export the entire XML tree to a file stream on disk
    def outputFile( self, _outfileName ):
        outfile = open( _outfileName, "w" )
        outfile.write("<?xml version=\"1.0\" ?>\n")
        self.export( outfile, 0, name_='experiment' )
        outfile.close()


    #Only to export the entire XML tree to a Html Page in a file stream on disk
    def outputPageHtml( self, _outfileName ):
        odtStrTitle = "    <span class=\"title\">experiment:</span> <br> <br> <br>\n" 
        outfile = open( _outfileName, "w" )
        outfile.write( TEMPLATE_PAGE_P1 % ( odtStrTitle ) )
        self.exportLiteralHtml( outfile, 0, name_='experiment' )
        outfile.write( TEMPLATE_PAGE_P2  )
        outfile.close()


    def outputFileHtml( self, _outfileName ):
        self.outputPageHtml( _outfileName )



    #Static method for parsing a string
    def parseString( _inString ):
        doc = minidom.parseString(_inString)
        rootNode = doc.documentElement
        rootObj = experiment.factory()
        rootObj.build(rootNode)
        return rootObj
    parseString = staticmethod( parseString ) 


    #Method for marshalling an object
    def marshal( self ):
        oStreamString = StringIO.StringIO()
        oStreamString.write('<?xml version="1.0" ?>\n')
        self.export( oStreamString, 0, name_="experiment" )
        oStringXML = oStreamString.getvalue()
        oStreamString.close()
        return oStringXML

    def exportLiteral(self, outfile, level = 0, name_='experiment'):
        level += 1
        self.exportLiteralAttributes(outfile, level, name_)
        self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('wavelength = %e,\n' % self.getWavelength())
        showIndent(outfile, level)
        outfile.write('distance = %e,\n' % self.getDistance())
        if self.resolution:
            showIndent(outfile, level)
            outfile.write('resolution = resolution(\n')
            self.resolution.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
    def exportLiteralHtml(self, outfile, level = 0, name_='experiment'):
        level += 1
        self.exportLiteralAttributesHtml(outfile, level, name_)
        self.exportLiteralChildrenHtml(outfile, level, name_)
    def exportLiteralAttributesHtml(self, outfile, level, name_):
        pass
    def exportLiteralChildrenHtml(self, outfile, level, name_):
        showIndentHtml(outfile, level)
        outfile.write('wavelength = <a  href:"#">%e</a><br>\n' % self.getWavelength())
        showIndentHtml(outfile, level)
        outfile.write('distance = <a  href:"#">%e</a><br>\n' % self.getDistance())
        if self.resolution:
            showIndentHtml(outfile, level)
            outfile.write('resolution<br>\n')
            self.resolution.exportLiteralHtml(outfile, level)
            showIndentHtml(outfile, level)
            outfile.write('<br>\n')
    def build(self, node_):
        attrs = node_.attributes
        self.buildAttributes(attrs)
        for child_ in node_.childNodes:
            nodeName_ = child_.nodeName.split(':')[-1]
            self.buildChildren(child_, nodeName_)
    def buildAttributes(self, attrs):
        pass
    def buildChildren(self, child_, nodeName_):
        if child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'wavelength':
            if child_.firstChild:
                sval_ = child_.firstChild.nodeValue
                try:
                    fval_ = float(sval_)
                except ValueError:
                    raise ValueError('requires float (or double) -- %s' % child_.toxml())
                self.wavelength = fval_
        elif child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'distance':
            if child_.firstChild:
                sval_ = child_.firstChild.nodeValue
                try:
                    fval_ = float(sval_)
                except ValueError:
                    raise ValueError('requires float (or double) -- %s' % child_.toxml())
                self.distance = fval_
        elif child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'resolution':
            obj_ = resolution.factory()
            obj_.build(child_)
            self.setResolution(obj_)
# end class experiment


class matrix(object):
    subclass = None
    def __init__(self, e11=0.0, e12=0.0, e13=0.0, e21=0.0, e22=0.0, e23=0.0, e31=0.0, e32=0.0, e33=0.0):
        self.e11 = e11
        self.e12 = e12
        self.e13 = e13
        self.e21 = e21
        self.e22 = e22
        self.e23 = e23
        self.e31 = e31
        self.e32 = e32
        self.e33 = e33
    def factory(*args_, **kwargs_):
        if matrix.subclass:
            return matrix.subclass(*args_, **kwargs_)
        else:
            return matrix(*args_, **kwargs_)
    factory = staticmethod(factory)
    def getE11(self): return self.e11
    def setE11(self, e11): self.e11 = e11
    def getE12(self): return self.e12
    def setE12(self, e12): self.e12 = e12
    def getE13(self): return self.e13
    def setE13(self, e13): self.e13 = e13
    def getE21(self): return self.e21
    def setE21(self, e21): self.e21 = e21
    def getE22(self): return self.e22
    def setE22(self, e22): self.e22 = e22
    def getE23(self): return self.e23
    def setE23(self, e23): self.e23 = e23
    def getE31(self): return self.e31
    def setE31(self, e31): self.e31 = e31
    def getE32(self): return self.e32
    def setE32(self, e32): self.e32 = e32
    def getE33(self): return self.e33
    def setE33(self, e33): self.e33 = e33
    def export(self, outfile, level = 0, name_='matrix'):
        showIndent(outfile, level)
        outfile.write('<%s>\n' % name_)
        self.exportChildren(outfile, level + 1, name_)
        showIndent(outfile, level)
        outfile.write('</%s>\n' % name_)
    def exportAttributes(self, outfile, level, name_='matrix'):
        pass
    def exportChildren(self, outfile, level, name_='matrix'):
        showIndent(outfile, level)
        outfile.write('<e11>%e</e11>\n' % self.getE11())
        showIndent(outfile, level)
        outfile.write('<e12>%e</e12>\n' % self.getE12())
        showIndent(outfile, level)
        outfile.write('<e13>%e</e13>\n' % self.getE13())
        showIndent(outfile, level)
        outfile.write('<e21>%e</e21>\n' % self.getE21())
        showIndent(outfile, level)
        outfile.write('<e22>%e</e22>\n' % self.getE22())
        showIndent(outfile, level)
        outfile.write('<e23>%e</e23>\n' % self.getE23())
        showIndent(outfile, level)
        outfile.write('<e31>%e</e31>\n' % self.getE31())
        showIndent(outfile, level)
        outfile.write('<e32>%e</e32>\n' % self.getE32())
        showIndent(outfile, level)
        outfile.write('<e33>%e</e33>\n' % self.getE33())

    #Only to export the entire XML tree to a file stream on disk
    def outputFile( self, _outfileName ):
        outfile = open( _outfileName, "w" )
        outfile.write("<?xml version=\"1.0\" ?>\n")
        self.export( outfile, 0, name_='matrix' )
        outfile.close()


    #Only to export the entire XML tree to a Html Page in a file stream on disk
    def outputPageHtml( self, _outfileName ):
        odtStrTitle = "    <span class=\"title\">matrix:</span> <br> <br> <br>\n" 
        outfile = open( _outfileName, "w" )
        outfile.write( TEMPLATE_PAGE_P1 % ( odtStrTitle ) )
        self.exportLiteralHtml( outfile, 0, name_='matrix' )
        outfile.write( TEMPLATE_PAGE_P2  )
        outfile.close()


    def outputFileHtml( self, _outfileName ):
        self.outputPageHtml( _outfileName )



    #Static method for parsing a string
    def parseString( _inString ):
        doc = minidom.parseString(_inString)
        rootNode = doc.documentElement
        rootObj = matrix.factory()
        rootObj.build(rootNode)
        return rootObj
    parseString = staticmethod( parseString ) 


    #Method for marshalling an object
    def marshal( self ):
        oStreamString = StringIO.StringIO()
        oStreamString.write('<?xml version="1.0" ?>\n')
        self.export( oStreamString, 0, name_="matrix" )
        oStringXML = oStreamString.getvalue()
        oStreamString.close()
        return oStringXML

    def exportLiteral(self, outfile, level = 0, name_='matrix'):
        level += 1
        self.exportLiteralAttributes(outfile, level, name_)
        self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('e11 = %e,\n' % self.getE11())
        showIndent(outfile, level)
        outfile.write('e12 = %e,\n' % self.getE12())
        showIndent(outfile, level)
        outfile.write('e13 = %e,\n' % self.getE13())
        showIndent(outfile, level)
        outfile.write('e21 = %e,\n' % self.getE21())
        showIndent(outfile, level)
        outfile.write('e22 = %e,\n' % self.getE22())
        showIndent(outfile, level)
        outfile.write('e23 = %e,\n' % self.getE23())
        showIndent(outfile, level)
        outfile.write('e31 = %e,\n' % self.getE31())
        showIndent(outfile, level)
        outfile.write('e32 = %e,\n' % self.getE32())
        showIndent(outfile, level)
        outfile.write('e33 = %e,\n' % self.getE33())
    def exportLiteralHtml(self, outfile, level = 0, name_='matrix'):
        level += 1
        self.exportLiteralAttributesHtml(outfile, level, name_)
        self.exportLiteralChildrenHtml(outfile, level, name_)
    def exportLiteralAttributesHtml(self, outfile, level, name_):
        pass
    def exportLiteralChildrenHtml(self, outfile, level, name_):
        showIndentHtml(outfile, level)
        outfile.write('e11 = <a  href:"#">%e</a><br>\n' % self.getE11())
        showIndentHtml(outfile, level)
        outfile.write('e12 = <a  href:"#">%e</a><br>\n' % self.getE12())
        showIndentHtml(outfile, level)
        outfile.write('e13 = <a  href:"#">%e</a><br>\n' % self.getE13())
        showIndentHtml(outfile, level)
        outfile.write('e21 = <a  href:"#">%e</a><br>\n' % self.getE21())
        showIndentHtml(outfile, level)
        outfile.write('e22 = <a  href:"#">%e</a><br>\n' % self.getE22())
        showIndentHtml(outfile, level)
        outfile.write('e23 = <a  href:"#">%e</a><br>\n' % self.getE23())
        showIndentHtml(outfile, level)
        outfile.write('e31 = <a  href:"#">%e</a><br>\n' % self.getE31())
        showIndentHtml(outfile, level)
        outfile.write('e32 = <a  href:"#">%e</a><br>\n' % self.getE32())
        showIndentHtml(outfile, level)
        outfile.write('e33 = <a  href:"#">%e</a><br>\n' % self.getE33())
    def build(self, node_):
        attrs = node_.attributes
        self.buildAttributes(attrs)
        for child_ in node_.childNodes:
            nodeName_ = child_.nodeName.split(':')[-1]
            self.buildChildren(child_, nodeName_)
    def buildAttributes(self, attrs):
        pass
    def buildChildren(self, child_, nodeName_):
        if child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'e11':
            if child_.firstChild:
                sval_ = child_.firstChild.nodeValue
                try:
                    fval_ = float(sval_)
                except ValueError:
                    raise ValueError('requires float (or double) -- %s' % child_.toxml())
                self.e11 = fval_
        elif child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'e12':
            if child_.firstChild:
                sval_ = child_.firstChild.nodeValue
                try:
                    fval_ = float(sval_)
                except ValueError:
                    raise ValueError('requires float (or double) -- %s' % child_.toxml())
                self.e12 = fval_
        elif child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'e13':
            if child_.firstChild:
                sval_ = child_.firstChild.nodeValue
                try:
                    fval_ = float(sval_)
                except ValueError:
                    raise ValueError('requires float (or double) -- %s' % child_.toxml())
                self.e13 = fval_
        elif child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'e21':
            if child_.firstChild:
                sval_ = child_.firstChild.nodeValue
                try:
                    fval_ = float(sval_)
                except ValueError:
                    raise ValueError('requires float (or double) -- %s' % child_.toxml())
                self.e21 = fval_
        elif child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'e22':
            if child_.firstChild:
                sval_ = child_.firstChild.nodeValue
                try:
                    fval_ = float(sval_)
                except ValueError:
                    raise ValueError('requires float (or double) -- %s' % child_.toxml())
                self.e22 = fval_
        elif child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'e23':
            if child_.firstChild:
                sval_ = child_.firstChild.nodeValue
                try:
                    fval_ = float(sval_)
                except ValueError:
                    raise ValueError('requires float (or double) -- %s' % child_.toxml())
                self.e23 = fval_
        elif child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'e31':
            if child_.firstChild:
                sval_ = child_.firstChild.nodeValue
                try:
                    fval_ = float(sval_)
                except ValueError:
                    raise ValueError('requires float (or double) -- %s' % child_.toxml())
                self.e31 = fval_
        elif child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'e32':
            if child_.firstChild:
                sval_ = child_.firstChild.nodeValue
                try:
                    fval_ = float(sval_)
                except ValueError:
                    raise ValueError('requires float (or double) -- %s' % child_.toxml())
                self.e32 = fval_
        elif child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'e33':
            if child_.firstChild:
                sval_ = child_.firstChild.nodeValue
                try:
                    fval_ = float(sval_)
                except ValueError:
                    raise ValueError('requires float (or double) -- %s' % child_.toxml())
                self.e33 = fval_
# end class matrix


class dna_message(object):
    subclass = None
    def __init__(self, ttype='', content_type='', level='', message=''):
        self.ttype = ttype
        self.content_type = content_type
        self.level = level
        self.message = message
    def factory(*args_, **kwargs_):
        if dna_message.subclass:
            return dna_message.subclass(*args_, **kwargs_)
        else:
            return dna_message(*args_, **kwargs_)
    factory = staticmethod(factory)
    def getType(self): return self.ttype
    def setType(self, ttype): self.ttype = ttype
    def getContent_type(self): return self.content_type
    def setContent_type(self, content_type): self.content_type = content_type
    def getLevel(self): return self.level
    def setLevel(self, level): self.level = level
    def getMessage(self): return self.message
    def setMessage(self, message): self.message = message
    def export(self, outfile, level = 0, name_='dna_message'):
        showIndent(outfile, level)
        outfile.write('<%s>\n' % name_)
        self.exportChildren(outfile, level + 1, name_)
        showIndent(outfile, level)
        outfile.write('</%s>\n' % name_)
    def exportAttributes(self, outfile, level, name_='dna_message'):
        pass
    def exportChildren(self, outfile, level, name_='dna_message'):
        showIndent(outfile, level)
        outfile.write('<type>%s</type>\n' % quote_xml(self.getType()))
        showIndent(outfile, level)
        outfile.write('<content_type>%s</content_type>\n' % quote_xml(self.getContent_type()))
        showIndent(outfile, level)
        outfile.write('<level>%s</level>\n' % quote_xml(self.getLevel()))
        showIndent(outfile, level)
        outfile.write('<message>%s</message>\n' % quote_xml(self.getMessage()))

    #Only to export the entire XML tree to a file stream on disk
    def outputFile( self, _outfileName ):
        outfile = open( _outfileName, "w" )
        outfile.write("<?xml version=\"1.0\" ?>\n")
        self.export( outfile, 0, name_='dna_message' )
        outfile.close()


    #Only to export the entire XML tree to a Html Page in a file stream on disk
    def outputPageHtml( self, _outfileName ):
        odtStrTitle = "    <span class=\"title\">dna_message:</span> <br> <br> <br>\n" 
        outfile = open( _outfileName, "w" )
        outfile.write( TEMPLATE_PAGE_P1 % ( odtStrTitle ) )
        self.exportLiteralHtml( outfile, 0, name_='dna_message' )
        outfile.write( TEMPLATE_PAGE_P2  )
        outfile.close()


    def outputFileHtml( self, _outfileName ):
        self.outputPageHtml( _outfileName )



    #Static method for parsing a string
    def parseString( _inString ):
        doc = minidom.parseString(_inString)
        rootNode = doc.documentElement
        rootObj = dna_message.factory()
        rootObj.build(rootNode)
        return rootObj
    parseString = staticmethod( parseString ) 


    #Method for marshalling an object
    def marshal( self ):
        oStreamString = StringIO.StringIO()
        oStreamString.write('<?xml version="1.0" ?>\n')
        self.export( oStreamString, 0, name_="dna_message" )
        oStringXML = oStreamString.getvalue()
        oStreamString.close()
        return oStringXML

    def exportLiteral(self, outfile, level = 0, name_='dna_message'):
        level += 1
        self.exportLiteralAttributes(outfile, level, name_)
        self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('ttype = %s,\n' % quote_python(self.getType()))
        showIndent(outfile, level)
        outfile.write('content_type = %s,\n' % quote_python(self.getContent_type()))
        showIndent(outfile, level)
        outfile.write('level = %s,\n' % quote_python(self.getLevel()))
        showIndent(outfile, level)
        outfile.write('message = %s,\n' % quote_python(self.getMessage()))
    def exportLiteralHtml(self, outfile, level = 0, name_='dna_message'):
        level += 1
        self.exportLiteralAttributesHtml(outfile, level, name_)
        self.exportLiteralChildrenHtml(outfile, level, name_)
    def exportLiteralAttributesHtml(self, outfile, level, name_):
        pass
    def exportLiteralChildrenHtml(self, outfile, level, name_):
        showIndentHtml(outfile, level)
        outfile.write('ttype = <a  href:"#">%s</a><br>\n' % quote_python(self.getType()))
        showIndentHtml(outfile, level)
        outfile.write('content_type = <a  href:"#">%s</a><br>\n' % quote_python(self.getContent_type()))
        showIndentHtml(outfile, level)
        outfile.write('level = <a  href:"#">%s</a><br>\n' % quote_python(self.getLevel()))
        showIndentHtml(outfile, level)
        outfile.write('message = <a  href:"#">%s</a><br>\n' % quote_python(self.getMessage()))
    def build(self, node_):
        attrs = node_.attributes
        self.buildAttributes(attrs)
        for child_ in node_.childNodes:
            nodeName_ = child_.nodeName.split(':')[-1]
            self.buildChildren(child_, nodeName_)
    def buildAttributes(self, attrs):
        pass
    def buildChildren(self, child_, nodeName_):
        if child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'type':
            type_ = ''
            for text__content_ in child_.childNodes:
                type_ += text__content_.nodeValue
            self.ttype = type_
        elif child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'content_type':
            content_type_ = ''
            for text__content_ in child_.childNodes:
                content_type_ += text__content_.nodeValue
            self.content_type = content_type_
        elif child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'level':
            level_ = ''
            for text__content_ in child_.childNodes:
                level_ += text__content_.nodeValue
            self.level = level_
        elif child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'message':
            message_ = ''
            for text__content_ in child_.childNodes:
                message_ += text__content_.nodeValue
            self.message = message_
# end class dna_message


class input_reflections(object):
    subclass = None
    def __init__(self, hklin=None):
        if hklin is None:
            self.hklin = []
        else:
            self.hklin = hklin
    def factory(*args_, **kwargs_):
        if input_reflections.subclass:
            return input_reflections.subclass(*args_, **kwargs_)
        else:
            return input_reflections(*args_, **kwargs_)
    factory = staticmethod(factory)
    def getHklin(self): return self.hklin
    def setHklin(self, hklin): self.hklin = hklin
    def addHklin(self, value): self.hklin.append(value)
    def insertHklin(self, index, value): self.hklin[index] = value
    def export(self, outfile, level = 0, name_='input_reflections'):
        showIndent(outfile, level)
        outfile.write('<%s>\n' % name_)
        self.exportChildren(outfile, level + 1, name_)
        showIndent(outfile, level)
        outfile.write('</%s>\n' % name_)
    def exportAttributes(self, outfile, level, name_='input_reflections'):
        pass
    def exportChildren(self, outfile, level, name_='input_reflections'):
        for hklin_ in self.getHklin():
            showIndent(outfile, level)
            outfile.write('<hklin>%s</hklin>\n' % quote_xml(hklin_))

    #Only to export the entire XML tree to a file stream on disk
    def outputFile( self, _outfileName ):
        outfile = open( _outfileName, "w" )
        outfile.write("<?xml version=\"1.0\" ?>\n")
        self.export( outfile, 0, name_='input_reflections' )
        outfile.close()


    #Only to export the entire XML tree to a Html Page in a file stream on disk
    def outputPageHtml( self, _outfileName ):
        odtStrTitle = "    <span class=\"title\">input_reflections:</span> <br> <br> <br>\n" 
        outfile = open( _outfileName, "w" )
        outfile.write( TEMPLATE_PAGE_P1 % ( odtStrTitle ) )
        self.exportLiteralHtml( outfile, 0, name_='input_reflections' )
        outfile.write( TEMPLATE_PAGE_P2  )
        outfile.close()


    def outputFileHtml( self, _outfileName ):
        self.outputPageHtml( _outfileName )



    #Static method for parsing a string
    def parseString( _inString ):
        doc = minidom.parseString(_inString)
        rootNode = doc.documentElement
        rootObj = input_reflections.factory()
        rootObj.build(rootNode)
        return rootObj
    parseString = staticmethod( parseString ) 


    #Method for marshalling an object
    def marshal( self ):
        oStreamString = StringIO.StringIO()
        oStreamString.write('<?xml version="1.0" ?>\n')
        self.export( oStreamString, 0, name_="input_reflections" )
        oStringXML = oStreamString.getvalue()
        oStreamString.close()
        return oStringXML

    def exportLiteral(self, outfile, level = 0, name_='input_reflections'):
        level += 1
        self.exportLiteralAttributes(outfile, level, name_)
        self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('hklin=[\n')
        level += 1
        for hklin in self.hklin:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(hklin))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def exportLiteralHtml(self, outfile, level = 0, name_='input_reflections'):
        level += 1
        self.exportLiteralAttributesHtml(outfile, level, name_)
        self.exportLiteralChildrenHtml(outfile, level, name_)
    def exportLiteralAttributesHtml(self, outfile, level, name_):
        pass
    def exportLiteralChildrenHtml(self, outfile, level, name_):
        showIndentHtml(outfile, level)
        outfile.write('hklin<br>\n')
        level += 1
        for hklin in self.hklin:
            showIndentHtml(outfile, level)
            outfile.write('<a  href:"#">%s</a><br>\n' % quote_python(hklin))
        level -= 1
        showIndentHtml(outfile, level)
        outfile.write('<br>\n')
    def build(self, node_):
        attrs = node_.attributes
        self.buildAttributes(attrs)
        for child_ in node_.childNodes:
            nodeName_ = child_.nodeName.split(':')[-1]
            self.buildChildren(child_, nodeName_)
    def buildAttributes(self, attrs):
        pass
    def buildChildren(self, child_, nodeName_):
        if child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'hklin':
            hklin_ = ''
            for text__content_ in child_.childNodes:
                hklin_ += text__content_.nodeValue
            self.hklin.append(hklin_)
# end class input_reflections


class output_reflections(object):
    subclass = None
    def __init__(self, hklout=''):
        self.hklout = hklout
    def factory(*args_, **kwargs_):
        if output_reflections.subclass:
            return output_reflections.subclass(*args_, **kwargs_)
        else:
            return output_reflections(*args_, **kwargs_)
    factory = staticmethod(factory)
    def getHklout(self): return self.hklout
    def setHklout(self, hklout): self.hklout = hklout
    def export(self, outfile, level = 0, name_='output_reflections'):
        showIndent(outfile, level)
        outfile.write('<%s>\n' % name_)
        self.exportChildren(outfile, level + 1, name_)
        showIndent(outfile, level)
        outfile.write('</%s>\n' % name_)
    def exportAttributes(self, outfile, level, name_='output_reflections'):
        pass
    def exportChildren(self, outfile, level, name_='output_reflections'):
        showIndent(outfile, level)
        outfile.write('<hklout>%s</hklout>\n' % quote_xml(self.getHklout()))

    #Only to export the entire XML tree to a file stream on disk
    def outputFile( self, _outfileName ):
        outfile = open( _outfileName, "w" )
        outfile.write("<?xml version=\"1.0\" ?>\n")
        self.export( outfile, 0, name_='output_reflections' )
        outfile.close()


    #Only to export the entire XML tree to a Html Page in a file stream on disk
    def outputPageHtml( self, _outfileName ):
        odtStrTitle = "    <span class=\"title\">output_reflections:</span> <br> <br> <br>\n" 
        outfile = open( _outfileName, "w" )
        outfile.write( TEMPLATE_PAGE_P1 % ( odtStrTitle ) )
        self.exportLiteralHtml( outfile, 0, name_='output_reflections' )
        outfile.write( TEMPLATE_PAGE_P2  )
        outfile.close()


    def outputFileHtml( self, _outfileName ):
        self.outputPageHtml( _outfileName )



    #Static method for parsing a string
    def parseString( _inString ):
        doc = minidom.parseString(_inString)
        rootNode = doc.documentElement
        rootObj = output_reflections.factory()
        rootObj.build(rootNode)
        return rootObj
    parseString = staticmethod( parseString ) 


    #Method for marshalling an object
    def marshal( self ):
        oStreamString = StringIO.StringIO()
        oStreamString.write('<?xml version="1.0" ?>\n')
        self.export( oStreamString, 0, name_="output_reflections" )
        oStringXML = oStreamString.getvalue()
        oStreamString.close()
        return oStringXML

    def exportLiteral(self, outfile, level = 0, name_='output_reflections'):
        level += 1
        self.exportLiteralAttributes(outfile, level, name_)
        self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('hklout = %s,\n' % quote_python(self.getHklout()))
    def exportLiteralHtml(self, outfile, level = 0, name_='output_reflections'):
        level += 1
        self.exportLiteralAttributesHtml(outfile, level, name_)
        self.exportLiteralChildrenHtml(outfile, level, name_)
    def exportLiteralAttributesHtml(self, outfile, level, name_):
        pass
    def exportLiteralChildrenHtml(self, outfile, level, name_):
        showIndentHtml(outfile, level)
        outfile.write('hklout = <a  href:"#">%s</a><br>\n' % quote_python(self.getHklout()))
    def build(self, node_):
        attrs = node_.attributes
        self.buildAttributes(attrs)
        for child_ in node_.childNodes:
            nodeName_ = child_.nodeName.split(':')[-1]
            self.buildChildren(child_, nodeName_)
    def buildAttributes(self, attrs):
        pass
    def buildChildren(self, child_, nodeName_):
        if child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'hklout':
            hklout_ = ''
            for text__content_ in child_.childNodes:
                hklout_ += text__content_.nodeValue
            self.hklout = hklout_
# end class output_reflections


class resolution(object):
    subclass = None
    def __init__(self, lower=0.0, upper=0.0):
        self.lower = lower
        self.upper = upper
    def factory(*args_, **kwargs_):
        if resolution.subclass:
            return resolution.subclass(*args_, **kwargs_)
        else:
            return resolution(*args_, **kwargs_)
    factory = staticmethod(factory)
    def getLower(self): return self.lower
    def setLower(self, lower): self.lower = lower
    def getUpper(self): return self.upper
    def setUpper(self, upper): self.upper = upper
    def export(self, outfile, level = 0, name_='resolution'):
        showIndent(outfile, level)
        outfile.write('<%s>\n' % name_)
        self.exportChildren(outfile, level + 1, name_)
        showIndent(outfile, level)
        outfile.write('</%s>\n' % name_)
    def exportAttributes(self, outfile, level, name_='resolution'):
        pass
    def exportChildren(self, outfile, level, name_='resolution'):
        showIndent(outfile, level)
        outfile.write('<lower>%e</lower>\n' % self.getLower())
        showIndent(outfile, level)
        outfile.write('<upper>%e</upper>\n' % self.getUpper())

    #Only to export the entire XML tree to a file stream on disk
    def outputFile( self, _outfileName ):
        outfile = open( _outfileName, "w" )
        outfile.write("<?xml version=\"1.0\" ?>\n")
        self.export( outfile, 0, name_='resolution' )
        outfile.close()


    #Only to export the entire XML tree to a Html Page in a file stream on disk
    def outputPageHtml( self, _outfileName ):
        odtStrTitle = "    <span class=\"title\">resolution:</span> <br> <br> <br>\n" 
        outfile = open( _outfileName, "w" )
        outfile.write( TEMPLATE_PAGE_P1 % ( odtStrTitle ) )
        self.exportLiteralHtml( outfile, 0, name_='resolution' )
        outfile.write( TEMPLATE_PAGE_P2  )
        outfile.close()


    def outputFileHtml( self, _outfileName ):
        self.outputPageHtml( _outfileName )



    #Static method for parsing a string
    def parseString( _inString ):
        doc = minidom.parseString(_inString)
        rootNode = doc.documentElement
        rootObj = resolution.factory()
        rootObj.build(rootNode)
        return rootObj
    parseString = staticmethod( parseString ) 


    #Method for marshalling an object
    def marshal( self ):
        oStreamString = StringIO.StringIO()
        oStreamString.write('<?xml version="1.0" ?>\n')
        self.export( oStreamString, 0, name_="resolution" )
        oStringXML = oStreamString.getvalue()
        oStreamString.close()
        return oStringXML

    def exportLiteral(self, outfile, level = 0, name_='resolution'):
        level += 1
        self.exportLiteralAttributes(outfile, level, name_)
        self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('lower = %e,\n' % self.getLower())
        showIndent(outfile, level)
        outfile.write('upper = %e,\n' % self.getUpper())
    def exportLiteralHtml(self, outfile, level = 0, name_='resolution'):
        level += 1
        self.exportLiteralAttributesHtml(outfile, level, name_)
        self.exportLiteralChildrenHtml(outfile, level, name_)
    def exportLiteralAttributesHtml(self, outfile, level, name_):
        pass
    def exportLiteralChildrenHtml(self, outfile, level, name_):
        showIndentHtml(outfile, level)
        outfile.write('lower = <a  href:"#">%e</a><br>\n' % self.getLower())
        showIndentHtml(outfile, level)
        outfile.write('upper = <a  href:"#">%e</a><br>\n' % self.getUpper())
    def build(self, node_):
        attrs = node_.attributes
        self.buildAttributes(attrs)
        for child_ in node_.childNodes:
            nodeName_ = child_.nodeName.split(':')[-1]
            self.buildChildren(child_, nodeName_)
    def buildAttributes(self, attrs):
        pass
    def buildChildren(self, child_, nodeName_):
        if child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'lower':
            if child_.firstChild:
                sval_ = child_.firstChild.nodeValue
                try:
                    fval_ = float(sval_)
                except ValueError:
                    raise ValueError('requires float (or double) -- %s' % child_.toxml())
                self.lower = fval_
        elif child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'upper':
            if child_.firstChild:
                sval_ = child_.firstChild.nodeValue
                try:
                    fval_ = float(sval_)
                except ValueError:
                    raise ValueError('requires float (or double) -- %s' % child_.toxml())
                self.upper = fval_
# end class resolution


class abort_request(object):
    subclass = None
    def __init__(self, level=''):
        self.level = level
    def factory(*args_, **kwargs_):
        if abort_request.subclass:
            return abort_request.subclass(*args_, **kwargs_)
        else:
            return abort_request(*args_, **kwargs_)
    factory = staticmethod(factory)
    def getLevel(self): return self.level
    def setLevel(self, level): self.level = level
    def export(self, outfile, level = 0, name_='abort_request'):
        showIndent(outfile, level)
        outfile.write('<%s>\n' % name_)
        self.exportChildren(outfile, level + 1, name_)
        showIndent(outfile, level)
        outfile.write('</%s>\n' % name_)
    def exportAttributes(self, outfile, level, name_='abort_request'):
        pass
    def exportChildren(self, outfile, level, name_='abort_request'):
        showIndent(outfile, level)
        outfile.write('<level>%s</level>\n' % quote_xml(self.getLevel()))

    #Only to export the entire XML tree to a file stream on disk
    def outputFile( self, _outfileName ):
        outfile = open( _outfileName, "w" )
        outfile.write("<?xml version=\"1.0\" ?>\n")
        self.export( outfile, 0, name_='abort_request' )
        outfile.close()


    #Only to export the entire XML tree to a Html Page in a file stream on disk
    def outputPageHtml( self, _outfileName ):
        odtStrTitle = "    <span class=\"title\">abort_request:</span> <br> <br> <br>\n" 
        outfile = open( _outfileName, "w" )
        outfile.write( TEMPLATE_PAGE_P1 % ( odtStrTitle ) )
        self.exportLiteralHtml( outfile, 0, name_='abort_request' )
        outfile.write( TEMPLATE_PAGE_P2  )
        outfile.close()


    def outputFileHtml( self, _outfileName ):
        self.outputPageHtml( _outfileName )



    #Static method for parsing a string
    def parseString( _inString ):
        doc = minidom.parseString(_inString)
        rootNode = doc.documentElement
        rootObj = abort_request.factory()
        rootObj.build(rootNode)
        return rootObj
    parseString = staticmethod( parseString ) 


    #Method for marshalling an object
    def marshal( self ):
        oStreamString = StringIO.StringIO()
        oStreamString.write('<?xml version="1.0" ?>\n')
        self.export( oStreamString, 0, name_="abort_request" )
        oStringXML = oStreamString.getvalue()
        oStreamString.close()
        return oStringXML

    def exportLiteral(self, outfile, level = 0, name_='abort_request'):
        level += 1
        self.exportLiteralAttributes(outfile, level, name_)
        self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('level = %s,\n' % quote_python(self.getLevel()))
    def exportLiteralHtml(self, outfile, level = 0, name_='abort_request'):
        level += 1
        self.exportLiteralAttributesHtml(outfile, level, name_)
        self.exportLiteralChildrenHtml(outfile, level, name_)
    def exportLiteralAttributesHtml(self, outfile, level, name_):
        pass
    def exportLiteralChildrenHtml(self, outfile, level, name_):
        showIndentHtml(outfile, level)
        outfile.write('level = <a  href:"#">%s</a><br>\n' % quote_python(self.getLevel()))
    def build(self, node_):
        attrs = node_.attributes
        self.buildAttributes(attrs)
        for child_ in node_.childNodes:
            nodeName_ = child_.nodeName.split(':')[-1]
            self.buildChildren(child_, nodeName_)
    def buildAttributes(self, attrs):
        pass
    def buildChildren(self, child_, nodeName_):
        if child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'level':
            level_ = ''
            for text__content_ in child_.childNodes:
                level_ += text__content_.nodeValue
            self.level = level_
# end class abort_request


class abort_response(object):
    subclass = None
    def __init__(self, status=None):
        self.status = status
    def factory(*args_, **kwargs_):
        if abort_response.subclass:
            return abort_response.subclass(*args_, **kwargs_)
        else:
            return abort_response(*args_, **kwargs_)
    factory = staticmethod(factory)
    def getStatus(self): return self.status
    def setStatus(self, status): self.status = status
    def export(self, outfile, level = 0, name_='abort_response'):
        showIndent(outfile, level)
        outfile.write('<%s>\n' % name_)
        self.exportChildren(outfile, level + 1, name_)
        showIndent(outfile, level)
        outfile.write('</%s>\n' % name_)
    def exportAttributes(self, outfile, level, name_='abort_response'):
        pass
    def exportChildren(self, outfile, level, name_='abort_response'):
        if self.status:
            self.status.export(outfile, level)

    #Only to export the entire XML tree to a file stream on disk
    def outputFile( self, _outfileName ):
        outfile = open( _outfileName, "w" )
        outfile.write("<?xml version=\"1.0\" ?>\n")
        self.export( outfile, 0, name_='abort_response' )
        outfile.close()


    #Only to export the entire XML tree to a Html Page in a file stream on disk
    def outputPageHtml( self, _outfileName ):
        odtStrTitle = "    <span class=\"title\">abort_response:</span> <br> <br> <br>\n" 
        outfile = open( _outfileName, "w" )
        outfile.write( TEMPLATE_PAGE_P1 % ( odtStrTitle ) )
        self.exportLiteralHtml( outfile, 0, name_='abort_response' )
        outfile.write( TEMPLATE_PAGE_P2  )
        outfile.close()


    def outputFileHtml( self, _outfileName ):
        self.outputPageHtml( _outfileName )



    #Static method for parsing a string
    def parseString( _inString ):
        doc = minidom.parseString(_inString)
        rootNode = doc.documentElement
        rootObj = abort_response.factory()
        rootObj.build(rootNode)
        return rootObj
    parseString = staticmethod( parseString ) 


    #Method for marshalling an object
    def marshal( self ):
        oStreamString = StringIO.StringIO()
        oStreamString.write('<?xml version="1.0" ?>\n')
        self.export( oStreamString, 0, name_="abort_response" )
        oStringXML = oStreamString.getvalue()
        oStreamString.close()
        return oStringXML

    def exportLiteral(self, outfile, level = 0, name_='abort_response'):
        level += 1
        self.exportLiteralAttributes(outfile, level, name_)
        self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.status:
            showIndent(outfile, level)
            outfile.write('status = status(\n')
            self.status.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
    def exportLiteralHtml(self, outfile, level = 0, name_='abort_response'):
        level += 1
        self.exportLiteralAttributesHtml(outfile, level, name_)
        self.exportLiteralChildrenHtml(outfile, level, name_)
    def exportLiteralAttributesHtml(self, outfile, level, name_):
        pass
    def exportLiteralChildrenHtml(self, outfile, level, name_):
        if self.status:
            showIndentHtml(outfile, level)
            outfile.write('status<br>\n')
            self.status.exportLiteralHtml(outfile, level)
            showIndentHtml(outfile, level)
            outfile.write('<br>\n')
    def build(self, node_):
        attrs = node_.attributes
        self.buildAttributes(attrs)
        for child_ in node_.childNodes:
            nodeName_ = child_.nodeName.split(':')[-1]
            self.buildChildren(child_, nodeName_)
    def buildAttributes(self, attrs):
        pass
    def buildChildren(self, child_, nodeName_):
        if child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'status':
            obj_ = status.factory()
            obj_.build(child_)
            self.setStatus(obj_)
# end class abort_response


class sample_reference(object):
    subclass = None
    def __init__(self, code='', container_reference='', container_code='', sample_location='', blSampleId=''):
        self.code = code
        self.container_reference = container_reference
        self.container_code = container_code
        self.sample_location = sample_location
        self.blSampleId = blSampleId
    def factory(*args_, **kwargs_):
        if sample_reference.subclass:
            return sample_reference.subclass(*args_, **kwargs_)
        else:
            return sample_reference(*args_, **kwargs_)
    factory = staticmethod(factory)
    def getCode(self): return self.code
    def setCode(self, code): self.code = code
    def getContainer_reference(self): return self.container_reference
    def setContainer_reference(self, container_reference): self.container_reference = container_reference
    def getContainer_code(self): return self.container_code
    def setContainer_code(self, container_code): self.container_code = container_code
    def getSample_location(self): return self.sample_location
    def setSample_location(self, sample_location): self.sample_location = sample_location
    def getBlSampleId(self): return self.blSampleId
    def setBlSampleId(self, blSampleId): self.blSampleId = blSampleId
    def export(self, outfile, level = 0, name_='sample_reference'):
        showIndent(outfile, level)
        outfile.write('<%s>\n' % name_)
        self.exportChildren(outfile, level + 1, name_)
        showIndent(outfile, level)
        outfile.write('</%s>\n' % name_)
    def exportAttributes(self, outfile, level, name_='sample_reference'):
        pass
    def exportChildren(self, outfile, level, name_='sample_reference'):
        showIndent(outfile, level)
        outfile.write('<code>%s</code>\n' % quote_xml(self.getCode()))
        showIndent(outfile, level)
        outfile.write('<container_reference>%s</container_reference>\n' % quote_xml(self.getContainer_reference()))
        showIndent(outfile, level)
        outfile.write('<container_code>%s</container_code>\n' % quote_xml(self.getContainer_code()))
        showIndent(outfile, level)
        outfile.write('<sample_location>%s</sample_location>\n' % quote_xml(self.getSample_location()))
        showIndent(outfile, level)
        outfile.write('<blSampleId>%s</blSampleId>\n' % quote_xml(self.getBlSampleId()))

    #Only to export the entire XML tree to a file stream on disk
    def outputFile( self, _outfileName ):
        outfile = open( _outfileName, "w" )
        outfile.write("<?xml version=\"1.0\" ?>\n")
        self.export( outfile, 0, name_='sample_reference' )
        outfile.close()


    #Only to export the entire XML tree to a Html Page in a file stream on disk
    def outputPageHtml( self, _outfileName ):
        odtStrTitle = "    <span class=\"title\">sample_reference:</span> <br> <br> <br>\n" 
        outfile = open( _outfileName, "w" )
        outfile.write( TEMPLATE_PAGE_P1 % ( odtStrTitle ) )
        self.exportLiteralHtml( outfile, 0, name_='sample_reference' )
        outfile.write( TEMPLATE_PAGE_P2  )
        outfile.close()


    def outputFileHtml( self, _outfileName ):
        self.outputPageHtml( _outfileName )



    #Static method for parsing a string
    def parseString( _inString ):
        doc = minidom.parseString(_inString)
        rootNode = doc.documentElement
        rootObj = sample_reference.factory()
        rootObj.build(rootNode)
        return rootObj
    parseString = staticmethod( parseString ) 


    #Method for marshalling an object
    def marshal( self ):
        oStreamString = StringIO.StringIO()
        oStreamString.write('<?xml version="1.0" ?>\n')
        self.export( oStreamString, 0, name_="sample_reference" )
        oStringXML = oStreamString.getvalue()
        oStreamString.close()
        return oStringXML

    def exportLiteral(self, outfile, level = 0, name_='sample_reference'):
        level += 1
        self.exportLiteralAttributes(outfile, level, name_)
        self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('code = %s,\n' % quote_python(self.getCode()))
        showIndent(outfile, level)
        outfile.write('container_reference = %s,\n' % quote_python(self.getContainer_reference()))
        showIndent(outfile, level)
        outfile.write('container_code = %s,\n' % quote_python(self.getContainer_code()))
        showIndent(outfile, level)
        outfile.write('sample_location = %s,\n' % quote_python(self.getSample_location()))
        showIndent(outfile, level)
        outfile.write('blSampleId = %s,\n' % quote_python(self.getBlSampleId()))
    def exportLiteralHtml(self, outfile, level = 0, name_='sample_reference'):
        level += 1
        self.exportLiteralAttributesHtml(outfile, level, name_)
        self.exportLiteralChildrenHtml(outfile, level, name_)
    def exportLiteralAttributesHtml(self, outfile, level, name_):
        pass
    def exportLiteralChildrenHtml(self, outfile, level, name_):
        showIndentHtml(outfile, level)
        outfile.write('code = <a  href:"#">%s</a><br>\n' % quote_python(self.getCode()))
        showIndentHtml(outfile, level)
        outfile.write('container_reference = <a  href:"#">%s</a><br>\n' % quote_python(self.getContainer_reference()))
        showIndentHtml(outfile, level)
        outfile.write('container_code = <a  href:"#">%s</a><br>\n' % quote_python(self.getContainer_code()))
        showIndentHtml(outfile, level)
        outfile.write('sample_location = <a  href:"#">%s</a><br>\n' % quote_python(self.getSample_location()))
        showIndentHtml(outfile, level)
        outfile.write('blSampleId = <a  href:"#">%s</a><br>\n' % quote_python(self.getBlSampleId()))
    def build(self, node_):
        attrs = node_.attributes
        self.buildAttributes(attrs)
        for child_ in node_.childNodes:
            nodeName_ = child_.nodeName.split(':')[-1]
            self.buildChildren(child_, nodeName_)
    def buildAttributes(self, attrs):
        pass
    def buildChildren(self, child_, nodeName_):
        if child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'code':
            code_ = ''
            for text__content_ in child_.childNodes:
                code_ += text__content_.nodeValue
            self.code = code_
        elif child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'container_reference':
            container_reference_ = ''
            for text__content_ in child_.childNodes:
                container_reference_ += text__content_.nodeValue
            self.container_reference = container_reference_
        elif child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'container_code':
            container_code_ = ''
            for text__content_ in child_.childNodes:
                container_code_ += text__content_.nodeValue
            self.container_code = container_code_
        elif child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'sample_location':
            sample_location_ = ''
            for text__content_ in child_.childNodes:
                sample_location_ += text__content_.nodeValue
            self.sample_location = sample_location_
        elif child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'blSampleId':
            blSampleId_ = ''
            for text__content_ in child_.childNodes:
                blSampleId_ += text__content_.nodeValue
            self.blSampleId = blSampleId_
# end class sample_reference


class beamline_parameters(object):
    subclass = None
    def __init__(self, maximum_exposure=0.0, minimum_exposure_time=0.0, minimum_phi_speed=0.0, maximum_phi_speed=0.0, minimum_phi_oscillation=0.0):
        self.maximum_exposure = maximum_exposure
        self.minimum_exposure_time = minimum_exposure_time
        self.minimum_phi_speed = minimum_phi_speed
        self.maximum_phi_speed = maximum_phi_speed
        self.minimum_phi_oscillation = minimum_phi_oscillation
    def factory(*args_, **kwargs_):
        if beamline_parameters.subclass:
            return beamline_parameters.subclass(*args_, **kwargs_)
        else:
            return beamline_parameters(*args_, **kwargs_)
    factory = staticmethod(factory)
    def getMaximum_exposure(self): return self.maximum_exposure
    def setMaximum_exposure(self, maximum_exposure): self.maximum_exposure = maximum_exposure
    def getMinimum_exposure_time(self): return self.minimum_exposure_time
    def setMinimum_exposure_time(self, minimum_exposure_time): self.minimum_exposure_time = minimum_exposure_time
    def getMinimum_phi_speed(self): return self.minimum_phi_speed
    def setMinimum_phi_speed(self, minimum_phi_speed): self.minimum_phi_speed = minimum_phi_speed
    def getMaximum_phi_speed(self): return self.maximum_phi_speed
    def setMaximum_phi_speed(self, maximum_phi_speed): self.maximum_phi_speed = maximum_phi_speed
    def getMinimum_phi_oscillation(self): return self.minimum_phi_oscillation
    def setMinimum_phi_oscillation(self, minimum_phi_oscillation): self.minimum_phi_oscillation = minimum_phi_oscillation
    def export(self, outfile, level = 0, name_='beamline_parameters'):
        showIndent(outfile, level)
        outfile.write('<%s>\n' % name_)
        self.exportChildren(outfile, level + 1, name_)
        showIndent(outfile, level)
        outfile.write('</%s>\n' % name_)
    def exportAttributes(self, outfile, level, name_='beamline_parameters'):
        pass
    def exportChildren(self, outfile, level, name_='beamline_parameters'):
        showIndent(outfile, level)
        outfile.write('<maximum_exposure>%e</maximum_exposure>\n' % self.getMaximum_exposure())
        showIndent(outfile, level)
        outfile.write('<minimum_exposure_time>%e</minimum_exposure_time>\n' % self.getMinimum_exposure_time())
        showIndent(outfile, level)
        outfile.write('<minimum_phi_speed>%e</minimum_phi_speed>\n' % self.getMinimum_phi_speed())
        showIndent(outfile, level)
        outfile.write('<maximum_phi_speed>%e</maximum_phi_speed>\n' % self.getMaximum_phi_speed())
        showIndent(outfile, level)
        outfile.write('<minimum_phi_oscillation>%e</minimum_phi_oscillation>\n' % self.getMinimum_phi_oscillation())

    #Only to export the entire XML tree to a file stream on disk
    def outputFile( self, _outfileName ):
        outfile = open( _outfileName, "w" )
        outfile.write("<?xml version=\"1.0\" ?>\n")
        self.export( outfile, 0, name_='beamline_parameters' )
        outfile.close()


    #Only to export the entire XML tree to a Html Page in a file stream on disk
    def outputPageHtml( self, _outfileName ):
        odtStrTitle = "    <span class=\"title\">beamline_parameters:</span> <br> <br> <br>\n" 
        outfile = open( _outfileName, "w" )
        outfile.write( TEMPLATE_PAGE_P1 % ( odtStrTitle ) )
        self.exportLiteralHtml( outfile, 0, name_='beamline_parameters' )
        outfile.write( TEMPLATE_PAGE_P2  )
        outfile.close()


    def outputFileHtml( self, _outfileName ):
        self.outputPageHtml( _outfileName )



    #Static method for parsing a string
    def parseString( _inString ):
        doc = minidom.parseString(_inString)
        rootNode = doc.documentElement
        rootObj = beamline_parameters.factory()
        rootObj.build(rootNode)
        return rootObj
    parseString = staticmethod( parseString ) 


    #Method for marshalling an object
    def marshal( self ):
        oStreamString = StringIO.StringIO()
        oStreamString.write('<?xml version="1.0" ?>\n')
        self.export( oStreamString, 0, name_="beamline_parameters" )
        oStringXML = oStreamString.getvalue()
        oStreamString.close()
        return oStringXML

    def exportLiteral(self, outfile, level = 0, name_='beamline_parameters'):
        level += 1
        self.exportLiteralAttributes(outfile, level, name_)
        self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('maximum_exposure = %e,\n' % self.getMaximum_exposure())
        showIndent(outfile, level)
        outfile.write('minimum_exposure_time = %e,\n' % self.getMinimum_exposure_time())
        showIndent(outfile, level)
        outfile.write('minimum_phi_speed = %e,\n' % self.getMinimum_phi_speed())
        showIndent(outfile, level)
        outfile.write('maximum_phi_speed = %e,\n' % self.getMaximum_phi_speed())
        showIndent(outfile, level)
        outfile.write('minimum_phi_oscillation = %e,\n' % self.getMinimum_phi_oscillation())
    def exportLiteralHtml(self, outfile, level = 0, name_='beamline_parameters'):
        level += 1
        self.exportLiteralAttributesHtml(outfile, level, name_)
        self.exportLiteralChildrenHtml(outfile, level, name_)
    def exportLiteralAttributesHtml(self, outfile, level, name_):
        pass
    def exportLiteralChildrenHtml(self, outfile, level, name_):
        showIndentHtml(outfile, level)
        outfile.write('maximum_exposure = <a  href:"#">%e</a><br>\n' % self.getMaximum_exposure())
        showIndentHtml(outfile, level)
        outfile.write('minimum_exposure_time = <a  href:"#">%e</a><br>\n' % self.getMinimum_exposure_time())
        showIndentHtml(outfile, level)
        outfile.write('minimum_phi_speed = <a  href:"#">%e</a><br>\n' % self.getMinimum_phi_speed())
        showIndentHtml(outfile, level)
        outfile.write('maximum_phi_speed = <a  href:"#">%e</a><br>\n' % self.getMaximum_phi_speed())
        showIndentHtml(outfile, level)
        outfile.write('minimum_phi_oscillation = <a  href:"#">%e</a><br>\n' % self.getMinimum_phi_oscillation())
    def build(self, node_):
        attrs = node_.attributes
        self.buildAttributes(attrs)
        for child_ in node_.childNodes:
            nodeName_ = child_.nodeName.split(':')[-1]
            self.buildChildren(child_, nodeName_)
    def buildAttributes(self, attrs):
        pass
    def buildChildren(self, child_, nodeName_):
        if child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'maximum_exposure':
            if child_.firstChild:
                sval_ = child_.firstChild.nodeValue
                try:
                    fval_ = float(sval_)
                except ValueError:
                    raise ValueError('requires float (or double) -- %s' % child_.toxml())
                self.maximum_exposure = fval_
        elif child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'minimum_exposure_time':
            if child_.firstChild:
                sval_ = child_.firstChild.nodeValue
                try:
                    fval_ = float(sval_)
                except ValueError:
                    raise ValueError('requires float (or double) -- %s' % child_.toxml())
                self.minimum_exposure_time = fval_
        elif child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'minimum_phi_speed':
            if child_.firstChild:
                sval_ = child_.firstChild.nodeValue
                try:
                    fval_ = float(sval_)
                except ValueError:
                    raise ValueError('requires float (or double) -- %s' % child_.toxml())
                self.minimum_phi_speed = fval_
        elif child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'maximum_phi_speed':
            if child_.firstChild:
                sval_ = child_.firstChild.nodeValue
                try:
                    fval_ = float(sval_)
                except ValueError:
                    raise ValueError('requires float (or double) -- %s' % child_.toxml())
                self.maximum_phi_speed = fval_
        elif child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'minimum_phi_oscillation':
            if child_.firstChild:
                sval_ = child_.firstChild.nodeValue
                try:
                    fval_ = float(sval_)
                except ValueError:
                    raise ValueError('requires float (or double) -- %s' % child_.toxml())
                self.minimum_phi_oscillation = fval_
# end class beamline_parameters




def parse(inFileName):
    doc = minidom.parse(inFileName)
    rootNode = doc.documentElement
    rootObj = system_defaults.factory()
    rootObj.build(rootNode)
    # Enable Python to collect the space used by the DOM.
    doc.unlink()
#    doc = None
    return rootObj


def parseString(inString):
    doc = minidom.parseString(inString)
    rootNode = doc.documentElement
    rootObj = system_defaults.factory()
    rootObj.build(rootNode)
    # Enable Python to collect the space used by the DOM.
    doc.unlink()
#    doc = None
#    sys.stdout.write('<?xml version="1.0" ?>\n')
#    rootObj.export(sys.stdout, 0, name_="system_defaults")
    return rootObj


# AAlib Modifications for marshalling and unmarshalling
# Creating program data constructs from XML
def unMarshalling( _inFileName ):
    return parse(  _inFileName )


# Serializing program data constructs to XML
def marshalling( _oObject, _inFileName ):
    oFile = open( _inFileName, "w" )
    oFile.write('<?xml version="1.0" ?>\n')
    _oObject.export( oFile, 0, name_="system_defaults" )
    oFile.close()

